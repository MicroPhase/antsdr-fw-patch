From 0c4049dd0bf7a7ede5838bb40e0a78ea92e2b6e5 Mon Sep 17 00:00:00 2001
From: Wei Chaochen <1530604142@qq.com>
Date: Tue, 21 Nov 2023 16:33:03 +0800
Subject: [PATCH] add ant hdl support, bump to version v0.38

---
 .../axi_vcxo_ctrl_v1_0/data/axi_vcxo_ctrl.mdd |  10 +
 .../axi_vcxo_ctrl_v1_0/data/axi_vcxo_ctrl.tcl |   5 +
 .../drivers/axi_vcxo_ctrl_v1_0/src/Makefile   |  26 +
 .../axi_vcxo_ctrl_v1_0/src/axi_vcxo_ctrl.c    |   6 +
 .../axi_vcxo_ctrl_v1_0/src/axi_vcxo_ctrl.h    |  83 ++++
 .../src/axi_vcxo_ctrl_selftest.c              |  60 +++
 .../bfm_design/axi_vcxo_ctrl_v1_0_tb.sv       | 197 ++++++++
 .../example_designs/bfm_design/design.tcl     |  88 ++++
 .../axi_vcxo_ctrl_v1_0_hw_test.tcl            |  45 ++
 .../debug_hw_design/design.tcl                | 118 +++++
 .../hdl/axi_vcxo_ctrl_v1_0.v                  | 153 ++++++
 .../hdl/axi_vcxo_ctrl_v1_0_S00_AXI.v          | 458 ++++++++++++++++++
 library/axi_vcxo_ctrl_1.0/hdl/b205_ref_pll.v  | 327 +++++++++++++
 library/axi_vcxo_ctrl_1.0/hdl/ltc2630_spi.v   | 151 ++++++
 library/axi_vcxo_ctrl_1.0/src/b205_ref_pll.v  | 334 +++++++++++++
 library/axi_vcxo_ctrl_1.0/src/ltc2630_spi.v   | 151 ++++++
 projects/ant/Makefile                         |  24 +
 projects/ant/system_bd.tcl                    | 376 ++++++++++++++
 projects/ant/system_constr.xdc                |  91 ++++
 projects/ant/system_project.tcl               |  15 +
 projects/ant/system_top.v                     | 233 +++++++++
 projects/e200/Makefile                        |  25 +
 projects/e200/system_bd.tcl                   | 406 ++++++++++++++++
 projects/e200/system_constr.xdc               | 108 +++++
 projects/e200/system_project.tcl              |  16 +
 projects/e200/system_top.v                    | 251 ++++++++++
 projects/e310v2/Makefile                      |  25 +
 projects/e310v2/system_bd.tcl                 | 408 ++++++++++++++++
 projects/e310v2/system_constr.xdc             | 123 +++++
 projects/e310v2/system_project.tcl            |  16 +
 projects/e310v2/system_top.v                  | 272 +++++++++++
 31 files changed, 4601 insertions(+)
 create mode 100644 library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/data/axi_vcxo_ctrl.mdd
 create mode 100644 library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/data/axi_vcxo_ctrl.tcl
 create mode 100644 library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/src/Makefile
 create mode 100644 library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/src/axi_vcxo_ctrl.c
 create mode 100644 library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/src/axi_vcxo_ctrl.h
 create mode 100644 library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/src/axi_vcxo_ctrl_selftest.c
 create mode 100644 library/axi_vcxo_ctrl_1.0/example_designs/bfm_design/axi_vcxo_ctrl_v1_0_tb.sv
 create mode 100644 library/axi_vcxo_ctrl_1.0/example_designs/bfm_design/design.tcl
 create mode 100644 library/axi_vcxo_ctrl_1.0/example_designs/debug_hw_design/axi_vcxo_ctrl_v1_0_hw_test.tcl
 create mode 100644 library/axi_vcxo_ctrl_1.0/example_designs/debug_hw_design/design.tcl
 create mode 100644 library/axi_vcxo_ctrl_1.0/hdl/axi_vcxo_ctrl_v1_0.v
 create mode 100644 library/axi_vcxo_ctrl_1.0/hdl/axi_vcxo_ctrl_v1_0_S00_AXI.v
 create mode 100644 library/axi_vcxo_ctrl_1.0/hdl/b205_ref_pll.v
 create mode 100644 library/axi_vcxo_ctrl_1.0/hdl/ltc2630_spi.v
 create mode 100644 library/axi_vcxo_ctrl_1.0/src/b205_ref_pll.v
 create mode 100644 library/axi_vcxo_ctrl_1.0/src/ltc2630_spi.v
 create mode 100644 projects/ant/Makefile
 create mode 100644 projects/ant/system_bd.tcl
 create mode 100644 projects/ant/system_constr.xdc
 create mode 100644 projects/ant/system_project.tcl
 create mode 100644 projects/ant/system_top.v
 create mode 100644 projects/e200/Makefile
 create mode 100644 projects/e200/system_bd.tcl
 create mode 100644 projects/e200/system_constr.xdc
 create mode 100644 projects/e200/system_project.tcl
 create mode 100644 projects/e200/system_top.v
 create mode 100644 projects/e310v2/Makefile
 create mode 100644 projects/e310v2/system_bd.tcl
 create mode 100644 projects/e310v2/system_constr.xdc
 create mode 100644 projects/e310v2/system_project.tcl
 create mode 100644 projects/e310v2/system_top.v

diff --git a/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/data/axi_vcxo_ctrl.mdd b/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/data/axi_vcxo_ctrl.mdd
new file mode 100644
index 000000000..6d1e57326
--- /dev/null
+++ b/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/data/axi_vcxo_ctrl.mdd
@@ -0,0 +1,10 @@
+
+
+OPTION psf_version = 2.1;
+
+BEGIN DRIVER axi_vcxo_ctrl
+	OPTION supported_peripherals = (axi_vcxo_ctrl);
+	OPTION copyfiles = all;
+	OPTION VERSION = 1.0;
+	OPTION NAME = axi_vcxo_ctrl;
+END DRIVER
diff --git a/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/data/axi_vcxo_ctrl.tcl b/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/data/axi_vcxo_ctrl.tcl
new file mode 100644
index 000000000..8a6c5c3ff
--- /dev/null
+++ b/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/data/axi_vcxo_ctrl.tcl
@@ -0,0 +1,5 @@
+
+
+proc generate {drv_handle} {
+	xdefine_include_file $drv_handle "xparameters.h" "axi_vcxo_ctrl" "NUM_INSTANCES" "DEVICE_ID"  "C_S00_AXI_BASEADDR" "C_S00_AXI_HIGHADDR"
+}
diff --git a/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/src/Makefile b/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/src/Makefile
new file mode 100644
index 000000000..a515fe497
--- /dev/null
+++ b/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/src/Makefile
@@ -0,0 +1,26 @@
+COMPILER=
+ARCHIVER=
+CP=cp
+COMPILER_FLAGS=
+EXTRA_COMPILER_FLAGS=
+LIB=libxil.a
+
+RELEASEDIR=../../../lib
+INCLUDEDIR=../../../include
+INCLUDES=-I./. -I${INCLUDEDIR}
+
+INCLUDEFILES=*.h
+LIBSOURCES=*.c
+OUTS = *.o
+
+libs:
+	echo "Compiling axi_vcxo_ctrl..."
+	$(COMPILER) $(COMPILER_FLAGS) $(EXTRA_COMPILER_FLAGS) $(INCLUDES) $(LIBSOURCES)
+	$(ARCHIVER) -r ${RELEASEDIR}/${LIB} ${OUTS}
+	make clean
+
+include:
+	${CP} $(INCLUDEFILES) $(INCLUDEDIR)
+
+clean:
+	rm -rf ${OUTS}
diff --git a/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/src/axi_vcxo_ctrl.c b/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/src/axi_vcxo_ctrl.c
new file mode 100644
index 000000000..f0177eb13
--- /dev/null
+++ b/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/src/axi_vcxo_ctrl.c
@@ -0,0 +1,6 @@
+
+
+/***************************** Include Files *******************************/
+#include "axi_vcxo_ctrl.h"
+
+/************************** Function Definitions ***************************/
diff --git a/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/src/axi_vcxo_ctrl.h b/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/src/axi_vcxo_ctrl.h
new file mode 100644
index 000000000..89eb186f8
--- /dev/null
+++ b/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/src/axi_vcxo_ctrl.h
@@ -0,0 +1,83 @@
+
+#ifndef AXI_VCXO_CTRL_H
+#define AXI_VCXO_CTRL_H
+
+
+/****************** Include Files ********************/
+#include "xil_types.h"
+#include "xstatus.h"
+
+#define AXI_VCXO_CTRL_S00_AXI_SLV_REG0_OFFSET 0
+#define AXI_VCXO_CTRL_S00_AXI_SLV_REG1_OFFSET 4
+#define AXI_VCXO_CTRL_S00_AXI_SLV_REG2_OFFSET 8
+#define AXI_VCXO_CTRL_S00_AXI_SLV_REG3_OFFSET 12
+#define AXI_VCXO_CTRL_S00_AXI_SLV_REG4_OFFSET 16
+#define AXI_VCXO_CTRL_S00_AXI_SLV_REG5_OFFSET 20
+#define AXI_VCXO_CTRL_S00_AXI_SLV_REG6_OFFSET 24
+#define AXI_VCXO_CTRL_S00_AXI_SLV_REG7_OFFSET 28
+
+
+/**************************** Type Definitions *****************************/
+/**
+ *
+ * Write a value to a AXI_VCXO_CTRL register. A 32 bit write is performed.
+ * If the component is implemented in a smaller width, only the least
+ * significant data is written.
+ *
+ * @param   BaseAddress is the base address of the AXI_VCXO_CTRLdevice.
+ * @param   RegOffset is the register offset from the base to write to.
+ * @param   Data is the data written to the register.
+ *
+ * @return  None.
+ *
+ * @note
+ * C-style signature:
+ * 	void AXI_VCXO_CTRL_mWriteReg(u32 BaseAddress, unsigned RegOffset, u32 Data)
+ *
+ */
+#define AXI_VCXO_CTRL_mWriteReg(BaseAddress, RegOffset, Data) \
+  	Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))
+
+/**
+ *
+ * Read a value from a AXI_VCXO_CTRL register. A 32 bit read is performed.
+ * If the component is implemented in a smaller width, only the least
+ * significant data is read from the register. The most significant data
+ * will be read as 0.
+ *
+ * @param   BaseAddress is the base address of the AXI_VCXO_CTRL device.
+ * @param   RegOffset is the register offset from the base to write to.
+ *
+ * @return  Data is the data from the register.
+ *
+ * @note
+ * C-style signature:
+ * 	u32 AXI_VCXO_CTRL_mReadReg(u32 BaseAddress, unsigned RegOffset)
+ *
+ */
+#define AXI_VCXO_CTRL_mReadReg(BaseAddress, RegOffset) \
+    Xil_In32((BaseAddress) + (RegOffset))
+
+/************************** Function Prototypes ****************************/
+/**
+ *
+ * Run a self-test on the driver/device. Note this may be a destructive test if
+ * resets of the device are performed.
+ *
+ * If the hardware system is not built correctly, this function may never
+ * return to the caller.
+ *
+ * @param   baseaddr_p is the base address of the AXI_VCXO_CTRL instance to be worked on.
+ *
+ * @return
+ *
+ *    - XST_SUCCESS   if all self-test code passed
+ *    - XST_FAILURE   if any self-test code failed
+ *
+ * @note    Caching must be turned off for this function to work.
+ * @note    Self test may fail if data memory and device are not on the same bus.
+ *
+ */
+XStatus AXI_VCXO_CTRL_Reg_SelfTest(void * baseaddr_p);
+
+#endif // AXI_VCXO_CTRL_H
diff --git a/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/src/axi_vcxo_ctrl_selftest.c b/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/src/axi_vcxo_ctrl_selftest.c
new file mode 100644
index 000000000..eb5213308
--- /dev/null
+++ b/library/axi_vcxo_ctrl_1.0/drivers/axi_vcxo_ctrl_v1_0/src/axi_vcxo_ctrl_selftest.c
@@ -0,0 +1,60 @@
+
+/***************************** Include Files *******************************/
+#include "axi_vcxo_ctrl.h"
+#include "xparameters.h"
+#include "stdio.h"
+#include "xil_io.h"
+
+/************************** Constant Definitions ***************************/
+#define READ_WRITE_MUL_FACTOR 0x10
+
+/************************** Function Definitions ***************************/
+/**
+ *
+ * Run a self-test on the driver/device. Note this may be a destructive test if
+ * resets of the device are performed.
+ *
+ * If the hardware system is not built correctly, this function may never
+ * return to the caller.
+ *
+ * @param   baseaddr_p is the base address of the AXI_VCXO_CTRLinstance to be worked on.
+ *
+ * @return
+ *
+ *    - XST_SUCCESS   if all self-test code passed
+ *    - XST_FAILURE   if any self-test code failed
+ *
+ * @note    Caching must be turned off for this function to work.
+ * @note    Self test may fail if data memory and device are not on the same bus.
+ *
+ */
+XStatus AXI_VCXO_CTRL_Reg_SelfTest(void * baseaddr_p)
+{
+	u32 baseaddr;
+	int write_loop_index;
+	int read_loop_index;
+	int Index;
+
+	baseaddr = (u32) baseaddr_p;
+
+	xil_printf("******************************\n\r");
+	xil_printf("* User Peripheral Self Test\n\r");
+	xil_printf("******************************\n\n\r");
+
+	/*
+	 * Write to user logic slave module register(s) and read back
+	 */
+	xil_printf("User logic slave module test...\n\r");
+
+	for (write_loop_index = 0 ; write_loop_index < 4; write_loop_index++)
+	  AXI_VCXO_CTRL_mWriteReg (baseaddr, write_loop_index*4, (write_loop_index+1)*READ_WRITE_MUL_FACTOR);
+	for (read_loop_index = 0 ; read_loop_index < 4; read_loop_index++)
+	  if ( AXI_VCXO_CTRL_mReadReg (baseaddr, read_loop_index*4) != (read_loop_index+1)*READ_WRITE_MUL_FACTOR){
+	    xil_printf ("Error reading register value at address %x\n", (int)baseaddr + read_loop_index*4);
+	    return XST_FAILURE;
+	  }
+
+	xil_printf("   - slave register write/read passed\n\n\r");
+
+	return XST_SUCCESS;
+}
diff --git a/library/axi_vcxo_ctrl_1.0/example_designs/bfm_design/axi_vcxo_ctrl_v1_0_tb.sv b/library/axi_vcxo_ctrl_1.0/example_designs/bfm_design/axi_vcxo_ctrl_v1_0_tb.sv
new file mode 100644
index 000000000..6c2fd8ea8
--- /dev/null
+++ b/library/axi_vcxo_ctrl_1.0/example_designs/bfm_design/axi_vcxo_ctrl_v1_0_tb.sv
@@ -0,0 +1,197 @@
+
+`timescale 1ns / 1ps
+`include "axi_vcxo_ctrl_v1_0_tb_include.svh"
+
+import axi_vip_pkg::*;
+import axi_vcxo_ctrl_v1_0_bfm_1_master_0_0_pkg::*;
+
+module axi_vcxo_ctrl_v1_0_tb();
+
+
+xil_axi_uint                            error_cnt = 0;
+xil_axi_uint                            comparison_cnt = 0;
+axi_transaction                         wr_transaction;   
+axi_transaction                         rd_transaction;   
+axi_monitor_transaction                 mst_monitor_transaction;  
+axi_monitor_transaction                 master_moniter_transaction_queue[$];  
+xil_axi_uint                            master_moniter_transaction_queue_size =0;  
+axi_monitor_transaction                 mst_scb_transaction;  
+axi_monitor_transaction                 passthrough_monitor_transaction;  
+axi_monitor_transaction                 passthrough_master_moniter_transaction_queue[$];  
+xil_axi_uint                            passthrough_master_moniter_transaction_queue_size =0;  
+axi_monitor_transaction                 passthrough_mst_scb_transaction;  
+axi_monitor_transaction                 passthrough_slave_moniter_transaction_queue[$];  
+xil_axi_uint                            passthrough_slave_moniter_transaction_queue_size =0;  
+axi_monitor_transaction                 passthrough_slv_scb_transaction;  
+axi_monitor_transaction                 slv_monitor_transaction;  
+axi_monitor_transaction                 slave_moniter_transaction_queue[$];  
+xil_axi_uint                            slave_moniter_transaction_queue_size =0;  
+axi_monitor_transaction                 slv_scb_transaction;  
+xil_axi_uint                           mst_agent_verbosity = 0;  
+xil_axi_uint                           slv_agent_verbosity = 0;  
+xil_axi_uint                           passthrough_agent_verbosity = 0;  
+bit                                     clock;
+bit                                     reset;
+integer result_slave;  
+bit [31:0] S00_AXI_test_data[3:0]; 
+ localparam LC_AXI_BURST_LENGTH = 8; 
+ localparam LC_AXI_DATA_WIDTH = 32; 
+task automatic COMPARE_DATA; 
+  input [(LC_AXI_BURST_LENGTH * LC_AXI_DATA_WIDTH)-1:0]expected; 
+  input [(LC_AXI_BURST_LENGTH * LC_AXI_DATA_WIDTH)-1:0]actual; 
+  begin 
+    if (expected === 'hx || actual === 'hx) begin 
+      $display("TESTBENCH ERROR! COMPARE_DATA cannot be performed with an expected or actual vector that is all 'x'!"); 
+ result_slave = 0;    $stop; 
+  end 
+  if (actual != expected) begin 
+    $display("TESTBENCH ERROR! Data expected is not equal to actual.",     " expected = 0x%h",expected,     " actual   = 0x%h",actual); 
+    result_slave = 0; 
+    $stop; 
+  end 
+  else  
+    begin 
+     $display("TESTBENCH Passed! Data expected is equal to actual.", 
+              " expected = 0x%h",expected,               " actual   = 0x%h",actual); 
+    end 
+  end 
+endtask 
+integer                                 i; 
+integer                                 j;  
+xil_axi_uint                            trans_cnt_before_switch = 48;  
+xil_axi_uint                            passthrough_cmd_switch_cnt = 0;  
+event                                   passthrough_mastermode_start_event;  
+event                                   passthrough_mastermode_end_event;  
+event                                   passthrough_slavemode_end_event;  
+xil_axi_uint                            mtestID;  
+xil_axi_ulong                           mtestADDR;  
+xil_axi_len_t                           mtestBurstLength;  
+xil_axi_size_t                          mtestDataSize;   
+xil_axi_burst_t                         mtestBurstType;   
+xil_axi_lock_t                          mtestLOCK;  
+xil_axi_cache_t                         mtestCacheType = 0;  
+xil_axi_prot_t                          mtestProtectionType = 3'b000;  
+xil_axi_region_t                        mtestRegion = 4'b000;  
+xil_axi_qos_t                           mtestQOS = 4'b000;  
+xil_axi_data_beat                       dbeat;  
+xil_axi_data_beat [255:0]               mtestWUSER;   
+xil_axi_data_beat                       mtestAWUSER = 'h0;  
+xil_axi_data_beat                       mtestARUSER = 0;  
+xil_axi_data_beat [255:0]               mtestRUSER;      
+xil_axi_uint                            mtestBUSER = 0;  
+xil_axi_resp_t                          mtestBresp;  
+xil_axi_resp_t[255:0]                   mtestRresp;  
+bit [63:0]                              mtestWDataL; 
+bit [63:0]                              mtestRDataL; 
+axi_transaction                         pss_wr_transaction;   
+axi_transaction                         pss_rd_transaction;   
+axi_transaction                         reactive_transaction;   
+axi_transaction                         rd_payload_transaction;  
+axi_transaction                         wr_rand;  
+axi_transaction                         rd_rand;  
+axi_transaction                         wr_reactive;  
+axi_transaction                         rd_reactive;  
+axi_transaction                         wr_reactive2;   
+axi_transaction                         rd_reactive2;  
+axi_ready_gen                           bready_gen;  
+axi_ready_gen                           rready_gen;  
+axi_ready_gen                           awready_gen;  
+axi_ready_gen                           wready_gen;  
+axi_ready_gen                           arready_gen;  
+axi_ready_gen                           bready_gen2;  
+axi_ready_gen                           rready_gen2;  
+axi_ready_gen                           awready_gen2;  
+axi_ready_gen                           wready_gen2;  
+axi_ready_gen                           arready_gen2;  
+xil_axi_payload_byte                    data_mem[xil_axi_ulong];  
+axi_vcxo_ctrl_v1_0_bfm_1_master_0_0_mst_t          mst_agent_0;
+
+  `BD_WRAPPER DUT(
+      .ARESETN(reset), 
+      .ACLK(clock) 
+    ); 
+  
+initial begin
+     mst_agent_0 = new("master vip agent",DUT.`BD_INST_NAME.master_0.inst.IF);//ms  
+   mst_agent_0.vif_proxy.set_dummy_drive_type(XIL_AXI_VIF_DRIVE_NONE); 
+   mst_agent_0.set_agent_tag("Master VIP"); 
+   mst_agent_0.set_verbosity(mst_agent_verbosity); 
+   mst_agent_0.start_master(); 
+     $timeformat (-12, 1, " ps", 1);
+  end
+  initial begin
+    reset <= 1'b0;
+    #200ns;
+    reset <= 1'b1;
+    repeat (5) @(negedge clock); 
+  end
+  always #5 clock <= ~clock;
+  initial begin
+      S_AXI_TEST ( );
+
+      #1ns;
+      $finish;
+  end
+task automatic S_AXI_TEST;  
+begin   
+#1; 
+   $display("Sequential write transfers example similar to  AXI BFM WRITE_BURST method starts"); 
+   mtestID = 0; 
+   mtestADDR = 64'h00000000; 
+   mtestBurstLength = 0; 
+   mtestDataSize = xil_axi_size_t'(xil_clog2(32/8)); 
+   mtestBurstType = XIL_AXI_BURST_TYPE_INCR;  
+   mtestLOCK = XIL_AXI_ALOCK_NOLOCK;  
+   mtestCacheType = 0;  
+   mtestProtectionType = 0;  
+   mtestRegion = 0; 
+   mtestQOS = 0; 
+   result_slave = 1; 
+  mtestWDataL[31:0] = 32'h00000001; 
+  for(int i = 0; i < 4;i++) begin 
+  S00_AXI_test_data[i] <= mtestWDataL[31:0];   
+  mst_agent_0.AXI4LITE_WRITE_BURST( 
+  mtestADDR, 
+  mtestProtectionType, 
+  mtestWDataL, 
+  mtestBresp 
+  );   
+  mtestWDataL[31:0] = mtestWDataL[31:0] + 1; 
+  mtestADDR = mtestADDR + 64'h4; 
+  end 
+     $display("Sequential write transfers example similar to  AXI BFM WRITE_BURST method completes"); 
+     $display("Sequential read transfers example similar to  AXI BFM READ_BURST method starts"); 
+     mtestID = 0; 
+     mtestADDR = 64'h00000000; 
+     mtestBurstLength = 0; 
+     mtestDataSize = xil_axi_size_t'(xil_clog2(32/8)); 
+     mtestBurstType = XIL_AXI_BURST_TYPE_INCR;  
+     mtestLOCK = XIL_AXI_ALOCK_NOLOCK;  
+     mtestCacheType = 0;  
+     mtestProtectionType = 0;  
+     mtestRegion = 0; 
+     mtestQOS = 0; 
+ for(int i = 0; i < 4;i++) begin 
+   mst_agent_0.AXI4LITE_READ_BURST( 
+        mtestADDR, 
+        mtestProtectionType, 
+        mtestRDataL, 
+        mtestRresp 
+      ); 
+   mtestADDR = mtestADDR + 64'h4; 
+   COMPARE_DATA(S00_AXI_test_data[i],mtestRDataL); 
+ end 
+     $display("Sequential read transfers example similar to  AXI BFM READ_BURST method completes"); 
+     $display("Sequential read transfers example similar to  AXI VIP READ_BURST method completes"); 
+     $display("---------------------------------------------------------"); 
+     $display("EXAMPLE TEST S00_AXI: PTGEN_TEST_FINISHED!"); 
+     if ( result_slave ) begin                    
+       $display("PTGEN_TEST: PASSED!");                  
+     end    else begin                                       
+       $display("PTGEN_TEST: FAILED!");                  
+     end                                
+     $display("---------------------------------------------------------"); 
+  end 
+endtask  
+
+endmodule
diff --git a/library/axi_vcxo_ctrl_1.0/example_designs/bfm_design/design.tcl b/library/axi_vcxo_ctrl_1.0/example_designs/bfm_design/design.tcl
new file mode 100644
index 000000000..5f5073856
--- /dev/null
+++ b/library/axi_vcxo_ctrl_1.0/example_designs/bfm_design/design.tcl
@@ -0,0 +1,88 @@
+proc create_ipi_design { offsetfile design_name } {
+	create_bd_design $design_name
+	open_bd_design $design_name
+
+	# Create Clock and Reset Ports
+	set ACLK [ create_bd_port -dir I -type clk ACLK ]
+	set_property -dict [ list CONFIG.FREQ_HZ {100000000} CONFIG.PHASE {0.000} CONFIG.CLK_DOMAIN "${design_name}_ACLK" ] $ACLK
+	set ARESETN [ create_bd_port -dir I -type rst ARESETN ]
+	set_property -dict [ list CONFIG.POLARITY {ACTIVE_LOW}  ] $ARESETN
+	set_property CONFIG.ASSOCIATED_RESET ARESETN $ACLK
+
+	# Create instance: axi_vcxo_ctrl_0, and set properties
+	set axi_vcxo_ctrl_0 [ create_bd_cell -type ip -vlnv user.org:user:axi_vcxo_ctrl:1.0 axi_vcxo_ctrl_0]
+
+	# Create instance: master_0, and set properties
+	set master_0 [ create_bd_cell -type ip -vlnv  xilinx.com:ip:axi_vip master_0]
+	set_property -dict [ list CONFIG.PROTOCOL {AXI4LITE} CONFIG.INTERFACE_MODE {MASTER} ] $master_0
+
+	# Create interface connections
+	connect_bd_intf_net [get_bd_intf_pins master_0/M_AXI ] [get_bd_intf_pins axi_vcxo_ctrl_0/S00_AXI]
+
+	# Create port connections
+	connect_bd_net -net aclk_net [get_bd_ports ACLK] [get_bd_pins master_0/ACLK] [get_bd_pins axi_vcxo_ctrl_0/S00_AXI_ACLK]
+	connect_bd_net -net aresetn_net [get_bd_ports ARESETN] [get_bd_pins master_0/ARESETN] [get_bd_pins axi_vcxo_ctrl_0/S00_AXI_ARESETN]
+set_property target_simulator XSim [current_project]
+set_property -name {xsim.simulate.runtime} -value {100ms} -objects [get_filesets sim_1]
+
+	# Auto assign address
+	assign_bd_address
+
+	# Copy all address to interface_address.vh file
+	set bd_path [file dirname [get_property NAME [get_files ${design_name}.bd]]]
+	upvar 1 $offsetfile offset_file
+	set offset_file "${bd_path}/axi_vcxo_ctrl_v1_0_tb_include.svh"
+	set fp [open $offset_file "w"]
+	puts $fp "`ifndef axi_vcxo_ctrl_v1_0_tb_include_vh_"
+	puts $fp "`define axi_vcxo_ctrl_v1_0_tb_include_vh_\n"
+	puts $fp "//Configuration current bd names"
+	puts $fp "`define BD_NAME ${design_name}"
+	puts $fp "`define BD_INST_NAME ${design_name}_i"
+	puts $fp "`define BD_WRAPPER ${design_name}_wrapper\n"
+	puts $fp "//Configuration address parameters"
+
+	puts $fp "`endif"
+	close $fp
+}
+
+set ip_path [file dirname [file normalize [get_property XML_FILE_NAME [ipx::get_cores user.org:user:axi_vcxo_ctrl:1.0]]]]
+set test_bench_file ${ip_path}/example_designs/bfm_design/axi_vcxo_ctrl_v1_0_tb.sv
+set interface_address_vh_file ""
+
+# Set IP Repository and Update IP Catalogue 
+set repo_paths [get_property ip_repo_paths [current_fileset]] 
+if { [lsearch -exact -nocase $repo_paths $ip_path ] == -1 } {
+	set_property ip_repo_paths "$ip_path [get_property ip_repo_paths [current_fileset]]" [current_fileset]
+	update_ip_catalog
+}
+
+set design_name ""
+set all_bd {}
+set all_bd_files [get_files *.bd -quiet]
+foreach file $all_bd_files {
+set file_name [string range $file [expr {[string last "/" $file] + 1}] end]
+set bd_name [string range $file_name 0 [expr {[string last "." $file_name] -1}]]
+lappend all_bd $bd_name
+}
+
+for { set i 1 } { 1 } { incr i } {
+	set design_name "axi_vcxo_ctrl_v1_0_bfm_${i}"
+	if { [lsearch -exact -nocase $all_bd $design_name ] == -1 } {
+		break
+	}
+}
+
+create_ipi_design interface_address_vh_file ${design_name}
+validate_bd_design
+
+set wrapper_file [make_wrapper -files [get_files ${design_name}.bd] -top -force]
+import_files -force -norecurse $wrapper_file
+
+set_property SOURCE_SET sources_1 [get_filesets sim_1]
+import_files -fileset sim_1 -norecurse -force $test_bench_file
+remove_files -quiet -fileset sim_1 axi_vcxo_ctrl_v1_0_tb_include.vh
+import_files -fileset sim_1 -norecurse -force $interface_address_vh_file
+set_property top axi_vcxo_ctrl_v1_0_tb [get_filesets sim_1]
+set_property top_lib {} [get_filesets sim_1]
+set_property top_file {} [get_filesets sim_1]
+launch_simulation -simset sim_1 -mode behavioral
diff --git a/library/axi_vcxo_ctrl_1.0/example_designs/debug_hw_design/axi_vcxo_ctrl_v1_0_hw_test.tcl b/library/axi_vcxo_ctrl_1.0/example_designs/debug_hw_design/axi_vcxo_ctrl_v1_0_hw_test.tcl
new file mode 100644
index 000000000..d9cdc6171
--- /dev/null
+++ b/library/axi_vcxo_ctrl_1.0/example_designs/debug_hw_design/axi_vcxo_ctrl_v1_0_hw_test.tcl
@@ -0,0 +1,45 @@
+# Runtime Tcl commands to interact with - axi_vcxo_ctrl_v1_0
+
+# Sourcing design address info tcl
+set bd_path [get_property DIRECTORY [current_project]]/[current_project].srcs/[current_fileset]/bd
+source ${bd_path}/axi_vcxo_ctrl_v1_0_include.tcl
+
+# jtag axi master interface hardware name, change as per your design.
+set jtag_axi_master hw_axi_1
+set ec 0
+
+# hw test script
+# Delete all previous axis transactions
+if { [llength [get_hw_axi_txns -quiet]] } {
+	delete_hw_axi_txn [get_hw_axi_txns -quiet]
+}
+
+
+# Test all lite slaves.
+set wdata_1 abcd1234
+
+# Test: S00_AXI
+# Create a write transaction at s00_axi_addr address
+create_hw_axi_txn w_s00_axi_addr [get_hw_axis $jtag_axi_master] -type write -address $s00_axi_addr -data $wdata_1
+# Create a read transaction at s00_axi_addr address
+create_hw_axi_txn r_s00_axi_addr [get_hw_axis $jtag_axi_master] -type read -address $s00_axi_addr
+# Initiate transactions
+run_hw_axi r_s00_axi_addr
+run_hw_axi w_s00_axi_addr
+run_hw_axi r_s00_axi_addr
+set rdata_tmp [get_property DATA [get_hw_axi_txn r_s00_axi_addr]]
+# Compare read data
+if { $rdata_tmp == $wdata_1 } {
+	puts "Data comparison test pass for - S00_AXI"
+} else {
+	puts "Data comparison test fail for - S00_AXI, expected-$wdata_1 actual-$rdata_tmp"
+	inc ec
+}
+
+# Check error flag
+if { $ec == 0 } {
+	 puts "PTGEN_TEST: PASSED!" 
+} else {
+	 puts "PTGEN_TEST: FAILED!" 
+}
+
diff --git a/library/axi_vcxo_ctrl_1.0/example_designs/debug_hw_design/design.tcl b/library/axi_vcxo_ctrl_1.0/example_designs/debug_hw_design/design.tcl
new file mode 100644
index 000000000..8c7ce676a
--- /dev/null
+++ b/library/axi_vcxo_ctrl_1.0/example_designs/debug_hw_design/design.tcl
@@ -0,0 +1,118 @@
+
+proc create_ipi_design { offsetfile design_name } {
+
+	create_bd_design $design_name
+	open_bd_design $design_name
+
+	# Create and configure Clock/Reset
+	create_bd_cell -type ip -vlnv xilinx.com:ip:clk_wiz sys_clk_0
+	create_bd_cell -type ip -vlnv xilinx.com:ip:proc_sys_reset sys_reset_0
+
+	#Constraints will be provided manually while pin planning.
+		create_bd_port -dir I -type rst reset_rtl
+		set_property CONFIG.POLARITY [get_property CONFIG.POLARITY [get_bd_pins sys_clk_0/reset]] [get_bd_ports reset_rtl]
+		connect_bd_net [get_bd_pins sys_reset_0/ext_reset_in] [get_bd_ports reset_rtl]
+		connect_bd_net [get_bd_ports reset_rtl] [get_bd_pins sys_clk_0/reset]
+		set external_reset_port reset_rtl
+		create_bd_port -dir I -type clk clock_rtl
+		connect_bd_net [get_bd_pins sys_clk_0/clk_in1] [get_bd_ports clock_rtl]
+		set external_clock_port clock_rtl
+	
+	#Avoid IPI DRC, make clock port synchronous to reset
+	if { $external_clock_port ne "" && $external_reset_port ne "" } {
+		set_property CONFIG.ASSOCIATED_RESET $external_reset_port [get_bd_ports $external_clock_port]
+	}
+
+	# Connect other sys_reset pins
+	connect_bd_net [get_bd_pins sys_reset_0/slowest_sync_clk] [get_bd_pins sys_clk_0/clk_out1]
+	connect_bd_net [get_bd_pins sys_clk_0/locked] [get_bd_pins sys_reset_0/dcm_locked]
+
+	# Create instance: axi_vcxo_ctrl_0, and set properties
+	set axi_vcxo_ctrl_0 [ create_bd_cell -type ip -vlnv user.org:user:axi_vcxo_ctrl:1.0 axi_vcxo_ctrl_0 ]
+
+	# Create instance: jtag_axi_0, and set properties
+	set jtag_axi_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:jtag_axi jtag_axi_0 ]
+	set_property -dict [list CONFIG.PROTOCOL {0}] [get_bd_cells jtag_axi_0]
+	connect_bd_net [get_bd_pins jtag_axi_0/aclk] [get_bd_pins sys_clk_0/clk_out1]
+	connect_bd_net [get_bd_pins jtag_axi_0/aresetn] [get_bd_pins sys_reset_0/peripheral_aresetn]
+
+	# Create instance: axi_peri_interconnect, and set properties
+	set axi_peri_interconnect [ create_bd_cell -type ip -vlnv xilinx.com:ip:axi_interconnect axi_peri_interconnect ]
+	connect_bd_net [get_bd_pins axi_peri_interconnect/ACLK] [get_bd_pins sys_clk_0/clk_out1]
+	connect_bd_net [get_bd_pins axi_peri_interconnect/ARESETN] [get_bd_pins sys_reset_0/interconnect_aresetn]
+	set_property -dict [ list CONFIG.NUM_SI {1}  ] $axi_peri_interconnect
+	connect_bd_net [get_bd_pins axi_peri_interconnect/S00_ACLK] [get_bd_pins sys_clk_0/clk_out1]
+	connect_bd_net [get_bd_pins axi_peri_interconnect/S00_ARESETN] [get_bd_pins sys_reset_0/peripheral_aresetn]
+	connect_bd_intf_net [get_bd_intf_pins jtag_axi_0/M_AXI] [get_bd_intf_pins axi_peri_interconnect/S00_AXI]
+
+	set_property -dict [ list CONFIG.NUM_MI {1} ] $axi_peri_interconnect
+	connect_bd_net [get_bd_pins axi_peri_interconnect/M00_ACLK] [get_bd_pins sys_clk_0/clk_out1]
+	connect_bd_net [get_bd_pins axi_peri_interconnect/M00_ARESETN] [get_bd_pins sys_reset_0/peripheral_aresetn]
+
+	# Connect all clock & reset of axi_vcxo_ctrl_0 slave interfaces..
+	connect_bd_intf_net [get_bd_intf_pins axi_peri_interconnect/M00_AXI] [get_bd_intf_pins axi_vcxo_ctrl_0/S00_AXI]
+	connect_bd_net [get_bd_pins axi_vcxo_ctrl_0/s00_axi_aclk] [get_bd_pins sys_clk_0/clk_out1]
+	connect_bd_net [get_bd_pins axi_vcxo_ctrl_0/s00_axi_aresetn] [get_bd_pins sys_reset_0/peripheral_aresetn]
+
+
+	# Auto assign address
+	assign_bd_address
+
+	# Copy all address to axi_vcxo_ctrl_v1_0_include.tcl file
+	set bd_path [get_property DIRECTORY [current_project]]/[current_project].srcs/[current_fileset]/bd
+	upvar 1 $offsetfile offset_file
+	set offset_file "${bd_path}/axi_vcxo_ctrl_v1_0_include.tcl"
+	set fp [open $offset_file "w"]
+	puts $fp "# Configuration address parameters"
+
+	set offset [get_property OFFSET [get_bd_addr_segs /jtag_axi_0/Data/SEG_axi_vcxo_ctrl_0_S00_AXI_* ]]
+	puts $fp "set s00_axi_addr ${offset}"
+
+	close $fp
+}
+
+# Set IP Repository and Update IP Catalogue 
+set ip_path [file dirname [file normalize [get_property XML_FILE_NAME [ipx::get_cores user.org:user:axi_vcxo_ctrl:1.0]]]]
+set hw_test_file ${ip_path}/example_designs/debug_hw_design/axi_vcxo_ctrl_v1_0_hw_test.tcl
+
+set repo_paths [get_property ip_repo_paths [current_fileset]] 
+if { [lsearch -exact -nocase $repo_paths $ip_path ] == -1 } {
+	set_property ip_repo_paths "$ip_path [get_property ip_repo_paths [current_fileset]]" [current_fileset]
+	update_ip_catalog
+}
+
+set design_name ""
+set all_bd {}
+set all_bd_files [get_files *.bd -quiet]
+foreach file $all_bd_files {
+set file_name [string range $file [expr {[string last "/" $file] + 1}] end]
+set bd_name [string range $file_name 0 [expr {[string last "." $file_name] -1}]]
+lappend all_bd $bd_name
+}
+
+for { set i 1 } { 1 } { incr i } {
+	set design_name "axi_vcxo_ctrl_v1_0_hw_${i}"
+	if { [lsearch -exact -nocase $all_bd $design_name ] == -1 } {
+		break
+	}
+}
+
+set intf_address_include_file ""
+create_ipi_design intf_address_include_file ${design_name}
+save_bd_design
+validate_bd_design
+
+set wrapper_file [make_wrapper -files [get_files ${design_name}.bd] -top -force]
+import_files -force -norecurse $wrapper_file
+
+puts "-------------------------------------------------------------------------------------------------"
+puts "INFO NEXT STEPS : Until this stage, debug hardware design has been created, "
+puts "   please perform following steps to test design in targeted board."
+puts "1. Generate bitstream"
+puts "2. Setup your targeted board, open hardware manager and open new(or existing) hardware target"
+puts "3. Download generated bitstream"
+puts "4. Run generated hardware test using below command, this invokes basic read/write operation"
+puts "   to every interface present in the peripheral : xilinx.com:user:myip:1.0"
+puts "   : source -notrace ${hw_test_file}"
+puts "-------------------------------------------------------------------------------------------------"
+
diff --git a/library/axi_vcxo_ctrl_1.0/hdl/axi_vcxo_ctrl_v1_0.v b/library/axi_vcxo_ctrl_1.0/hdl/axi_vcxo_ctrl_v1_0.v
new file mode 100644
index 000000000..34934f4c6
--- /dev/null
+++ b/library/axi_vcxo_ctrl_1.0/hdl/axi_vcxo_ctrl_v1_0.v
@@ -0,0 +1,153 @@
+
+`timescale 1 ns / 1 ps
+
+	module axi_vcxo_ctrl_v1_0 #
+	(
+		// Users to add parameters here
+
+		// User parameters ends
+		// Do not modify the parameters beyond this line
+
+
+		// Parameters of Axi Slave Bus Interface S00_AXI
+		parameter integer C_S00_AXI_DATA_WIDTH	= 32,
+		parameter integer C_S00_AXI_ADDR_WIDTH	= 5
+	)
+	(
+		// Users to add ports here
+		input  wire	 			CLK_40MHz_FPGA  ,
+		// PPS or 10 MHz (need to choose from SW)
+		input  wire             PPS_IN          ,
+		input  wire             CLKIN_10MHz     ,
+		input  wire             PPS_GPS         ,
+		output wire             PPS_LED         ,
+		output wire             PPS_LOCKED      ,
+		output wire             REF_10M_LOCKED  ,
+		output wire             CLK_40M_DAC_nSYNC,
+		output wire             CLK_40M_DAC_SCLK ,
+		output wire             CLK_40M_DAC_DIN ,
+
+		// User ports ends
+		// Do not modify the ports beyond this line
+
+
+		// Ports of Axi Slave Bus Interface S00_AXI
+		input wire  s00_axi_aclk,
+		input wire  s00_axi_aresetn,
+		input wire [C_S00_AXI_ADDR_WIDTH-1 : 0] s00_axi_awaddr,
+		input wire [2 : 0] s00_axi_awprot,
+		input wire  s00_axi_awvalid,
+		output wire  s00_axi_awready,
+		input wire [C_S00_AXI_DATA_WIDTH-1 : 0] s00_axi_wdata,
+		input wire [(C_S00_AXI_DATA_WIDTH/8)-1 : 0] s00_axi_wstrb,
+		input wire  s00_axi_wvalid,
+		output wire  s00_axi_wready,
+		output wire [1 : 0] s00_axi_bresp,
+		output wire  s00_axi_bvalid,
+		input wire  s00_axi_bready,
+		input wire [C_S00_AXI_ADDR_WIDTH-1 : 0] s00_axi_araddr,
+		input wire [2 : 0] s00_axi_arprot,
+		input wire  s00_axi_arvalid,
+		output wire  s00_axi_arready,
+		output wire [C_S00_AXI_DATA_WIDTH-1 : 0] s00_axi_rdata,
+		output wire [1 : 0] s00_axi_rresp,
+		output wire  s00_axi_rvalid,
+		input wire  s00_axi_rready
+	);
+
+
+	wire  	[0:0]	dac_mode 			;
+	wire 	[15:0]	dac_user_set_value	;
+	wire 	[15:0]	dac_dyn_value 		;
+	wire  	[1:0]	dac_ref_sel 		;
+	wire 			dac_locked 			;
+
+	wire 		clk_200M;
+	wire 		clk_40M;
+	wire 		plllck;
+	wire 		ref_sync 	;
+	wire 		ref_ext_pll_locked;
+	wire 		ref_is_10M;
+	wire 		ref_is_pps;
+	wire [15:0]	dyn_dac_value	;
+
+
+// Instantiation of Axi Bus Interface S00_AXI
+	axi_vcxo_ctrl_v1_0_S00_AXI # ( 
+		.C_S_AXI_DATA_WIDTH(C_S00_AXI_DATA_WIDTH),
+		.C_S_AXI_ADDR_WIDTH(C_S00_AXI_ADDR_WIDTH)
+	) axi_vcxo_ctrl_v1_0_S00_AXI_inst (
+		.dac_mode(dac_mode) 			,
+		.dac_user_set_value(dac_user_set_value)	,
+		.dac_dyn_value(dac_dyn_value) 		,
+		.dac_ref_sel(dac_ref_sel) 		,
+		.dac_locked(ref_ext_pll_locked) 			,
+		.S_AXI_ACLK(s00_axi_aclk),
+		.S_AXI_ARESETN(s00_axi_aresetn),
+		.S_AXI_AWADDR(s00_axi_awaddr),
+		.S_AXI_AWPROT(s00_axi_awprot),
+		.S_AXI_AWVALID(s00_axi_awvalid),
+		.S_AXI_AWREADY(s00_axi_awready),
+		.S_AXI_WDATA(s00_axi_wdata),
+		.S_AXI_WSTRB(s00_axi_wstrb),
+		.S_AXI_WVALID(s00_axi_wvalid),
+		.S_AXI_WREADY(s00_axi_wready),
+		.S_AXI_BRESP(s00_axi_bresp),
+		.S_AXI_BVALID(s00_axi_bvalid),
+		.S_AXI_BREADY(s00_axi_bready),
+		.S_AXI_ARADDR(s00_axi_araddr),
+		.S_AXI_ARPROT(s00_axi_arprot),
+		.S_AXI_ARVALID(s00_axi_arvalid),
+		.S_AXI_ARREADY(s00_axi_arready),
+		.S_AXI_RDATA(s00_axi_rdata),
+		.S_AXI_RRESP(s00_axi_rresp),
+		.S_AXI_RVALID(s00_axi_rvalid),
+		.S_AXI_RREADY(s00_axi_rready)
+	);
+
+	// Add user logic here
+	
+
+	assign REF_10M_LOCKED = ref_ext_pll_locked & ref_is_10M;
+	assign PPS_LOCKED = ref_ext_pll_locked & ref_is_pps;
+	assign ref_sync = (dac_ref_sel==2'b00) ? CLKIN_10MHz :
+					  (dac_ref_sel==2'b01) ? PPS_IN :
+					  (dac_ref_sel==2'b10) ? PPS_GPS: 1'b0;
+
+	PLLE2_ADV #(.BANDWIDTH("OPTIMIZED"), .COMPENSATION("INTERNAL"),
+		.DIVCLK_DIVIDE(1),
+		.CLKFBOUT_MULT(30),
+		.CLKOUT0_DIVIDE(6),
+		.CLKOUT1_DIVIDE(30),
+		.CLKIN1_PERIOD(25.0)
+	)
+	clkgen (
+		.PWRDWN(1'b0), .RST(1'b0),
+		.CLKIN1(CLK_40MHz_FPGA),
+		.CLKOUT0(clk_200M),
+		.CLKOUT1(clk_40M),
+		.LOCKED(plllck)
+	);
+
+	b205_ref_pll#(
+		.DEVICE("LTC2630" )
+	)u_b205_ref_pll(
+		.reset      ( ~plllck    ),
+		.clk        ( clk_200M   ),
+		.refclk     ( clk_40M    ),
+		.ref        ( ref_sync        ),
+		.locked     ( ref_ext_pll_locked     ),
+		.ref_is_10M ( ref_is_10M ),
+		.ref_is_pps ( ref_is_pps ),
+		.dac_mode   ( dac_mode   ),
+		.dyn_dac    ( dyn_dac_value    ),
+		.dac_dft    ( 16'd42580	),
+		.dac_user_set_value(dac_user_set_value),
+		.sclk       ( CLK_40M_DAC_SCLK       ),
+		.mosi       ( CLK_40M_DAC_DIN       ),
+		.sync_n     ( CLK_40M_DAC_nSYNC     )
+	);
+
+	// User logic ends
+
+	endmodule
diff --git a/library/axi_vcxo_ctrl_1.0/hdl/axi_vcxo_ctrl_v1_0_S00_AXI.v b/library/axi_vcxo_ctrl_1.0/hdl/axi_vcxo_ctrl_v1_0_S00_AXI.v
new file mode 100644
index 000000000..22ebf7eb8
--- /dev/null
+++ b/library/axi_vcxo_ctrl_1.0/hdl/axi_vcxo_ctrl_v1_0_S00_AXI.v
@@ -0,0 +1,458 @@
+
+`timescale 1 ns / 1 ps
+
+	module axi_vcxo_ctrl_v1_0_S00_AXI #
+	(
+		// Users to add parameters here
+
+		// User parameters ends
+		// Do not modify the parameters beyond this line
+
+		// Width of S_AXI data bus
+		parameter integer C_S_AXI_DATA_WIDTH	= 32,
+		// Width of S_AXI address bus
+		parameter integer C_S_AXI_ADDR_WIDTH	= 5
+	)
+	(
+		// Users to add ports here
+		output 	wire  	[0:0]	dac_mode 			,
+		output 	wire 	[15:0]	dac_user_set_value	,
+		input 	wire 	[15:0]	dac_dyn_value 		,
+		output 	wire  	[1:0]	dac_ref_sel 		,
+		input 	wire 			dac_locked 			,
+
+		// User ports ends
+		// Do not modify the ports beyond this line
+
+		// Global Clock Signal
+		input wire  S_AXI_ACLK,
+		// Global Reset Signal. This Signal is Active LOW
+		input wire  S_AXI_ARESETN,
+		// Write address (issued by master, acceped by Slave)
+		input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR,
+		// Write channel Protection type. This signal indicates the
+    		// privilege and security level of the transaction, and whether
+    		// the transaction is a data access or an instruction access.
+		input wire [2 : 0] S_AXI_AWPROT,
+		// Write address valid. This signal indicates that the master signaling
+    		// valid write address and control information.
+		input wire  S_AXI_AWVALID,
+		// Write address ready. This signal indicates that the slave is ready
+    		// to accept an address and associated control signals.
+		output wire  S_AXI_AWREADY,
+		// Write data (issued by master, acceped by Slave) 
+		input wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA,
+		// Write strobes. This signal indicates which byte lanes hold
+    		// valid data. There is one write strobe bit for each eight
+    		// bits of the write data bus.    
+		input wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB,
+		// Write valid. This signal indicates that valid write
+    		// data and strobes are available.
+		input wire  S_AXI_WVALID,
+		// Write ready. This signal indicates that the slave
+    		// can accept the write data.
+		output wire  S_AXI_WREADY,
+		// Write response. This signal indicates the status
+    		// of the write transaction.
+		output wire [1 : 0] S_AXI_BRESP,
+		// Write response valid. This signal indicates that the channel
+    		// is signaling a valid write response.
+		output wire  S_AXI_BVALID,
+		// Response ready. This signal indicates that the master
+    		// can accept a write response.
+		input wire  S_AXI_BREADY,
+		// Read address (issued by master, acceped by Slave)
+		input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR,
+		// Protection type. This signal indicates the privilege
+    		// and security level of the transaction, and whether the
+    		// transaction is a data access or an instruction access.
+		input wire [2 : 0] S_AXI_ARPROT,
+		// Read address valid. This signal indicates that the channel
+    		// is signaling valid read address and control information.
+		input wire  S_AXI_ARVALID,
+		// Read address ready. This signal indicates that the slave is
+    		// ready to accept an address and associated control signals.
+		output wire  S_AXI_ARREADY,
+		// Read data (issued by slave)
+		output wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA,
+		// Read response. This signal indicates the status of the
+    		// read transfer.
+		output wire [1 : 0] S_AXI_RRESP,
+		// Read valid. This signal indicates that the channel is
+    		// signaling the required read data.
+		output wire  S_AXI_RVALID,
+		// Read ready. This signal indicates that the master can
+    		// accept the read data and response information.
+		input wire  S_AXI_RREADY
+	);
+
+	// AXI4LITE signals
+	reg [C_S_AXI_ADDR_WIDTH-1 : 0] 	axi_awaddr;
+	reg  	axi_awready;
+	reg  	axi_wready;
+	reg [1 : 0] 	axi_bresp;
+	reg  	axi_bvalid;
+	reg [C_S_AXI_ADDR_WIDTH-1 : 0] 	axi_araddr;
+	reg  	axi_arready;
+	reg [C_S_AXI_DATA_WIDTH-1 : 0] 	axi_rdata;
+	reg [1 : 0] 	axi_rresp;
+	reg  	axi_rvalid;
+
+	// Example-specific design signals
+	// local parameter for addressing 32 bit / 64 bit C_S_AXI_DATA_WIDTH
+	// ADDR_LSB is used for addressing 32/64 bit registers/memories
+	// ADDR_LSB = 2 for 32 bits (n downto 2)
+	// ADDR_LSB = 3 for 64 bits (n downto 3)
+	localparam integer ADDR_LSB = (C_S_AXI_DATA_WIDTH/32) + 1;
+	localparam integer OPT_MEM_ADDR_BITS = 2;
+	//----------------------------------------------
+	//-- Signals for user logic register space example
+	//------------------------------------------------
+	//-- Number of Slave Registers 8
+	reg [C_S_AXI_DATA_WIDTH-1:0]	slv_reg0;
+	reg [C_S_AXI_DATA_WIDTH-1:0]	slv_reg1;
+	reg [C_S_AXI_DATA_WIDTH-1:0]	slv_reg2;
+	reg [C_S_AXI_DATA_WIDTH-1:0]	slv_reg3;
+	reg [C_S_AXI_DATA_WIDTH-1:0]	slv_reg4;
+	reg [C_S_AXI_DATA_WIDTH-1:0]	slv_reg5;
+	reg [C_S_AXI_DATA_WIDTH-1:0]	slv_reg6;
+	reg [C_S_AXI_DATA_WIDTH-1:0]	slv_reg7;
+	wire	 slv_reg_rden;
+	wire	 slv_reg_wren;
+	reg [C_S_AXI_DATA_WIDTH-1:0]	 reg_data_out;
+	integer	 byte_index;
+	reg	 aw_en;
+
+	// I/O Connections assignments
+
+	assign S_AXI_AWREADY	= axi_awready;
+	assign S_AXI_WREADY	= axi_wready;
+	assign S_AXI_BRESP	= axi_bresp;
+	assign S_AXI_BVALID	= axi_bvalid;
+	assign S_AXI_ARREADY	= axi_arready;
+	assign S_AXI_RDATA	= axi_rdata;
+	assign S_AXI_RRESP	= axi_rresp;
+	assign S_AXI_RVALID	= axi_rvalid;
+	// Implement axi_awready generation
+	// axi_awready is asserted for one S_AXI_ACLK clock cycle when both
+	// S_AXI_AWVALID and S_AXI_WVALID are asserted. axi_awready is
+	// de-asserted when reset is low.
+
+	always @( posedge S_AXI_ACLK )
+	begin
+	  if ( S_AXI_ARESETN == 1'b0 )
+	    begin
+	      axi_awready <= 1'b0;
+	      aw_en <= 1'b1;
+	    end 
+	  else
+	    begin    
+	      if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID && aw_en)
+	        begin
+	          // slave is ready to accept write address when 
+	          // there is a valid write address and write data
+	          // on the write address and data bus. This design 
+	          // expects no outstanding transactions. 
+	          axi_awready <= 1'b1;
+	          aw_en <= 1'b0;
+	        end
+	        else if (S_AXI_BREADY && axi_bvalid)
+	            begin
+	              aw_en <= 1'b1;
+	              axi_awready <= 1'b0;
+	            end
+	      else           
+	        begin
+	          axi_awready <= 1'b0;
+	        end
+	    end 
+	end       
+
+	// Implement axi_awaddr latching
+	// This process is used to latch the address when both 
+	// S_AXI_AWVALID and S_AXI_WVALID are valid. 
+
+	always @( posedge S_AXI_ACLK )
+	begin
+	  if ( S_AXI_ARESETN == 1'b0 )
+	    begin
+	      axi_awaddr <= 0;
+	    end 
+	  else
+	    begin    
+	      if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID && aw_en)
+	        begin
+	          // Write Address latching 
+	          axi_awaddr <= S_AXI_AWADDR;
+	        end
+	    end 
+	end       
+
+	// Implement axi_wready generation
+	// axi_wready is asserted for one S_AXI_ACLK clock cycle when both
+	// S_AXI_AWVALID and S_AXI_WVALID are asserted. axi_wready is 
+	// de-asserted when reset is low. 
+
+	always @( posedge S_AXI_ACLK )
+	begin
+	  if ( S_AXI_ARESETN == 1'b0 )
+	    begin
+	      axi_wready <= 1'b0;
+	    end 
+	  else
+	    begin    
+	      if (~axi_wready && S_AXI_WVALID && S_AXI_AWVALID && aw_en )
+	        begin
+	          // slave is ready to accept write data when 
+	          // there is a valid write address and write data
+	          // on the write address and data bus. This design 
+	          // expects no outstanding transactions. 
+	          axi_wready <= 1'b1;
+	        end
+	      else
+	        begin
+	          axi_wready <= 1'b0;
+	        end
+	    end 
+	end       
+
+	// Implement memory mapped register select and write logic generation
+	// The write data is accepted and written to memory mapped registers when
+	// axi_awready, S_AXI_WVALID, axi_wready and S_AXI_WVALID are asserted. Write strobes are used to
+	// select byte enables of slave registers while writing.
+	// These registers are cleared when reset (active low) is applied.
+	// Slave register write enable is asserted when valid address and data are available
+	// and the slave is ready to accept the write address and write data.
+	assign slv_reg_wren = axi_wready && S_AXI_WVALID && axi_awready && S_AXI_AWVALID;
+
+	always @( posedge S_AXI_ACLK )
+	begin
+	  if ( S_AXI_ARESETN == 1'b0 )
+	    begin
+	      slv_reg0 <= 0;
+	      slv_reg1 <= 0;
+	      slv_reg2 <= 0;
+	      slv_reg3 <= 0;
+	      slv_reg4 <= 0;
+	      slv_reg5 <= 0;
+	      slv_reg6 <= 0;
+	      slv_reg7 <= 0;
+	    end 
+	  else begin
+	    if (slv_reg_wren)
+	      begin
+	        case ( axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] )
+	          3'h0:
+	            for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
+	              if ( S_AXI_WSTRB[byte_index] == 1 ) begin
+	                // Respective byte enables are asserted as per write strobes 
+	                // Slave register 0
+	                slv_reg0[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
+	              end  
+	          3'h1:
+	            for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
+	              if ( S_AXI_WSTRB[byte_index] == 1 ) begin
+	                // Respective byte enables are asserted as per write strobes 
+	                // Slave register 1
+	                slv_reg1[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
+	              end  
+	          3'h2:
+	            for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
+	              if ( S_AXI_WSTRB[byte_index] == 1 ) begin
+	                // Respective byte enables are asserted as per write strobes 
+	                // Slave register 2
+	                slv_reg2[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
+	              end  
+	          3'h3:
+	            for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
+	              if ( S_AXI_WSTRB[byte_index] == 1 ) begin
+	                // Respective byte enables are asserted as per write strobes 
+	                // Slave register 3
+	                slv_reg3[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
+	              end  
+	          3'h4:
+	            for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
+	              if ( S_AXI_WSTRB[byte_index] == 1 ) begin
+	                // Respective byte enables are asserted as per write strobes 
+	                // Slave register 4
+	                slv_reg4[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
+	              end  
+	          3'h5:
+	            for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
+	              if ( S_AXI_WSTRB[byte_index] == 1 ) begin
+	                // Respective byte enables are asserted as per write strobes 
+	                // Slave register 5
+	                slv_reg5[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
+	              end  
+	          3'h6:
+	            for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
+	              if ( S_AXI_WSTRB[byte_index] == 1 ) begin
+	                // Respective byte enables are asserted as per write strobes 
+	                // Slave register 6
+	                slv_reg6[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
+	              end  
+	          3'h7:
+	            for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
+	              if ( S_AXI_WSTRB[byte_index] == 1 ) begin
+	                // Respective byte enables are asserted as per write strobes 
+	                // Slave register 7
+	                slv_reg7[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
+	              end  
+	          default : begin
+	                      slv_reg0 <= slv_reg0;
+	                      slv_reg1 <= slv_reg1;
+	                      slv_reg2 <= slv_reg2;
+	                      slv_reg3 <= slv_reg3;
+	                      slv_reg4 <= slv_reg4;
+	                      slv_reg5 <= slv_reg5;
+	                      slv_reg6 <= slv_reg6;
+	                      slv_reg7 <= slv_reg7;
+	                    end
+	        endcase
+	      end
+	  end
+	end    
+
+	// Implement write response logic generation
+	// The write response and response valid signals are asserted by the slave 
+	// when axi_wready, S_AXI_WVALID, axi_wready and S_AXI_WVALID are asserted.  
+	// This marks the acceptance of address and indicates the status of 
+	// write transaction.
+
+	always @( posedge S_AXI_ACLK )
+	begin
+	  if ( S_AXI_ARESETN == 1'b0 )
+	    begin
+	      axi_bvalid  <= 0;
+	      axi_bresp   <= 2'b0;
+	    end 
+	  else
+	    begin    
+	      if (axi_awready && S_AXI_AWVALID && ~axi_bvalid && axi_wready && S_AXI_WVALID)
+	        begin
+	          // indicates a valid write response is available
+	          axi_bvalid <= 1'b1;
+	          axi_bresp  <= 2'b0; // 'OKAY' response 
+	        end                   // work error responses in future
+	      else
+	        begin
+	          if (S_AXI_BREADY && axi_bvalid) 
+	            //check if bready is asserted while bvalid is high) 
+	            //(there is a possibility that bready is always asserted high)   
+	            begin
+	              axi_bvalid <= 1'b0; 
+	            end  
+	        end
+	    end
+	end   
+
+	// Implement axi_arready generation
+	// axi_arready is asserted for one S_AXI_ACLK clock cycle when
+	// S_AXI_ARVALID is asserted. axi_awready is 
+	// de-asserted when reset (active low) is asserted. 
+	// The read address is also latched when S_AXI_ARVALID is 
+	// asserted. axi_araddr is reset to zero on reset assertion.
+
+	always @( posedge S_AXI_ACLK )
+	begin
+	  if ( S_AXI_ARESETN == 1'b0 )
+	    begin
+	      axi_arready <= 1'b0;
+	      axi_araddr  <= 32'b0;
+	    end 
+	  else
+	    begin    
+	      if (~axi_arready && S_AXI_ARVALID)
+	        begin
+	          // indicates that the slave has acceped the valid read address
+	          axi_arready <= 1'b1;
+	          // Read address latching
+	          axi_araddr  <= S_AXI_ARADDR;
+	        end
+	      else
+	        begin
+	          axi_arready <= 1'b0;
+	        end
+	    end 
+	end       
+
+	// Implement axi_arvalid generation
+	// axi_rvalid is asserted for one S_AXI_ACLK clock cycle when both 
+	// S_AXI_ARVALID and axi_arready are asserted. The slave registers 
+	// data are available on the axi_rdata bus at this instance. The 
+	// assertion of axi_rvalid marks the validity of read data on the 
+	// bus and axi_rresp indicates the status of read transaction.axi_rvalid 
+	// is deasserted on reset (active low). axi_rresp and axi_rdata are 
+	// cleared to zero on reset (active low).  
+	always @( posedge S_AXI_ACLK )
+	begin
+	  if ( S_AXI_ARESETN == 1'b0 )
+	    begin
+	      axi_rvalid <= 0;
+	      axi_rresp  <= 0;
+	    end 
+	  else
+	    begin    
+	      if (axi_arready && S_AXI_ARVALID && ~axi_rvalid)
+	        begin
+	          // Valid read data is available at the read data bus
+	          axi_rvalid <= 1'b1;
+	          axi_rresp  <= 2'b0; // 'OKAY' response
+	        end   
+	      else if (axi_rvalid && S_AXI_RREADY)
+	        begin
+	          // Read data is accepted by the master
+	          axi_rvalid <= 1'b0;
+	        end                
+	    end
+	end    
+
+	// Implement memory mapped register select and read logic generation
+	// Slave register read enable is asserted when valid address is available
+	// and the slave is ready to accept the read address.
+	assign slv_reg_rden = axi_arready & S_AXI_ARVALID & ~axi_rvalid;
+	always @(*)
+	begin
+	      // Address decoding for reading registers
+	      case ( axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] )
+	        3'h0   : reg_data_out <= slv_reg0;
+	        3'h1   : reg_data_out <= slv_reg1;
+	        3'h2   : reg_data_out <= dac_dyn_value;
+	        3'h3   : reg_data_out <= slv_reg3;
+	        3'h4   : reg_data_out <= dac_locked;
+	        3'h5   : reg_data_out <= slv_reg5;
+	        3'h6   : reg_data_out <= slv_reg6;
+	        3'h7   : reg_data_out <= slv_reg7;
+	        default : reg_data_out <= 0;
+	      endcase
+	end
+
+	// Output register or memory read data
+	always @( posedge S_AXI_ACLK )
+	begin
+	  if ( S_AXI_ARESETN == 1'b0 )
+	    begin
+	      axi_rdata  <= 0;
+	    end 
+	  else
+	    begin    
+	      // When there is a valid read address (S_AXI_ARVALID) with 
+	      // acceptance of read address by the slave (axi_arready), 
+	      // output the read dada 
+	      if (slv_reg_rden)
+	        begin
+	          axi_rdata <= reg_data_out;     // register read data
+	        end   
+	    end
+	end    
+
+	// Add user logic here
+	assign dac_mode = slv_reg0[0];
+	assign dac_user_set_value = slv_reg1[15:0];
+	assign dac_ref_sel = slv_reg3[1:0];
+	
+	
+
+	// User logic ends
+
+	endmodule
diff --git a/library/axi_vcxo_ctrl_1.0/hdl/b205_ref_pll.v b/library/axi_vcxo_ctrl_1.0/hdl/b205_ref_pll.v
new file mode 100644
index 000000000..140c44066
--- /dev/null
+++ b/library/axi_vcxo_ctrl_1.0/hdl/b205_ref_pll.v
@@ -0,0 +1,327 @@
+//
+// Copyright 2015 Ettus Research, a National Instruments Company
+//
+// SPDX-License-Identifier: LGPL-3.0-or-later
+//
+
+module b205_ref_pll#(parameter DEVICE="LTC2630")(
+    input reset,
+    input clk,      // 200 MHz sample clock
+    input refclk,   // 40 MHz reference clock
+    input ref,      // PPS or 10 MHz external reference
+    output reg locked,
+    output reg ref_is_10M,
+    output reg ref_is_pps,
+
+    output [15:0] dyn_dac,
+
+    // SPI lines to AD5662
+    output sclk,
+    output mosi,
+    output sync_n
+    );
+
+    // Base parameters
+    localparam SAMPLE_CLOCK_FREQ=200_000_000;
+    localparam REF_FREQ_PPS=1;
+    localparam REF_FREQ_10MHZ=10_000_000;
+    localparam REF_CLK_FREQ=40_000_000;
+    localparam PFD_FREQ_PPS=1;
+    localparam PFD_FREQ_10MHZ=10;
+
+    // Lock detection parameters
+    localparam LOCK_TOLERANCE_PPM=1;
+    localparam LOCK_MARGIN_PPS=(SAMPLE_CLOCK_FREQ/PFD_FREQ_PPS)*LOCK_TOLERANCE_PPM/1_000_000;
+    localparam LOCK_MARGIN_10MHZ=(SAMPLE_CLOCK_FREQ/PFD_FREQ_10MHZ)*LOCK_TOLERANCE_PPM/1_000_000;
+
+    // Reference frequency detection parameters
+    // References are only valid if they are +/-5ppm because that is the range of the VCTXCO
+    localparam REF_PERIOD_PPS=SAMPLE_CLOCK_FREQ/REF_FREQ_PPS;
+    localparam REF_PERIOD_10MHZ=SAMPLE_CLOCK_FREQ/REF_FREQ_10MHZ;
+    localparam REF_PERIOD_PPS_MIN=REF_PERIOD_PPS-(REF_PERIOD_PPS*5/1_000_000)-1;
+    localparam REF_PERIOD_PPS_MAX=REF_PERIOD_PPS+(REF_PERIOD_PPS*5/1_000_000)+1;
+    localparam REF_PERIOD_10MHZ_MIN=REF_PERIOD_10MHZ-(REF_PERIOD_10MHZ*5/1_000_000)-1;
+    localparam REF_PERIOD_10MHZ_MAX=REF_PERIOD_10MHZ+(REF_PERIOD_10MHZ*5/1_000_000)+1;
+
+    // R divider parameters
+    localparam RDIV_PPS=REF_FREQ_PPS/PFD_FREQ_PPS;
+    localparam RDIV_10MHZ=REF_FREQ_10MHZ/PFD_FREQ_10MHZ;
+
+    // N divider parameters (refclk is divided by 2)
+    localparam NDIV_PPS=REF_CLK_FREQ/2/PFD_FREQ_PPS;
+    localparam NDIV_10MHZ=REF_CLK_FREQ/2/PFD_FREQ_10MHZ;
+
+    // PFD parameters
+    localparam PFD_PERIOD_PPS=SAMPLE_CLOCK_FREQ/PFD_FREQ_PPS;
+    localparam PFD_PERIOD_10MHZ=SAMPLE_CLOCK_FREQ/PFD_FREQ_10MHZ;
+
+
+    // Initial divide by 2 for 40 MHz clock
+    // (since refclk cannot be sampled directly)
+    reg refclk_div;
+    always @(posedge refclk) begin
+        refclk_div <= ~refclk_div;
+    end
+
+    // flop signals into sample clock domain together
+    reg [3:0] refsmp;
+    reg [3:0] refclksmp;
+    always @(posedge clk) begin
+        refsmp <= {refsmp[2:0],ref};
+        refclksmp <= {refclksmp[2:0],refclk_div};
+    end
+
+    // rising edge detection
+    wire ref_rising = (refsmp[3:2] == 2'b01);
+    wire refclk_rising = (refclksmp[3:2] == 2'b01);
+
+    // reference frequency detection
+    reg [27:0] refcnt;
+    reg ref_detected;
+
+    wire valid_ref = ref_is_10M | ref_is_pps;
+    always @(posedge clk) begin
+        if (reset) begin
+            refcnt <= 28'd0;
+            ref_detected <= 1'b0;
+            ref_is_10M <= 1'b0;
+            ref_is_pps <= 1'b0;
+        end
+        else if (ref_rising) begin
+            refcnt <= 28'd1;
+            ref_detected <= 1'b1;
+            ref_is_10M <= ((refcnt >= REF_PERIOD_10MHZ_MIN) && (refcnt <= REF_PERIOD_10MHZ_MAX));
+            ref_is_pps <= ((refcnt >= REF_PERIOD_PPS_MIN) && (refcnt <= REF_PERIOD_PPS_MAX));
+        end
+        else if ((ref_is_10M && (refcnt > REF_PERIOD_10MHZ_MAX)) || (refcnt > REF_PERIOD_PPS_MAX)) begin
+            // consider the reference lost
+            refcnt <= 28'd0;
+            ref_detected <= 1'b0;
+            ref_is_10M <= 1'b0;
+            ref_is_pps <= 1'b0;
+        end
+        else if (ref_detected)
+            refcnt <= refcnt + 28'd1;
+    end
+
+    // R divider
+    wire [23:0] rdiv = ref_is_10M ? RDIV_10MHZ : RDIV_PPS;
+    reg [23:0] rcnt;
+    wire [23:0] next_rcnt = ~valid_ref ? 24'd0 : (rcnt == rdiv) ? 24'd1 : rcnt + 1'b1;
+    reg r_rising;
+    always @(posedge clk) begin
+        if (ref_rising)
+            rcnt <= next_rcnt;
+        r_rising <= (ref_rising && ((ref_is_10M && (rcnt == rdiv)) || ref_is_pps));
+    end
+
+    // N divider
+    // Enable on rising edge of R after valid_ref
+    // is asserted so R and N signals start aligned.
+    // Disable if reference lost.
+    wire [25:0] ndiv = ref_is_10M ? NDIV_10MHZ : NDIV_PPS;
+    reg [25:0] ncnt;
+    wire [25:0] next_ncnt = ~valid_ref ? 26'd0 : ncnt == ndiv ? 26'd1 : ncnt + 1'b1;
+    reg n_rising;
+    always @(posedge clk) begin
+		if (refclk_rising)
+			ncnt <= next_ncnt;
+		n_rising <= (refclk_rising && (ncnt == ndiv));
+    end
+
+    // Frequency Counter
+    wire signed [28:0] period = ref_is_10M ? PFD_PERIOD_10MHZ : PFD_PERIOD_PPS;
+    reg signed [28:0] r_period_cnt;
+    reg signed [28:0] freq_err;
+    always @(posedge clk) begin
+        if (reset | ~valid_ref) begin
+            r_period_cnt <= 28'd0;
+            freq_err <= 29'sd0;
+        end
+        else if (r_rising) begin
+            r_period_cnt <= 28'd1;
+            freq_err <= period - r_period_cnt;
+        end
+        else
+            r_period_cnt <= r_period_cnt + 28'd1;
+    end
+
+    // Phase Counter
+    reg signed [28:0] lead_cnt;
+    reg lead_cnt_ena;
+    reg signed [28:0] lead;
+    always @(posedge clk) begin
+        // Count how much N leads R
+        // The count is negative because it measures
+        // how much the VCTCXO must be slowed down.
+        if (~valid_ref | n_rising) begin
+            lead_cnt <= 29'sd0;
+            lead_cnt_ena <= 1'b1;
+            if (r_rising)
+                lead <= 29'sd0;
+        end
+        else if (r_rising) begin
+            if (lead_cnt_ena)
+                lead <= lead_cnt - 29'sd1;
+            else begin
+                // R rising with no preceding N rising.
+                // N has changed from leading to lagging R,
+                // but we don't yet know by how much so
+                // assume 1.
+                lead <= 29'sd1;
+            end
+            lead_cnt_ena <= 1'b0;
+        end
+        else if (lead_cnt_ena)
+            lead_cnt <= lead_cnt - 29'sd1;
+    end
+
+    // PFD State Machine
+    localparam MEASURE=4'd0;
+    localparam CAPTURE=4'd1;
+    localparam CAPTURE_LAG=4'd2;
+    localparam CAPTURE_LEAD=4'd3;
+    localparam CALCULATE_ERROR=4'd4;
+    localparam CALCULATE_10M_GAIN=4'd5;
+    localparam CALCULATE_ADJUSTMENT=4'd6;
+    localparam CALCULATE_OUTPUT_VALUE=4'd7;
+    localparam APPLY_OUTPUT_VALUE=4'd8;
+    reg [3:0] state;
+    reg [15:0] daco = 16'd32767;
+    wire signed [28:0] lock_margin = ref_is_10M ? LOCK_MARGIN_10MHZ : LOCK_MARGIN_PPS;
+    wire signed [28:0] lag = lead + period;
+    reg signed [28:0] phase_err;
+    reg signed [28:0] err;
+    reg signed [28:0] shift;
+    reg signed [28:0] adj;
+    wire signed [28:0] dacv = {13'd0, daco};
+    reg signed [28:0] sum;
+    reg [2:0] ld;
+    always @(posedge clk) begin
+        if (reset || ~valid_ref) begin
+            state <= MEASURE;
+            daco <= 16'd32767;
+            err <= 29'sd0;
+            shift <= 29'sd0;
+            adj <= 29'sd0;
+            ld <= 3'd0;
+        end
+        else begin
+            case(state)
+                MEASURE: begin
+                    if (r_rising)
+                        state <= CAPTURE;
+                end
+                CAPTURE: begin
+                    if (lag < -lead)
+                        state <= CAPTURE_LAG;
+                    else
+                        state <= CAPTURE_LEAD;
+                end
+                CAPTURE_LAG: begin
+                    phase_err <= lag;
+                    ld <= {ld[1:0], (lag <= lock_margin)};
+                    state <= CALCULATE_ERROR;
+                end
+                CAPTURE_LEAD: begin
+                    phase_err <= lead;
+                    ld <= {ld[1:0], (-lead <= lock_margin)};
+                    state <= CALCULATE_ERROR;
+                end
+                CALCULATE_ERROR: begin
+                    err <= phase_err + freq_err;
+                    state <= ref_is_10M ? CALCULATE_10M_GAIN : CALCULATE_ADJUSTMENT;
+                end
+                CALCULATE_10M_GAIN: begin
+                    shift <= (err < -7 || err > 7) ? 7 : (err < 0 ? -err : err);
+                    state <= CALCULATE_ADJUSTMENT;
+                end
+                CALCULATE_ADJUSTMENT: begin
+                    // The VCTCXO is +/-5 ppm from 0.3V to 1.5V and the DAC is 16 bits,
+                    // which works out to 0.000228885 ppm per DAC unit.
+                    // The 200 MHz sampling clock means each unit of error is 0.005 ppm,
+                    // which works out to 21.845 DAC units to correct each unit of error.
+                    // Theory is nice, but the proportional and integral gains used here
+                    // were determined through manual tuning.
+                    if (ref_is_10M)
+                        adj <= (err <<< shift);
+                    else
+                        adj <= (err <<< 4) - err;
+                    state <= CALCULATE_OUTPUT_VALUE;
+                end
+                CALCULATE_OUTPUT_VALUE: begin
+                    sum <= dacv + adj;
+                    state <= APPLY_OUTPUT_VALUE;
+                end
+                APPLY_OUTPUT_VALUE: begin
+                    // Clip and apply
+                    if (sum < 29'sd0)
+                        daco <= 16'd0;
+                    else if (sum > 29'sd65535)
+                        daco <= 16'd65535;
+                    else
+                        daco <= sum[15:0];
+                    state <= MEASURE;
+                end
+            endcase
+        end
+    end
+
+    always @(posedge clk)
+        locked <= (ld == 3'b111);
+
+    // ad5660_spi dac
+    // (
+    //     .clk(clk),
+    //     .dat(daco),
+    //     .sclk(sclk),
+    //     .mosi(mosi),
+    //     .sync_n(sync_n)
+    // );
+
+
+    // ad5662_auto_spi dac
+    //     (
+    //       .clk(refclk),
+    //       .rst  ( reset),
+    //       .data(daco),
+    //       .sclk(sclk),
+    //       .mosi(mosi),
+    //       .sync_n(sync_n)
+    //     );
+
+
+    generate
+        if (DEVICE=="AD5660") begin
+          ad5662_auto_spi dac
+          (
+            .clk(clk),
+            .dat(daco),
+            .sclk(sclk),
+            .mosi(mosi),
+            .sync_n(sync_n)
+          );
+        end  else if (DEVICE=="AD5640") begin
+          ad5640_spi u_ad5640_spi(
+              .clk  ( clk  ),
+              .rst  ( reset  ),
+              .data ( daco[15:2] ),
+              .sclk ( sclk ),
+              .mosi ( mosi ),
+              .sync_n  ( sync_n  )
+          ); 
+        end else begin
+          ltc2630_spi u_ltc2630_spi(
+              .clk  ( clk  ),
+              .rst  ( reset),
+              .data ( daco ),
+              .sclk ( sclk ),
+              .mosi ( mosi ),
+              .sync_n  ( sync_n  )
+          );
+        end
+    endgenerate
+  
+    assign dyn_dac = daco;
+  
+endmodule
diff --git a/library/axi_vcxo_ctrl_1.0/hdl/ltc2630_spi.v b/library/axi_vcxo_ctrl_1.0/hdl/ltc2630_spi.v
new file mode 100644
index 000000000..43ee8fcc2
--- /dev/null
+++ b/library/axi_vcxo_ctrl_1.0/hdl/ltc2630_spi.v
@@ -0,0 +1,151 @@
+module ltc2630_spi  (
+    input   wire            clk,
+    input   wire            rst,
+    input   wire  [15:0]    data,
+    output  reg             sclk,
+    output  wire            mosi,
+    output  reg             sync_n
+);
+
+    //====================================================
+    //parameter define
+    //====================================================
+    localparam  IDLE        = 4'b0001;
+    localparam  SYNC_PRE    = 4'b0010;
+    localparam  DATA        = 4'b0100;
+    localparam  SYNC_END    = 4'b1000;
+
+    //====================================================
+    // internal signals and registers
+    //====================================================
+    reg     [3:0]   state;
+    reg     [3:0]   cnt_cycle   ;
+    reg     [5:0]   cnt_bit     ;
+    reg     [15:0]  last_data   ;
+    reg     [23:0]  data_shift  ;
+    wire            rising_edge ;
+    wire            falling_edge;
+
+
+    //----------------state------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            state <= IDLE;
+        end
+        else  begin
+            case (state)
+                IDLE : begin
+                    // detect a new data input, the dac value needs to be updated
+                    if (last_data != data) begin
+                        state <= SYNC_PRE;
+                    end
+                end
+
+                SYNC_PRE : begin
+                    // The SYNC is low, start to update the value
+                    if (falling_edge) begin
+                        state <= DATA;
+                    end
+                end
+
+                DATA : begin
+                    if (cnt_bit == 'd23 && falling_edge) begin
+                        state <= SYNC_END;
+                    end
+                end
+
+                SYNC_END : begin
+                    if (rising_edge == 1'b1) begin
+                        state <= IDLE;
+                    end
+                end
+            endcase
+        end
+    end
+
+    //----------------cnt_cycle------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            cnt_cycle <= 'd0;
+        end
+        else if (state == SYNC_PRE || state == DATA || state == SYNC_END) begin
+            cnt_cycle <= cnt_cycle + 1'b1;
+        end
+        else  begin
+            cnt_cycle <=  'd0;
+        end
+    end
+
+    assign rising_edge = cnt_cycle==4'b1000;
+    assign falling_edge = cnt_cycle==4'b1111;
+
+    //----------------data_shift------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            data_shift <= 'd0;
+        end
+        else if (state == IDLE && (last_data != data)) begin
+            data_shift <= {4'b0011, 4'b0000, data};
+        end
+        else if (state == DATA && falling_edge) begin
+            data_shift <=  {data_shift[22:0], 1'b0};
+        end
+    end
+
+    //----------------cnt_bit------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            cnt_bit <= 'd0;
+        end
+        else if (state == DATA ) begin
+            if (cnt_bit == 'd23 && falling_edge) begin
+                cnt_bit <= 'd0;
+            end
+            else if(falling_edge)begin
+                cnt_bit <= cnt_bit + 1'b1;
+            end
+        end
+        else  begin
+            cnt_bit <=  'd0;
+        end
+    end
+
+    //----------------last_data------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            last_data <= 'd0;
+        end
+        else if (state == IDLE && (last_data != data)) begin
+            last_data <= data;
+        end
+    end
+
+    //-----------------sclk-----------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            sclk <= 1'b0;
+        end
+        else if (state==DATA && rising_edge == 1'b1) begin
+            sclk <= 1'b1;
+        end
+        else if (state==DATA && falling_edge == 1'b1) begin
+            sclk <=  1'b0;
+        end
+    end
+
+    assign mosi = data_shift[23];
+
+    //----------------sync_n------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            sync_n <= 1'b1;
+        end
+        else if (state == SYNC_PRE && falling_edge == 1'b1) begin
+            sync_n <= 1'b0;
+        end
+        else if (state == SYNC_END && rising_edge == 1'b1) begin
+            sync_n <=  1'b1;
+        end
+    end
+    
+endmodule
\ No newline at end of file
diff --git a/library/axi_vcxo_ctrl_1.0/src/b205_ref_pll.v b/library/axi_vcxo_ctrl_1.0/src/b205_ref_pll.v
new file mode 100644
index 000000000..666c125c4
--- /dev/null
+++ b/library/axi_vcxo_ctrl_1.0/src/b205_ref_pll.v
@@ -0,0 +1,334 @@
+//
+// Copyright 2015 Ettus Research, a National Instruments Company
+//
+// SPDX-License-Identifier: LGPL-3.0-or-later
+//
+
+module b205_ref_pll#(parameter DEVICE="LTC2630")(
+    input reset,
+    input clk,      // 200 MHz sample clock
+    input refclk,   // 40 MHz reference clock
+    input ref,      // PPS or 10 MHz external reference
+    output reg locked,
+    output reg ref_is_10M,
+    output reg ref_is_pps,
+    input           dac_mode,
+    input  [15:0]   dac_dft,
+    input  [15:0]   dac_user_set_value,
+    output [15:0]   dyn_dac,
+
+    // SPI lines to AD5662
+    output sclk,
+    output mosi,
+    output sync_n
+    );
+
+    // Base parameters
+    localparam SAMPLE_CLOCK_FREQ=200_000_000;
+    localparam REF_FREQ_PPS=1;
+    localparam REF_FREQ_10MHZ=10_000_000;
+    localparam REF_CLK_FREQ=40_000_000;
+    localparam PFD_FREQ_PPS=1;
+    localparam PFD_FREQ_10MHZ=10;
+
+    // Lock detection parameters
+    localparam LOCK_TOLERANCE_PPM=1;
+    localparam LOCK_MARGIN_PPS=(SAMPLE_CLOCK_FREQ/PFD_FREQ_PPS)*LOCK_TOLERANCE_PPM/1_000_000;
+    localparam LOCK_MARGIN_10MHZ=(SAMPLE_CLOCK_FREQ/PFD_FREQ_10MHZ)*LOCK_TOLERANCE_PPM/1_000_000;
+
+    // Reference frequency detection parameters
+    // References are only valid if they are +/-5ppm because that is the range of the VCTXCO
+    localparam REF_PERIOD_PPS=SAMPLE_CLOCK_FREQ/REF_FREQ_PPS;
+    localparam REF_PERIOD_10MHZ=SAMPLE_CLOCK_FREQ/REF_FREQ_10MHZ;
+    localparam REF_PERIOD_PPS_MIN=REF_PERIOD_PPS-(REF_PERIOD_PPS*5/1_000_000)-1;
+    localparam REF_PERIOD_PPS_MAX=REF_PERIOD_PPS+(REF_PERIOD_PPS*5/1_000_000)+1;
+    localparam REF_PERIOD_10MHZ_MIN=REF_PERIOD_10MHZ-(REF_PERIOD_10MHZ*5/1_000_000)-1;
+    localparam REF_PERIOD_10MHZ_MAX=REF_PERIOD_10MHZ+(REF_PERIOD_10MHZ*5/1_000_000)+1;
+
+    // R divider parameters
+    localparam RDIV_PPS=REF_FREQ_PPS/PFD_FREQ_PPS;
+    localparam RDIV_10MHZ=REF_FREQ_10MHZ/PFD_FREQ_10MHZ;
+
+    // N divider parameters (refclk is divided by 2)
+    localparam NDIV_PPS=REF_CLK_FREQ/2/PFD_FREQ_PPS;
+    localparam NDIV_10MHZ=REF_CLK_FREQ/2/PFD_FREQ_10MHZ;
+
+    // PFD parameters
+    localparam PFD_PERIOD_PPS=SAMPLE_CLOCK_FREQ/PFD_FREQ_PPS;
+    localparam PFD_PERIOD_10MHZ=SAMPLE_CLOCK_FREQ/PFD_FREQ_10MHZ;
+
+
+    // Initial divide by 2 for 40 MHz clock
+    // (since refclk cannot be sampled directly)
+    reg refclk_div;
+    always @(posedge refclk) begin
+        refclk_div <= ~refclk_div;
+    end
+
+    // flop signals into sample clock domain together
+    reg [3:0] refsmp;
+    reg [3:0] refclksmp;
+    always @(posedge clk) begin
+        refsmp <= {refsmp[2:0],ref};
+        refclksmp <= {refclksmp[2:0],refclk_div};
+    end
+
+    // rising edge detection
+    wire ref_rising = (refsmp[3:2] == 2'b01);
+    wire refclk_rising = (refclksmp[3:2] == 2'b01);
+
+    // reference frequency detection
+    reg [27:0] refcnt;
+    reg ref_detected;
+
+    wire valid_ref = ref_is_10M | ref_is_pps;
+    always @(posedge clk) begin
+        if (reset) begin
+            refcnt <= 28'd0;
+            ref_detected <= 1'b0;
+            ref_is_10M <= 1'b0;
+            ref_is_pps <= 1'b0;
+        end
+        else if (ref_rising) begin
+            refcnt <= 28'd1;
+            ref_detected <= 1'b1;
+            ref_is_10M <= ((refcnt >= REF_PERIOD_10MHZ_MIN) && (refcnt <= REF_PERIOD_10MHZ_MAX));
+            ref_is_pps <= ((refcnt >= REF_PERIOD_PPS_MIN) && (refcnt <= REF_PERIOD_PPS_MAX));
+        end
+        else if ((ref_is_10M && (refcnt > REF_PERIOD_10MHZ_MAX)) || (refcnt > REF_PERIOD_PPS_MAX)) begin
+            // consider the reference lost
+            refcnt <= 28'd0;
+            ref_detected <= 1'b0;
+            ref_is_10M <= 1'b0;
+            ref_is_pps <= 1'b0;
+        end
+        else if (ref_detected)
+            refcnt <= refcnt + 28'd1;
+    end
+
+    // R divider
+    wire [23:0] rdiv = ref_is_10M ? RDIV_10MHZ : RDIV_PPS;
+    reg [23:0] rcnt;
+    wire [23:0] next_rcnt = ~valid_ref ? 24'd0 : (rcnt == rdiv) ? 24'd1 : rcnt + 1'b1;
+    reg r_rising;
+    always @(posedge clk) begin
+        if (ref_rising)
+            rcnt <= next_rcnt;
+        r_rising <= (ref_rising && ((ref_is_10M && (rcnt == rdiv)) || ref_is_pps));
+    end
+
+    // N divider
+    // Enable on rising edge of R after valid_ref
+    // is asserted so R and N signals start aligned.
+    // Disable if reference lost.
+    wire [25:0] ndiv = ref_is_10M ? NDIV_10MHZ : NDIV_PPS;
+    reg [25:0] ncnt;
+    wire [25:0] next_ncnt = ~valid_ref ? 26'd0 : ncnt == ndiv ? 26'd1 : ncnt + 1'b1;
+    reg n_rising;
+    always @(posedge clk) begin
+		if (refclk_rising)
+			ncnt <= next_ncnt;
+		n_rising <= (refclk_rising && (ncnt == ndiv));
+    end
+
+    // Frequency Counter
+    wire signed [28:0] period = ref_is_10M ? PFD_PERIOD_10MHZ : PFD_PERIOD_PPS;
+    reg signed [28:0] r_period_cnt;
+    reg signed [28:0] freq_err;
+    always @(posedge clk) begin
+        if (reset | ~valid_ref) begin
+            r_period_cnt <= 28'd0;
+            freq_err <= 29'sd0;
+        end
+        else if (r_rising) begin
+            r_period_cnt <= 28'd1;
+            freq_err <= period - r_period_cnt;
+        end
+        else
+            r_period_cnt <= r_period_cnt + 28'd1;
+    end
+
+    // Phase Counter
+    reg signed [28:0] lead_cnt;
+    reg lead_cnt_ena;
+    reg signed [28:0] lead;
+    always @(posedge clk) begin
+        // Count how much N leads R
+        // The count is negative because it measures
+        // how much the VCTCXO must be slowed down.
+        if (~valid_ref | n_rising) begin
+            lead_cnt <= 29'sd0;
+            lead_cnt_ena <= 1'b1;
+            if (r_rising)
+                lead <= 29'sd0;
+        end
+        else if (r_rising) begin
+            if (lead_cnt_ena)
+                lead <= lead_cnt - 29'sd1;
+            else begin
+                // R rising with no preceding N rising.
+                // N has changed from leading to lagging R,
+                // but we don't yet know by how much so
+                // assume 1.
+                lead <= 29'sd1;
+            end
+            lead_cnt_ena <= 1'b0;
+        end
+        else if (lead_cnt_ena)
+            lead_cnt <= lead_cnt - 29'sd1;
+    end
+
+    // PFD State Machine
+    localparam MEASURE=4'd0;
+    localparam CAPTURE=4'd1;
+    localparam CAPTURE_LAG=4'd2;
+    localparam CAPTURE_LEAD=4'd3;
+    localparam CALCULATE_ERROR=4'd4;
+    localparam CALCULATE_10M_GAIN=4'd5;
+    localparam CALCULATE_ADJUSTMENT=4'd6;
+    localparam CALCULATE_OUTPUT_VALUE=4'd7;
+    localparam APPLY_OUTPUT_VALUE=4'd8;
+    reg [3:0] state;
+    reg [15:0] daco = 32767;
+    wire signed [28:0] lock_margin = ref_is_10M ? LOCK_MARGIN_10MHZ : LOCK_MARGIN_PPS;
+    wire signed [28:0] lag = lead + period;
+    reg signed [28:0] phase_err;
+    reg signed [28:0] err;
+    reg signed [28:0] shift;
+    reg signed [28:0] adj;
+    wire signed [28:0] dacv = {13'd0, daco};
+    reg signed [28:0] sum;
+    reg [2:0] ld;
+    always @(posedge clk) begin
+        if (reset || ~valid_ref) begin
+            state <= MEASURE;
+            daco <= dac_dft;
+            err <= 29'sd0;
+            shift <= 29'sd0;
+            adj <= 29'sd0;
+            ld <= 3'd0;
+        end
+        else begin
+            case(state)
+                MEASURE: begin
+                    if (r_rising)
+                        state <= CAPTURE;
+                end
+                CAPTURE: begin
+                    if (lag < -lead)
+                        state <= CAPTURE_LAG;
+                    else
+                        state <= CAPTURE_LEAD;
+                end
+                CAPTURE_LAG: begin
+                    phase_err <= lag;
+                    ld <= {ld[1:0], (lag <= lock_margin)};
+                    state <= CALCULATE_ERROR;
+                end
+                CAPTURE_LEAD: begin
+                    phase_err <= lead;
+                    ld <= {ld[1:0], (-lead <= lock_margin)};
+                    state <= CALCULATE_ERROR;
+                end
+                CALCULATE_ERROR: begin
+                    err <= phase_err + freq_err;
+                    state <= ref_is_10M ? CALCULATE_10M_GAIN : CALCULATE_ADJUSTMENT;
+                end
+                CALCULATE_10M_GAIN: begin
+                    shift <= (err < -7 || err > 7) ? 7 : (err < 0 ? -err : err);
+                    state <= CALCULATE_ADJUSTMENT;
+                end
+                CALCULATE_ADJUSTMENT: begin
+                    // The VCTCXO is +/-5 ppm from 0.3V to 1.5V and the DAC is 16 bits,
+                    // which works out to 0.000228885 ppm per DAC unit.
+                    // The 200 MHz sampling clock means each unit of error is 0.005 ppm,
+                    // which works out to 21.845 DAC units to correct each unit of error.
+                    // Theory is nice, but the proportional and integral gains used here
+                    // were determined through manual tuning.
+                    if (ref_is_10M)
+                        adj <= (err <<< shift);
+                    else
+                        adj <= (err <<< 4) - err;
+                    state <= CALCULATE_OUTPUT_VALUE;
+                end
+                CALCULATE_OUTPUT_VALUE: begin
+                    sum <= dacv + adj;
+                    state <= APPLY_OUTPUT_VALUE;
+                end
+                APPLY_OUTPUT_VALUE: begin
+                    // Clip and apply
+                    if (sum < 29'sd0)
+                        daco <= 16'd0;
+                    else if (sum > 29'sd65535)
+                        daco <= 16'd65535;
+                    else
+                        daco <= sum[15:0];
+                    state <= MEASURE;
+                end
+            endcase
+        end
+    end
+
+    always @(posedge clk)
+        locked <= (ld == 3'b111);
+
+    // ad5660_spi dac
+    // (
+    //     .clk(clk),
+    //     .dat(daco),
+    //     .sclk(sclk),
+    //     .mosi(mosi),
+    //     .sync_n(sync_n)
+    // );
+
+
+    // ad5662_auto_spi dac
+    //     (
+    //       .clk(refclk),
+    //       .rst  ( reset),
+    //       .data(daco),
+    //       .sclk(sclk),
+    //       .mosi(mosi),
+    //       .sync_n(sync_n)
+    //     );
+
+    wire [15:0] dac_value;
+
+
+    assign  dac_value = dac_mode ? dac_user_set_value : daco;
+
+
+    generate
+        if (DEVICE=="AD5660") begin
+          ad5662_auto_spi dac
+          (
+            .clk(clk),
+            .dat(dac_value),
+            .sclk(sclk),
+            .mosi(mosi),
+            .sync_n(sync_n)
+          );
+        end  else if (DEVICE=="AD5640") begin
+          ad5640_spi u_ad5640_spi(
+              .clk  ( clk  ),
+              .rst  ( reset  ),
+              .data ( dac_value[15:2] ),
+              .sclk ( sclk ),
+              .mosi ( mosi ),
+              .sync_n  ( sync_n  )
+          ); 
+        end else begin
+          ltc2630_spi u_ltc2630_spi(
+              .clk  ( clk  ),
+              .rst  ( reset),
+              .data ( dac_value ),
+              .sclk ( sclk ),
+              .mosi ( mosi ),
+              .sync_n  ( sync_n  )
+          );
+        end
+    endgenerate
+  
+    assign dyn_dac = dac_value;
+  
+endmodule
diff --git a/library/axi_vcxo_ctrl_1.0/src/ltc2630_spi.v b/library/axi_vcxo_ctrl_1.0/src/ltc2630_spi.v
new file mode 100644
index 000000000..43ee8fcc2
--- /dev/null
+++ b/library/axi_vcxo_ctrl_1.0/src/ltc2630_spi.v
@@ -0,0 +1,151 @@
+module ltc2630_spi  (
+    input   wire            clk,
+    input   wire            rst,
+    input   wire  [15:0]    data,
+    output  reg             sclk,
+    output  wire            mosi,
+    output  reg             sync_n
+);
+
+    //====================================================
+    //parameter define
+    //====================================================
+    localparam  IDLE        = 4'b0001;
+    localparam  SYNC_PRE    = 4'b0010;
+    localparam  DATA        = 4'b0100;
+    localparam  SYNC_END    = 4'b1000;
+
+    //====================================================
+    // internal signals and registers
+    //====================================================
+    reg     [3:0]   state;
+    reg     [3:0]   cnt_cycle   ;
+    reg     [5:0]   cnt_bit     ;
+    reg     [15:0]  last_data   ;
+    reg     [23:0]  data_shift  ;
+    wire            rising_edge ;
+    wire            falling_edge;
+
+
+    //----------------state------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            state <= IDLE;
+        end
+        else  begin
+            case (state)
+                IDLE : begin
+                    // detect a new data input, the dac value needs to be updated
+                    if (last_data != data) begin
+                        state <= SYNC_PRE;
+                    end
+                end
+
+                SYNC_PRE : begin
+                    // The SYNC is low, start to update the value
+                    if (falling_edge) begin
+                        state <= DATA;
+                    end
+                end
+
+                DATA : begin
+                    if (cnt_bit == 'd23 && falling_edge) begin
+                        state <= SYNC_END;
+                    end
+                end
+
+                SYNC_END : begin
+                    if (rising_edge == 1'b1) begin
+                        state <= IDLE;
+                    end
+                end
+            endcase
+        end
+    end
+
+    //----------------cnt_cycle------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            cnt_cycle <= 'd0;
+        end
+        else if (state == SYNC_PRE || state == DATA || state == SYNC_END) begin
+            cnt_cycle <= cnt_cycle + 1'b1;
+        end
+        else  begin
+            cnt_cycle <=  'd0;
+        end
+    end
+
+    assign rising_edge = cnt_cycle==4'b1000;
+    assign falling_edge = cnt_cycle==4'b1111;
+
+    //----------------data_shift------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            data_shift <= 'd0;
+        end
+        else if (state == IDLE && (last_data != data)) begin
+            data_shift <= {4'b0011, 4'b0000, data};
+        end
+        else if (state == DATA && falling_edge) begin
+            data_shift <=  {data_shift[22:0], 1'b0};
+        end
+    end
+
+    //----------------cnt_bit------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            cnt_bit <= 'd0;
+        end
+        else if (state == DATA ) begin
+            if (cnt_bit == 'd23 && falling_edge) begin
+                cnt_bit <= 'd0;
+            end
+            else if(falling_edge)begin
+                cnt_bit <= cnt_bit + 1'b1;
+            end
+        end
+        else  begin
+            cnt_bit <=  'd0;
+        end
+    end
+
+    //----------------last_data------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            last_data <= 'd0;
+        end
+        else if (state == IDLE && (last_data != data)) begin
+            last_data <= data;
+        end
+    end
+
+    //-----------------sclk-----------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            sclk <= 1'b0;
+        end
+        else if (state==DATA && rising_edge == 1'b1) begin
+            sclk <= 1'b1;
+        end
+        else if (state==DATA && falling_edge == 1'b1) begin
+            sclk <=  1'b0;
+        end
+    end
+
+    assign mosi = data_shift[23];
+
+    //----------------sync_n------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            sync_n <= 1'b1;
+        end
+        else if (state == SYNC_PRE && falling_edge == 1'b1) begin
+            sync_n <= 1'b0;
+        end
+        else if (state == SYNC_END && rising_edge == 1'b1) begin
+            sync_n <=  1'b1;
+        end
+    end
+    
+endmodule
\ No newline at end of file
diff --git a/projects/ant/Makefile b/projects/ant/Makefile
new file mode 100644
index 000000000..4a1ad7e0f
--- /dev/null
+++ b/projects/ant/Makefile
@@ -0,0 +1,24 @@
+####################################################################################
+## Copyright (c) 2018 - 2023 Analog Devices, Inc.
+### SPDX short identifier: BSD-1-Clause
+## Auto-generated, do not modify!
+####################################################################################
+
+PROJECT_NAME := ant
+
+M_DEPS += ../common/xilinx/adi_fir_filter_constr.xdc
+M_DEPS += ../common/xilinx/adi_fir_filter_bd.tcl
+M_DEPS += ../../library/util_cdc/sync_bits.v
+M_DEPS += ../../library/common/util_pulse_gen.v
+M_DEPS += ../../library/common/ad_iobuf.v
+M_DEPS += ../../library/common/ad_bus_mux.v
+M_DEPS += ../../library/axi_tdd/scripts/axi_tdd.tcl
+M_DEPS += ../../library/axi_ad9361/axi_ad9361_delay.tcl
+
+LIB_DEPS += axi_ad9361
+LIB_DEPS += axi_dmac
+LIB_DEPS += axi_tdd
+LIB_DEPS += util_pack/util_cpack2
+LIB_DEPS += util_pack/util_upack2
+
+include ../scripts/project-xilinx.mk
diff --git a/projects/ant/system_bd.tcl b/projects/ant/system_bd.tcl
new file mode 100644
index 000000000..e3e11b600
--- /dev/null
+++ b/projects/ant/system_bd.tcl
@@ -0,0 +1,376 @@
+# create board design
+
+source $ad_hdl_dir/projects/common/xilinx/adi_fir_filter_bd.tcl
+source $ad_hdl_dir/library/axi_tdd/scripts/axi_tdd.tcl
+set_property  ip_repo_paths  { ../../library/} [current_project]
+update_ip_catalog
+
+# default ports
+
+create_bd_intf_port -mode Master -vlnv xilinx.com:interface:ddrx_rtl:1.0 ddr
+create_bd_intf_port -mode Master -vlnv xilinx.com:display_processing_system7:fixedio_rtl:1.0 fixed_io
+
+create_bd_port -dir O spi0_csn_2_o
+create_bd_port -dir O spi0_csn_1_o
+create_bd_port -dir O spi0_csn_0_o
+create_bd_port -dir I spi0_csn_i
+create_bd_port -dir I spi0_clk_i
+create_bd_port -dir O spi0_clk_o
+create_bd_port -dir I spi0_sdo_i
+create_bd_port -dir O spi0_sdo_o
+create_bd_port -dir I spi0_sdi_i
+
+create_bd_port -dir I -from 63 -to 0 gpio_i
+create_bd_port -dir O -from 63 -to 0 gpio_o
+create_bd_port -dir O -from 63 -to 0 gpio_t
+
+
+create_bd_port -dir O txdata_o
+create_bd_port -dir I tdd_ext_sync
+
+
+create_bd_port -dir I CLKIN_10MHz
+create_bd_port -dir I CLK_40MHz_FPGA
+create_bd_port -dir O CLK_40M_DAC_DIN
+create_bd_port -dir O CLK_40M_DAC_SCLK
+create_bd_port -dir O CLK_40M_DAC_nSYNC
+create_bd_port -dir I PPS_GPS
+create_bd_port -dir I PPS_IN
+create_bd_port -dir O PPS_LED
+create_bd_port -dir O PPS_LOCKED
+create_bd_port -dir O REF_10M_LOCKED
+
+# ps7 settings
+
+ad_ip_instance processing_system7 sys_ps7
+ad_ip_parameter sys_ps7 CONFIG.PCW_PRESET_BANK0_VOLTAGE "LVCMOS 3.3V"
+ad_ip_parameter sys_ps7 CONFIG.PCW_PRESET_BANK1_VOLTAGE "LVCMOS 1.8V"
+ad_ip_parameter sys_ps7 CONFIG.PCW_PACKAGE_NAME clg400
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_MIO_GPIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_ENET0_IO "MIO 16 .. 27"
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_GRP_MDIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_GRP_MDIO_IO "MIO 52 .. 53"
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_RESET_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_RESET_IO "MIO 46"
+ad_ip_parameter sys_ps7 CONFIG.PCW_SD0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_SDIO_PERIPHERAL_FREQMHZ 50
+ad_ip_parameter sys_ps7 CONFIG.PCW_UART1_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UART1_UART1_IO {MIO 12 .. 13}
+ad_ip_parameter sys_ps7 CONFIG.PCW_I2C0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_I2C0_I2C0_IO {MIO 10 .. 11}
+ad_ip_parameter sys_ps7 CONFIG.PCW_USB0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_USB0_RESET_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_USB0_RESET_IO "MIO 47"
+ad_ip_parameter sys_ps7 CONFIG.PCW_QSPI_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_PARTNO {MT41J256M16 RE-125}
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_BUS_WIDTH {32 Bit}
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_USE_INTERNAL_VREF 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_TRAIN_WRITE_LEVEL 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_TRAIN_READ_GATE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_TRAIN_DATA_EYE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_DQS_TO_CLK_DELAY_0 0.048
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_DQS_TO_CLK_DELAY_1 0.050
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_BOARD_DELAY0 0.241
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_BOARD_DELAY1 0.240
+ad_ip_parameter sys_ps7 CONFIG.PCW_TTC0_PERIPHERAL_ENABLE 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_EN_CLK1_PORT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_EN_RST1_PORT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_EN_CLK2_PORT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_EN_RST2_PORT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_FPGA0_PERIPHERAL_FREQMHZ 100.0
+ad_ip_parameter sys_ps7 CONFIG.PCW_FPGA1_PERIPHERAL_FREQMHZ 200.0
+ad_ip_parameter sys_ps7 CONFIG.PCW_FPGA2_PERIPHERAL_FREQMHZ 200.0
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_FABRIC_INTERRUPT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_IRQ_F2P_INTR 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_EMIO_GPIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_EMIO_GPIO_IO 64
+ad_ip_parameter sys_ps7 CONFIG.PCW_IRQ_F2P_MODE REVERSE
+ad_ip_parameter sys_ps7 CONFIG.PCW_SPI0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_SPI0_SPI0_IO EMIO
+ad_ip_parameter sys_ps7 CONFIG.PCW_SPI1_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_SPI1_SPI1_IO EMIO
+
+
+ad_ip_instance xlconcat sys_concat_intc
+ad_ip_parameter sys_concat_intc CONFIG.NUM_PORTS 16
+
+ad_ip_instance proc_sys_reset sys_rstgen
+ad_ip_parameter sys_rstgen CONFIG.C_EXT_RST_WIDTH 1
+
+# system reset/clock definitions
+
+
+
+set axi_vcxo_ctrl [ create_bd_cell -type ip -vlnv user.org:user:axi_vcxo_ctrl:1.0 axi_vcxo_ctrl ]
+ad_connect axi_vcxo_ctrl/CLK_40M_DAC_DIN CLK_40M_DAC_DIN
+ad_connect axi_vcxo_ctrl/CLK_40M_DAC_SCLK CLK_40M_DAC_SCLK
+ad_connect axi_vcxo_ctrl/CLK_40M_DAC_nSYNC CLK_40M_DAC_nSYNC
+ad_connect axi_vcxo_ctrl/CLKIN_10MHz CLKIN_10MHz
+ad_connect axi_vcxo_ctrl/CLK_40MHz_FPGA CLK_40MHz_FPGA
+ad_connect axi_vcxo_ctrl/PPS_GPS PPS_GPS
+ad_connect axi_vcxo_ctrl/PPS_IN PPS_IN
+ad_connect axi_vcxo_ctrl/PPS_LED PPS_LED
+ad_connect axi_vcxo_ctrl/PPS_LOCKED PPS_LOCKED
+ad_connect axi_vcxo_ctrl/REF_10M_LOCKED REF_10M_LOCKED
+
+
+
+
+ad_connect  sys_cpu_clk sys_ps7/FCLK_CLK0
+ad_connect  sys_200m_clk sys_ps7/FCLK_CLK1
+ad_connect  sys_cpu_reset sys_rstgen/peripheral_reset
+ad_connect  sys_cpu_resetn sys_rstgen/peripheral_aresetn
+ad_connect  sys_cpu_clk sys_rstgen/slowest_sync_clk
+ad_connect  sys_rstgen/ext_reset_in sys_ps7/FCLK_RESET0_N
+
+# interface connections
+
+ad_connect  ddr sys_ps7/DDR
+ad_connect  gpio_i sys_ps7/GPIO_I
+ad_connect  gpio_o sys_ps7/GPIO_O
+ad_connect  gpio_t sys_ps7/GPIO_T
+ad_connect  fixed_io sys_ps7/FIXED_IO
+
+# ps7 spi connections
+
+ad_connect  spi0_csn_2_o sys_ps7/SPI0_SS2_O
+ad_connect  spi0_csn_1_o sys_ps7/SPI0_SS1_O
+ad_connect  spi0_csn_0_o sys_ps7/SPI0_SS_O
+ad_connect  spi0_csn_i sys_ps7/SPI0_SS_I
+ad_connect  spi0_clk_i sys_ps7/SPI0_SCLK_I
+ad_connect  spi0_clk_o sys_ps7/SPI0_SCLK_O
+ad_connect  spi0_sdo_i sys_ps7/SPI0_MOSI_I
+ad_connect  spi0_sdo_o sys_ps7/SPI0_MOSI_O
+ad_connect  spi0_sdi_i sys_ps7/SPI0_MISO_I
+
+
+# interrupts
+
+ad_connect  sys_concat_intc/dout sys_ps7/IRQ_F2P
+ad_connect  sys_concat_intc/In15 GND
+ad_connect  sys_concat_intc/In14 GND
+ad_connect  sys_concat_intc/In13 GND
+ad_connect  sys_concat_intc/In12 GND
+ad_connect  sys_concat_intc/In11 GND
+ad_connect  sys_concat_intc/In10 GND
+ad_connect  sys_concat_intc/In9 GND
+ad_connect  sys_concat_intc/In8 GND
+ad_connect  sys_concat_intc/In7 GND
+ad_connect  sys_concat_intc/In6 GND
+ad_connect  sys_concat_intc/In5 GND
+ad_connect  sys_concat_intc/In4 GND
+ad_connect  sys_concat_intc/In3 GND
+ad_connect  sys_concat_intc/In2 GND
+ad_connect  sys_concat_intc/In1 GND
+ad_connect  sys_concat_intc/In0 GND
+
+# ad9361
+
+create_bd_port -dir I rx_clk_in
+create_bd_port -dir I rx_frame_in
+create_bd_port -dir I -from 11 -to 0 rx_data_in
+
+create_bd_port -dir O tx_clk_out
+create_bd_port -dir O tx_frame_out
+create_bd_port -dir O -from 11 -to 0 tx_data_out
+
+create_bd_port -dir O enable
+create_bd_port -dir O txnrx
+create_bd_port -dir I up_enable
+create_bd_port -dir I up_txnrx
+
+# ad9361 core(s)
+
+ad_ip_instance axi_ad9361 axi_ad9361
+ad_ip_parameter axi_ad9361 CONFIG.ID 0
+ad_ip_parameter axi_ad9361 CONFIG.CMOS_OR_LVDS_N 1
+ad_ip_parameter axi_ad9361 CONFIG.MODE_1R1T 0
+ad_ip_parameter axi_ad9361 CONFIG.ADC_INIT_DELAY 21
+
+ad_ip_instance axi_dmac axi_ad9361_dac_dma
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_TYPE_SRC 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_TYPE_DEST 1
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.CYCLIC 1
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.AXI_SLICE_SRC 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.AXI_SLICE_DEST 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_2D_TRANSFER 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_DATA_WIDTH_DEST 64
+
+ad_add_interpolation_filter "tx_fir_interpolator" 8 2 1 {61.44} {7.68} \
+                             "$ad_hdl_dir/library/util_fir_int/coefile_int.coe"
+ad_ip_instance xlslice interp_slice
+ad_ip_instance util_upack2 tx_upack
+
+ad_ip_instance axi_dmac axi_ad9361_adc_dma
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_TYPE_SRC 2
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_TYPE_DEST 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.CYCLIC 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.SYNC_TRANSFER_START 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.AXI_SLICE_SRC 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.AXI_SLICE_DEST 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_2D_TRANSFER 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_DATA_WIDTH_SRC 64
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.SYNC_TRANSFER_START {true}
+
+ad_add_decimation_filter "rx_fir_decimator" 8 2 1 {61.44} {61.44} \
+                         "$ad_hdl_dir/library/util_fir_int/coefile_int.coe"
+ad_ip_instance xlslice decim_slice
+ad_ip_instance util_cpack2 cpack
+
+# connections
+
+ad_connect  rx_clk_in axi_ad9361/rx_clk_in
+ad_connect  rx_frame_in axi_ad9361/rx_frame_in
+ad_connect  rx_data_in axi_ad9361/rx_data_in
+ad_connect  tx_clk_out axi_ad9361/tx_clk_out
+ad_connect  tx_frame_out axi_ad9361/tx_frame_out
+ad_connect  tx_data_out axi_ad9361/tx_data_out
+ad_connect  enable axi_ad9361/enable
+ad_connect  txnrx axi_ad9361/txnrx
+ad_connect  up_enable axi_ad9361/up_enable
+ad_connect  up_txnrx axi_ad9361/up_txnrx
+
+ad_connect  axi_ad9361/tdd_sync GND
+ad_connect  sys_200m_clk axi_ad9361/delay_clk
+ad_connect  axi_ad9361/l_clk axi_ad9361/clk
+
+ad_connect axi_ad9361/l_clk rx_fir_decimator/aclk
+
+ad_connect axi_ad9361/adc_valid_i0 rx_fir_decimator/valid_in_0
+ad_connect axi_ad9361/adc_enable_i0 rx_fir_decimator/enable_in_0
+ad_connect axi_ad9361/adc_data_i0 rx_fir_decimator/data_in_0
+ad_connect axi_ad9361/adc_valid_q0 rx_fir_decimator/valid_in_1
+ad_connect axi_ad9361/adc_enable_q0 rx_fir_decimator/enable_in_1
+ad_connect axi_ad9361/adc_data_q0 rx_fir_decimator/data_in_1
+
+ad_connect axi_ad9361/l_clk cpack/clk
+ad_connect axi_ad9361/rst cpack/reset
+
+ad_connect axi_ad9361/adc_enable_i1 cpack/enable_2
+ad_connect axi_ad9361/adc_data_i1 cpack/fifo_wr_data_2
+ad_connect axi_ad9361/adc_enable_q1 cpack/enable_3
+ad_connect axi_ad9361/adc_data_q1 cpack/fifo_wr_data_3
+
+ad_connect cpack/enable_0 rx_fir_decimator/enable_out_0
+ad_connect cpack/enable_1 rx_fir_decimator/enable_out_1
+ad_connect cpack/fifo_wr_data_0 rx_fir_decimator/data_out_0
+ad_connect cpack/fifo_wr_data_1 rx_fir_decimator/data_out_1
+ad_connect rx_fir_decimator/valid_out_0 cpack/fifo_wr_en
+
+ad_connect axi_ad9361_adc_dma/fifo_wr cpack/packed_fifo_wr
+ad_connect axi_ad9361/up_adc_gpio_out decim_slice/Din
+ad_connect rx_fir_decimator/active decim_slice/Dout
+
+ad_connect axi_ad9361/l_clk tx_fir_interpolator/aclk
+
+ad_connect axi_ad9361/dac_enable_i0 tx_fir_interpolator/dac_enable_0
+ad_connect axi_ad9361/dac_valid_i0 tx_fir_interpolator/dac_valid_0
+ad_connect axi_ad9361/dac_data_i0 tx_fir_interpolator/data_out_0
+ad_connect axi_ad9361/dac_enable_q0 tx_fir_interpolator/dac_enable_1
+ad_connect axi_ad9361/dac_valid_q0 tx_fir_interpolator/dac_valid_1
+ad_connect axi_ad9361/dac_data_q0 tx_fir_interpolator/data_out_1
+
+ad_connect  axi_ad9361/l_clk tx_upack/clk
+
+ad_connect  tx_upack/fifo_rd_data_0  tx_fir_interpolator/data_in_0
+ad_connect  tx_upack/enable_0  tx_fir_interpolator/enable_out_0
+ad_connect  tx_upack/fifo_rd_data_1  tx_fir_interpolator/data_in_1
+ad_connect  tx_upack/enable_1  tx_fir_interpolator/enable_out_1
+
+ad_connect axi_ad9361/dac_enable_i1 tx_upack/enable_2
+ad_connect axi_ad9361/dac_data_i1 tx_upack/fifo_rd_data_2
+ad_connect axi_ad9361/dac_enable_q1 tx_upack/enable_3
+ad_connect axi_ad9361/dac_data_q1 tx_upack/fifo_rd_data_3
+
+ad_connect tx_upack/s_axis  axi_ad9361_dac_dma/m_axis
+
+ad_ip_instance util_vector_logic logic_or [list \
+  C_OPERATION {or} \
+  C_SIZE 1]
+
+ad_connect  logic_or/Op1  tx_fir_interpolator/valid_out_0
+ad_connect  logic_or/Op2  axi_ad9361/dac_valid_i1
+ad_connect  logic_or/Res  tx_upack/fifo_rd_en
+ad_connect  tx_upack/fifo_rd_underflow axi_ad9361/dac_dunf
+
+ad_connect axi_ad9361/up_dac_gpio_out interp_slice/Din
+ad_connect  tx_fir_interpolator/active interp_slice/Dout
+
+ad_connect  axi_ad9361/l_clk axi_ad9361_adc_dma/fifo_wr_clk
+ad_connect  axi_ad9361/l_clk axi_ad9361_dac_dma/m_axis_aclk
+ad_connect  cpack/fifo_wr_overflow axi_ad9361/adc_dovf
+
+# External TDD
+set TDD_CHANNEL_CNT 3
+set TDD_DEFAULT_POL 0b010
+set TDD_REG_WIDTH 32
+set TDD_BURST_WIDTH 32
+set TDD_SYNC_WIDTH 0
+set TDD_SYNC_INT 0
+set TDD_SYNC_EXT 1
+set TDD_SYNC_EXT_CDC 1
+ad_tdd_gen_create axi_tdd_0 $TDD_CHANNEL_CNT \
+                            $TDD_DEFAULT_POL \
+                            $TDD_REG_WIDTH \
+                            $TDD_BURST_WIDTH \
+                            $TDD_SYNC_WIDTH \
+                            $TDD_SYNC_INT \
+                            $TDD_SYNC_EXT \
+                            $TDD_SYNC_EXT_CDC
+
+ad_ip_instance util_vector_logic logic_inv [list \
+  C_OPERATION {not} \
+  C_SIZE 1]
+
+ad_ip_instance util_vector_logic logic_or_1 [list \
+  C_OPERATION {or} \
+  C_SIZE 1]
+
+ad_connect logic_inv/Op1  axi_ad9361/rst
+ad_connect logic_inv/Res  axi_tdd_0/resetn
+ad_connect axi_ad9361/l_clk axi_tdd_0/clk
+ad_connect axi_tdd_0/sync_in tdd_ext_sync
+ad_connect axi_tdd_0/tdd_channel_0 txdata_o
+ad_connect axi_tdd_0/tdd_channel_1 axi_ad9361_adc_dma/fifo_wr_sync
+
+ad_connect  logic_or_1/Op1  axi_ad9361/rst
+ad_connect  logic_or_1/Op2  axi_tdd_0/tdd_channel_2
+ad_connect  logic_or_1/Res  tx_upack/reset
+
+# interconnects
+
+ad_cpu_interconnect 0x79020000 axi_ad9361
+ad_cpu_interconnect 0x7C400000 axi_ad9361_adc_dma
+ad_cpu_interconnect 0x7C420000 axi_ad9361_dac_dma
+ad_cpu_interconnect 0x7C440000 axi_tdd_0
+ad_cpu_interconnect 0x43C00000 axi_vcxo_ctrl
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP1 {1}
+ad_connect sys_cpu_clk sys_ps7/S_AXI_HP1_ACLK
+ad_connect axi_ad9361_adc_dma/m_dest_axi sys_ps7/S_AXI_HP1
+
+create_bd_addr_seg -range 0x40000000 -offset 0x00000000 \
+                    [get_bd_addr_spaces axi_ad9361_adc_dma/m_dest_axi] \
+                    [get_bd_addr_segs sys_ps7/S_AXI_HP1/HP1_DDR_LOWOCM] \
+                    SEG_sys_ps7_HP1_DDR_LOWOCM
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP2 {1}
+ad_connect sys_cpu_clk sys_ps7/S_AXI_HP2_ACLK
+ad_connect axi_ad9361_dac_dma/m_src_axi sys_ps7/S_AXI_HP2
+
+create_bd_addr_seg -range 0x40000000 -offset 0x00000000 \
+                    [get_bd_addr_spaces axi_ad9361_dac_dma/m_src_axi] \
+                    [get_bd_addr_segs sys_ps7/S_AXI_HP2/HP2_DDR_LOWOCM] \
+                    SEG_sys_ps7_HP2_DDR_LOWOCM
+
+ad_connect sys_cpu_clk axi_ad9361_dac_dma/m_src_axi_aclk
+ad_connect sys_cpu_clk axi_ad9361_adc_dma/m_dest_axi_aclk
+ad_connect sys_cpu_resetn axi_ad9361_adc_dma/m_dest_axi_aresetn
+ad_connect sys_cpu_resetn axi_ad9361_dac_dma/m_src_axi_aresetn
+
+# interrupts
+
+ad_cpu_interrupt ps-13 mb-13 axi_ad9361_adc_dma/irq
+ad_cpu_interrupt ps-12 mb-12 axi_ad9361_dac_dma/irq
+
diff --git a/projects/ant/system_constr.xdc b/projects/ant/system_constr.xdc
new file mode 100644
index 000000000..b312ff2cf
--- /dev/null
+++ b/projects/ant/system_constr.xdc
@@ -0,0 +1,91 @@
+set_property -dict {PACKAGE_PIN K16 IOSTANDARD LVCMOS33} [get_ports CLK_40M_DAC_nSYNC];
+set_property -dict {PACKAGE_PIN J16 IOSTANDARD LVCMOS33} [get_ports CLK_40M_DAC_SCLK];
+set_property -dict {PACKAGE_PIN J15 IOSTANDARD LVCMOS33} [get_ports CLK_40M_DAC_DIN];
+set_property -dict {PACKAGE_PIN J18 IOSTANDARD LVCMOS33} [get_ports PPS_IN];
+set_property -dict {PACKAGE_PIN K17 IOSTANDARD LVCMOS33} [get_ports CLK_40MHz_FPGA];
+set_property -dict {PACKAGE_PIN T9 IOSTANDARD LVCMOS18} [get_ports CLKIN_10MHz];
+set_property -dict {PACKAGE_PIN V6 IOSTANDARD LVCMOS18} [get_ports CLKIN_10MHz_REQ];
+
+
+
+
+set_property -dict { PACKAGE_PIN T10 IOSTANDARD LVCMOS18} [get_ports {gpio_ctl[0]}];
+set_property -dict { PACKAGE_PIN Y12 IOSTANDARD LVCMOS18} [get_ports {gpio_ctl[1]}];
+set_property -dict { PACKAGE_PIN Y13 IOSTANDARD LVCMOS18} [get_ports {gpio_ctl[2]}];
+set_property -dict { PACKAGE_PIN V11 IOSTANDARD LVCMOS18} [get_ports {gpio_ctl[3]}];
+set_property -dict { PACKAGE_PIN T11 IOSTANDARD LVCMOS18} [get_ports {gpio_status[0]}];
+set_property -dict { PACKAGE_PIN T14 IOSTANDARD LVCMOS18} [get_ports {gpio_status[1]}];
+set_property -dict { PACKAGE_PIN T15 IOSTANDARD LVCMOS18} [get_ports {gpio_status[2]}];
+set_property -dict { PACKAGE_PIN T17 IOSTANDARD LVCMOS18} [get_ports {gpio_status[3]}];
+set_property -dict { PACKAGE_PIN T19 IOSTANDARD LVCMOS18} [get_ports {gpio_status[4]}];
+set_property -dict { PACKAGE_PIN T20 IOSTANDARD LVCMOS18} [get_ports {gpio_status[5]}];
+set_property -dict { PACKAGE_PIN U13 IOSTANDARD LVCMOS18} [get_ports {gpio_status[6]}];
+set_property -dict { PACKAGE_PIN V13 IOSTANDARD LVCMOS18} [get_ports {gpio_status[7]}];
+set_property -dict { PACKAGE_PIN P14 IOSTANDARD LVCMOS18} [get_ports txnrx];
+set_property -dict { PACKAGE_PIN M15 IOSTANDARD LVCMOS18} [get_ports clk_out];
+set_property -dict { PACKAGE_PIN R18 IOSTANDARD LVCMOS18} [get_ports enable];
+set_property -dict { PACKAGE_PIN P16 IOSTANDARD LVCMOS18} [get_ports gpio_en_agc];
+set_property -dict { PACKAGE_PIN N17 IOSTANDARD LVCMOS18} [get_ports gpio_resetb];
+
+
+set_property -dict { PACKAGE_PIN P18 IOSTANDARD LVCMOS18 PULLUP true} [get_ports spi_csn];
+set_property -dict { PACKAGE_PIN R14 IOSTANDARD LVCMOS18} [get_ports spi_clk];
+set_property -dict { PACKAGE_PIN P15 IOSTANDARD LVCMOS18} [get_ports spi_mosi];
+set_property -dict { PACKAGE_PIN R19 IOSTANDARD LVCMOS18} [get_ports spi_miso];
+
+
+
+set_property -dict { PACKAGE_PIN N20 IOSTANDARD LVCMOS18} [get_ports rx_clk_in];
+set_property -dict { PACKAGE_PIN U18 IOSTANDARD LVCMOS18} [get_ports rx_frame_in];
+set_property -dict { PACKAGE_PIN Y19 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[0]}];
+set_property -dict { PACKAGE_PIN Y18 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[1]}];
+set_property -dict { PACKAGE_PIN V18 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[2]}];
+set_property -dict { PACKAGE_PIN V17 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[3]}];
+set_property -dict { PACKAGE_PIN W20 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[4]}];
+set_property -dict { PACKAGE_PIN V20 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[5]}];
+set_property -dict { PACKAGE_PIN R17 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[6]}];
+set_property -dict { PACKAGE_PIN R16 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[7]}];
+set_property -dict { PACKAGE_PIN W19 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[8]}];
+set_property -dict { PACKAGE_PIN W18 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[9]}];
+set_property -dict { PACKAGE_PIN W16 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[10]}];
+set_property -dict { PACKAGE_PIN V16 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[11]}];
+
+set_property -dict { PACKAGE_PIN Y14 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[0]}];
+set_property -dict { PACKAGE_PIN W14 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[1]}];
+set_property -dict { PACKAGE_PIN U12 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[2]}];
+set_property -dict { PACKAGE_PIN T12 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[3]}];
+set_property -dict { PACKAGE_PIN U15 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[4]}];
+set_property -dict { PACKAGE_PIN U14 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[5]}];
+set_property -dict { PACKAGE_PIN U17 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[6]}];
+set_property -dict { PACKAGE_PIN T16 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[7]}];
+set_property -dict { PACKAGE_PIN W13 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[8]}];
+set_property -dict { PACKAGE_PIN V12 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[9]}];
+set_property -dict { PACKAGE_PIN W15 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[10]}];
+set_property -dict { PACKAGE_PIN V15 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[11]}];
+set_property -dict { PACKAGE_PIN N18 IOSTANDARD LVCMOS18} [get_ports tx_clk_out];
+set_property -dict { PACKAGE_PIN Y16 IOSTANDARD LVCMOS18} [get_ports tx_frame_out];
+
+
+
+set_property -dict { PACKAGE_PIN G14 IOSTANDARD LVCMOS33 } [get_ports VCRX1_H];
+set_property -dict { PACKAGE_PIN C20 IOSTANDARD LVCMOS33 } [get_ports VCRX1_L];
+set_property -dict { PACKAGE_PIN B19 IOSTANDARD LVCMOS33 } [get_ports VCRX2_H];
+set_property -dict { PACKAGE_PIN B20 IOSTANDARD LVCMOS33 } [get_ports VCRX2_L];
+set_property -dict { PACKAGE_PIN E17 IOSTANDARD LVCMOS33 } [get_ports VCTX1_H];
+set_property -dict { PACKAGE_PIN A20 IOSTANDARD LVCMOS33 } [get_ports VCTX1_L];
+set_property -dict { PACKAGE_PIN D18 IOSTANDARD LVCMOS33 } [get_ports VCTX2_H];
+set_property -dict { PACKAGE_PIN D19 IOSTANDARD LVCMOS33 } [get_ports VCTX2_L];
+
+create_clock -name rx_clk -period  16.27 [get_ports rx_clk_in];
+create_clock -name clk_fpga_0 -period 10 [get_pins "i_system_wrapper/system_i/sys_ps7/inst/PS7_i/FCLKCLK[0]"];
+create_clock -name clk_fpga_1 -period  5 [get_pins "i_system_wrapper/system_i/sys_ps7/inst/PS7_i/FCLKCLK[1]"];
+
+create_clock -name spi0_clk      -period 40   [get_pins -hier */EMIOSPI0SCLKO];
+
+set_input_jitter clk_fpga_0 0.3;
+set_input_jitter clk_fpga_1 0.15;
+
+
+set_false_path -from [get_pins {i_system_wrapper/system_i/axi_ad9361/inst/i_rx/i_up_adc_common/up_adc_gpio_out_int_reg[0]/C}];
+set_false_path -from [get_pins {i_system_wrapper/system_i/axi_ad9361/inst/i_tx/i_up_dac_common/up_dac_gpio_out_int_reg[0]/C}];
+
diff --git a/projects/ant/system_project.tcl b/projects/ant/system_project.tcl
new file mode 100644
index 000000000..525496c19
--- /dev/null
+++ b/projects/ant/system_project.tcl
@@ -0,0 +1,15 @@
+source ../../scripts/adi_env.tcl
+source $ad_hdl_dir/projects/scripts/adi_project_xilinx.tcl
+source $ad_hdl_dir/projects/scripts/adi_board.tcl
+
+adi_project_create ant 0 {} "xc7z020clg400-2"
+
+adi_project_files ant [list \
+  "system_top.v" \
+  "system_constr.xdc" \
+  "$ad_hdl_dir/library/common/ad_iobuf.v"]
+
+set_property is_enabled false [get_files  *system_sys_ps7_0.xdc]
+adi_project_run ant
+source $ad_hdl_dir/library/axi_ad9361/axi_ad9361_delay.tcl
+
diff --git a/projects/ant/system_top.v b/projects/ant/system_top.v
new file mode 100644
index 000000000..9ae91a15e
--- /dev/null
+++ b/projects/ant/system_top.v
@@ -0,0 +1,233 @@
+// ***************************************************************************
+// ***************************************************************************
+// Copyright (C) 2014-2023 Analog Devices, Inc. All rights reserved.
+//
+// In this HDL repository, there are many different and unique modules, consisting
+// of various HDL (Verilog or VHDL) components. The individual modules are
+// developed independently, and may be accompanied by separate and unique license
+// terms.
+//
+// The user should read each of these license terms, and understand the
+// freedoms and responsibilities that he or she has by using this source/core.
+//
+// This core is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+// A PARTICULAR PURPOSE.
+//
+// Redistribution and use of source or resulting binaries, with or without modification
+// of this file, are permitted under one of the following two license terms:
+//
+//   1. The GNU General Public License version 2 as published by the
+//      Free Software Foundation, which can be found in the top level directory
+//      of this repository (LICENSE_GPL2), and also online at:
+//      <https://www.gnu.org/licenses/old-licenses/gpl-2.0.html>
+//
+// OR
+//
+//   2. An ADI specific BSD license, which can be found in the top level directory
+//      of this repository (LICENSE_ADIBSD), and also on-line at:
+//      https://github.com/analogdevicesinc/hdl/blob/master/LICENSE_ADIBSD
+//      This will allow to generate bit files and not release the source code,
+//      as long as it attaches to an ADI device.
+//
+// ***************************************************************************
+// ***************************************************************************
+
+`timescale 1ns/100ps
+
+module system_top (
+
+  inout   [14:0]  ddr_addr,
+  inout   [ 2:0]  ddr_ba,
+  inout           ddr_cas_n,
+  inout           ddr_ck_n,
+  inout           ddr_ck_p,
+  inout           ddr_cke,
+  inout           ddr_cs_n,
+  inout   [ 3:0]  ddr_dm,
+  inout   [31:0]  ddr_dq,
+  inout   [ 3:0]  ddr_dqs_n,
+  inout   [ 3:0]  ddr_dqs_p,
+  inout           ddr_odt,
+  inout           ddr_ras_n,
+  inout           ddr_reset_n,
+  inout           ddr_we_n,
+
+  inout           fixed_io_ddr_vrn,
+  inout           fixed_io_ddr_vrp,
+  inout   [53:0]  fixed_io_mio,
+  inout           fixed_io_ps_clk,
+  inout           fixed_io_ps_porb,
+  inout           fixed_io_ps_srstb,
+
+  input           rx_clk_in,
+  input           rx_frame_in,
+  input   [11:0]  rx_data_in,
+  output          tx_clk_out,
+  output          tx_frame_out,
+  output  [11:0]  tx_data_out,
+
+  output          enable,
+  output          txnrx,
+  
+  inout           gpio_resetb,
+  inout           gpio_en_agc,
+  inout   [ 3:0]  gpio_ctl,
+  inout   [ 7:0]  gpio_status,
+
+  output          spi_csn,
+  output          spi_clk,
+  output          spi_mosi,
+  input           spi_miso,
+
+
+  // clock form vctcxo
+  input  wire	 			      CLK_40MHz_FPGA  ,
+  // PPS or 10 MHz (need to choose from SW)
+  input  wire             PPS_IN          ,
+  input  wire             CLKIN_10MHz     ,
+  output wire             CLKIN_10MHz_REQ ,
+
+  // Clock disciplining / AD5662 controls
+  output wire             CLK_40M_DAC_nSYNC,
+  output wire             CLK_40M_DAC_SCLK ,
+  output wire             CLK_40M_DAC_DIN ,
+
+
+  output          VCRX1_H,
+  output          VCRX1_L,
+  output          VCTX1_H,
+  output          VCTX1_L,
+  output          VCRX2_H,
+  output          VCRX2_L,
+  output          VCTX2_H,
+  output          VCTX2_L
+  
+  
+  );
+
+  // internal signals
+
+  wire    [63:0]  gpio_i;
+  wire    [63:0]  gpio_o;
+  wire    [63:0]  gpio_t;
+
+  wire            iic_scl;
+  wire            iic_sda;
+  wire            phaser_enable;
+  wire            pl_burst;
+  wire            pl_muxout;
+  wire            pl_spi_clk_o;
+  wire            pl_spi_miso;
+  wire            pl_spi_mosi;
+  wire            pl_txdata;
+
+  // instantiations
+
+  ad_iobuf #(
+    .DATA_WIDTH(14)
+  ) i_iobuf (
+    .dio_t (gpio_t[13:0]),
+    .dio_i (gpio_o[13:0]),
+    .dio_o (gpio_i[13:0]),
+    .dio_p ({ gpio_resetb,        // 13:13
+              gpio_en_agc,        // 12:12
+              gpio_ctl,           // 11: 8
+              gpio_status}));     //  7: 0
+
+  assign gpio_i[16:14] = gpio_o[16:14];
+  assign gpio_i[17] = pl_muxout;
+  assign phaser_enable = gpio_o[14];
+
+  assign pl_gpio4 = iic_scl;      //PL_GPIO4
+  assign pl_gpio3 = iic_sda;      //PL_GPIO3
+
+  assign VCRX1_H=gpio_o[32];
+  assign VCRX1_L=gpio_o[33];
+  assign VCTX1_H=gpio_o[34];
+  assign VCTX1_L=gpio_o[35];
+  assign VCRX2_H=gpio_o[36];
+  assign VCRX2_L=gpio_o[37];
+  assign VCTX2_H=gpio_o[38];
+  assign VCTX2_L=gpio_o[39];
+
+  assign CLKIN_10MHz_REQ = 1'b1;
+
+  //PL_GPIO2
+  ad_iobuf #(
+    .DATA_WIDTH(1)
+  ) i_pl_gpio_iobuf (
+    .dio_t (phaser_enable),
+    .dio_i (pl_spi_clk_o),
+    .dio_o (pl_muxout),
+    .dio_p (pl_gpio2));
+
+  //PL_GPIO1
+  // assign pl_spi_miso = pl_gpio1 & ~phaser_enable;
+  // assign pl_burst    = pl_gpio1 &  phaser_enable;
+
+  //PL_GPIO0
+  assign pl_gpio0 = phaser_enable ? pl_txdata : pl_spi_mosi;
+
+  system_wrapper i_system_wrapper (
+    .CLKIN_10MHz(CLKIN_10MHz),
+    .CLK_40MHz_FPGA(CLK_40MHz_FPGA),
+    .CLK_40M_DAC_DIN(CLK_40M_DAC_DIN),
+    .CLK_40M_DAC_SCLK(CLK_40M_DAC_SCLK),
+    .CLK_40M_DAC_nSYNC(CLK_40M_DAC_nSYNC),
+    .PPS_GPS(1'b0),
+    .PPS_IN(PPS_IN),
+    .PPS_LED(),
+    .PPS_LOCKED(),
+    .REF_10M_LOCKED(),
+    .ddr_addr (ddr_addr),
+    .ddr_ba (ddr_ba),
+    .ddr_cas_n (ddr_cas_n),
+    .ddr_ck_n (ddr_ck_n),
+    .ddr_ck_p (ddr_ck_p),
+    .ddr_cke (ddr_cke),
+    .ddr_cs_n (ddr_cs_n),
+    .ddr_dm (ddr_dm),
+    .ddr_dq (ddr_dq),
+    .ddr_dqs_n (ddr_dqs_n),
+    .ddr_dqs_p (ddr_dqs_p),
+    .ddr_odt (ddr_odt),
+    .ddr_ras_n (ddr_ras_n),
+    .ddr_reset_n (ddr_reset_n),
+    .ddr_we_n (ddr_we_n),
+    .enable (enable),
+    .fixed_io_ddr_vrn (fixed_io_ddr_vrn),
+    .fixed_io_ddr_vrp (fixed_io_ddr_vrp),
+    .fixed_io_mio (fixed_io_mio),
+    .fixed_io_ps_clk (fixed_io_ps_clk),
+    .fixed_io_ps_porb (fixed_io_ps_porb),
+    .fixed_io_ps_srstb (fixed_io_ps_srstb),
+    .gpio_i (gpio_i),
+    .gpio_o (gpio_o),
+    .gpio_t (gpio_t),
+    
+    .rx_clk_in (rx_clk_in),
+    .rx_data_in (rx_data_in),
+    .rx_frame_in (rx_frame_in),
+
+    .spi0_clk_i (1'b0),
+    .spi0_clk_o (spi_clk),
+    .spi0_csn_0_o (spi_csn),
+    .spi0_csn_1_o (),
+    .spi0_csn_2_o (),
+    .spi0_csn_i (1'b1),
+    .spi0_sdi_i (spi_miso),
+    .spi0_sdo_i (1'b0),
+    .spi0_sdo_o (spi_mosi),
+
+    .tdd_ext_sync(pl_burst),
+    .txdata_o(pl_txdata),
+
+    .tx_clk_out (tx_clk_out),
+    .tx_data_out (tx_data_out),
+    .tx_frame_out (tx_frame_out),
+    .txnrx (txnrx),
+    .up_enable (gpio_o[15]),
+    .up_txnrx (gpio_o[16]));
+
+endmodule
diff --git a/projects/e200/Makefile b/projects/e200/Makefile
new file mode 100644
index 000000000..1c9b4f2f4
--- /dev/null
+++ b/projects/e200/Makefile
@@ -0,0 +1,25 @@
+####################################################################################
+## Copyright (c) 2018 - 2023 Analog Devices, Inc.
+### SPDX short identifier: BSD-1-Clause
+## Auto-generated, do not modify!
+####################################################################################
+
+PROJECT_NAME := e200
+
+M_DEPS += ../common/xilinx/adi_fir_filter_constr.xdc
+M_DEPS += ../common/xilinx/adi_fir_filter_bd.tcl
+M_DEPS += ../../library/util_cdc/sync_bits.v
+M_DEPS += ../../library/common/util_pulse_gen.v
+M_DEPS += ../../library/common/ad_iobuf.v
+M_DEPS += ../../library/common/ad_bus_mux.v
+M_DEPS += ../../library/axi_tdd/scripts/axi_tdd.tcl
+M_DEPS += ../../library/axi_ad9361/axi_ad9361_delay.tcl
+
+LIB_DEPS += axi_ad9361
+LIB_DEPS += axi_dmac
+LIB_DEPS += axi_tdd
+LIB_DEPS += util_pack/util_cpack2
+LIB_DEPS += util_pack/util_upack2
+
+
+include ../scripts/project-xilinx.mk
diff --git a/projects/e200/system_bd.tcl b/projects/e200/system_bd.tcl
new file mode 100644
index 000000000..5f702b8e7
--- /dev/null
+++ b/projects/e200/system_bd.tcl
@@ -0,0 +1,406 @@
+# create board design
+
+source $ad_hdl_dir/projects/common/xilinx/adi_fir_filter_bd.tcl
+source $ad_hdl_dir/library/axi_tdd/scripts/axi_tdd.tcl
+set_property  ip_repo_paths  { ../../library/} [current_project]
+update_ip_catalog
+
+# default ports
+
+create_bd_intf_port -mode Master -vlnv xilinx.com:interface:ddrx_rtl:1.0 ddr
+create_bd_intf_port -mode Master -vlnv xilinx.com:display_processing_system7:fixedio_rtl:1.0 fixed_io
+
+create_bd_intf_port -mode Master -vlnv xilinx.com:interface:mdio_rtl:1.0 MDIO_PHY
+create_bd_intf_port -mode Master -vlnv xilinx.com:interface:rgmii_rtl:1.0 RGMII
+
+create_bd_port -dir O eth_rst_n
+
+create_bd_port -dir O spi0_csn_2_o
+create_bd_port -dir O spi0_csn_1_o
+create_bd_port -dir O spi0_csn_0_o
+create_bd_port -dir I spi0_csn_i
+create_bd_port -dir I spi0_clk_i
+create_bd_port -dir O spi0_clk_o
+create_bd_port -dir I spi0_sdo_i
+create_bd_port -dir O spi0_sdo_o
+create_bd_port -dir I spi0_sdi_i
+
+create_bd_port -dir I -from 63 -to 0 gpio_i
+create_bd_port -dir O -from 63 -to 0 gpio_o
+create_bd_port -dir O -from 63 -to 0 gpio_t
+
+create_bd_port -dir O txdata_o
+create_bd_port -dir I tdd_ext_sync
+
+
+create_bd_port -dir I CLKIN_10MHz
+create_bd_port -dir I CLK_40MHz_FPGA
+create_bd_port -dir O CLK_40M_DAC_DIN
+create_bd_port -dir O CLK_40M_DAC_SCLK
+create_bd_port -dir O CLK_40M_DAC_nSYNC
+create_bd_port -dir I PPS_GPS
+create_bd_port -dir I PPS_IN
+create_bd_port -dir O PPS_LED
+create_bd_port -dir O PPS_LOCKED
+create_bd_port -dir O REF_10M_LOCKED
+
+# instance: sys_ps7
+
+ad_ip_instance processing_system7 sys_ps7
+
+# ps7 settings
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_PRESET_BANK0_VOLTAGE {LVCMOS 3.3V}
+ad_ip_parameter sys_ps7 CONFIG.PCW_PRESET_BANK1_VOLTAGE {LVCMOS 3.3V}
+ad_ip_parameter sys_ps7 CONFIG.PCW_PACKAGE_NAME clg400
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_MIO_GPIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_ENET0_IO "EMIO"
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_GRP_MDIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_GRP_MDIO_IO "EMIO"
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP1 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP2 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_EN_CLK1_PORT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_EN_RST1_PORT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_FPGA0_PERIPHERAL_FREQMHZ 100.0
+ad_ip_parameter sys_ps7 CONFIG.PCW_FPGA1_PERIPHERAL_FREQMHZ 200.0
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_EMIO_GPIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_EMIO_GPIO_IO 64
+ad_ip_parameter sys_ps7 CONFIG.PCW_SPI1_PERIPHERAL_ENABLE 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_I2C0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_I2C0_I2C0_IO {MIO 10 .. 11}
+ad_ip_parameter sys_ps7 CONFIG.PCW_SD0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_SDIO_PERIPHERAL_FREQMHZ 50
+ad_ip_parameter sys_ps7 CONFIG.PCW_UART0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UART0_UART0_IO {MIO 14 .. 15}
+ad_ip_parameter sys_ps7 CONFIG.PCW_I2C1_PERIPHERAL_ENABLE 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_QSPI_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_QSPI_GRP_SINGLE_SS_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_SPI0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_SPI0_SPI0_IO EMIO
+ad_ip_parameter sys_ps7 CONFIG.PCW_TTC0_PERIPHERAL_ENABLE 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_FABRIC_INTERRUPT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_USB0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_MIO_GPIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_MIO_GPIO_IO MIO
+ad_ip_parameter sys_ps7 CONFIG.PCW_USB0_RESET_IO {MIO 47}
+ad_ip_parameter sys_ps7 CONFIG.PCW_USB0_RESET_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_IRQ_F2P_INTR 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_IRQ_F2P_MODE REVERSE
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_0_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_9_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_10_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_11_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_48_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_49_PULLUP {disabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_53_PULLUP {enabled}
+
+# DDR MT41K256M16 HA-125 (32M, 16bit, 8banks)
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_PARTNO {MT41J256M16 RE-125}
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_BUS_WIDTH {16 Bit}
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_USE_INTERNAL_VREF 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_TRAIN_WRITE_LEVEL 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_TRAIN_READ_GATE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_TRAIN_DATA_EYE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_DQS_TO_CLK_DELAY_0 0.048
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_DQS_TO_CLK_DELAY_1 0.050
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_BOARD_DELAY0 0.241
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_BOARD_DELAY1 0.240
+
+ad_ip_instance xlconcat sys_concat_intc
+ad_ip_parameter sys_concat_intc CONFIG.NUM_PORTS 16
+
+ad_ip_instance proc_sys_reset sys_rstgen
+ad_ip_parameter sys_rstgen CONFIG.C_EXT_RST_WIDTH 1
+
+# system reset/clock definitions
+
+# add external ethernet phy
+ad_ip_instance gmii_to_rgmii sys_rgmii
+ad_ip_parameter sys_rgmii CONFIG.SupportLevel Include_Shared_Logic_in_Core
+
+
+
+set axi_vcxo_ctrl [ create_bd_cell -type ip -vlnv user.org:user:axi_vcxo_ctrl:1.0 axi_vcxo_ctrl ]
+ad_connect axi_vcxo_ctrl/CLK_40M_DAC_DIN CLK_40M_DAC_DIN
+ad_connect axi_vcxo_ctrl/CLK_40M_DAC_SCLK CLK_40M_DAC_SCLK
+ad_connect axi_vcxo_ctrl/CLK_40M_DAC_nSYNC CLK_40M_DAC_nSYNC
+ad_connect axi_vcxo_ctrl/CLKIN_10MHz CLKIN_10MHz
+ad_connect axi_vcxo_ctrl/CLK_40MHz_FPGA CLK_40MHz_FPGA
+ad_connect axi_vcxo_ctrl/PPS_GPS PPS_GPS
+ad_connect axi_vcxo_ctrl/PPS_IN PPS_IN
+ad_connect axi_vcxo_ctrl/PPS_LED PPS_LED
+ad_connect axi_vcxo_ctrl/PPS_LOCKED PPS_LOCKED
+ad_connect axi_vcxo_ctrl/REF_10M_LOCKED REF_10M_LOCKED
+
+
+
+
+ad_connect  sys_cpu_clk sys_ps7/FCLK_CLK0
+ad_connect  sys_200m_clk sys_ps7/FCLK_CLK1
+ad_connect  sys_cpu_reset sys_rstgen/peripheral_reset
+ad_connect  sys_cpu_resetn sys_rstgen/peripheral_aresetn
+ad_connect  eth_rst_n sys_rstgen/peripheral_aresetn
+ad_connect  sys_cpu_clk sys_rstgen/slowest_sync_clk
+ad_connect  sys_rstgen/ext_reset_in sys_ps7/FCLK_RESET0_N
+ad_connect  sys_rgmii/tx_reset sys_rstgen/peripheral_reset
+ad_connect  sys_rgmii/rx_reset sys_rstgen/peripheral_reset
+ad_connect  sys_rgmii/clkin sys_ps7/FCLK_CLK1 
+ad_connect  sys_ps7/MDIO_ETHERNET_0 sys_rgmii/MDIO_GEM
+ad_connect  sys_ps7/GMII_ETHERNET_0 sys_rgmii/GMII
+ad_connect  sys_rgmii/MDIO_PHY MDIO_PHY
+ad_connect  sys_rgmii/RGMII RGMII
+
+# interface connections
+
+ad_connect  ddr sys_ps7/DDR
+ad_connect  gpio_i sys_ps7/GPIO_I
+ad_connect  gpio_o sys_ps7/GPIO_O
+ad_connect  gpio_t sys_ps7/GPIO_T
+ad_connect  fixed_io sys_ps7/FIXED_IO
+
+# ps7 spi connections
+
+ad_connect  spi0_csn_2_o sys_ps7/SPI0_SS2_O
+ad_connect  spi0_csn_1_o sys_ps7/SPI0_SS1_O
+ad_connect  spi0_csn_0_o sys_ps7/SPI0_SS_O
+ad_connect  spi0_csn_i sys_ps7/SPI0_SS_I
+ad_connect  spi0_clk_i sys_ps7/SPI0_SCLK_I
+ad_connect  spi0_clk_o sys_ps7/SPI0_SCLK_O
+ad_connect  spi0_sdo_i sys_ps7/SPI0_MOSI_I
+ad_connect  spi0_sdo_o sys_ps7/SPI0_MOSI_O
+ad_connect  spi0_sdi_i sys_ps7/SPI0_MISO_I
+
+
+# interrupts
+
+ad_connect  sys_concat_intc/dout sys_ps7/IRQ_F2P
+ad_connect  sys_concat_intc/In15 GND
+ad_connect  sys_concat_intc/In14 GND
+ad_connect  sys_concat_intc/In13 GND
+ad_connect  sys_concat_intc/In12 GND
+ad_connect  sys_concat_intc/In11 GND
+ad_connect  sys_concat_intc/In10 GND
+ad_connect  sys_concat_intc/In9 GND
+ad_connect  sys_concat_intc/In8 GND
+ad_connect  sys_concat_intc/In7 GND
+ad_connect  sys_concat_intc/In6 GND
+ad_connect  sys_concat_intc/In5 GND
+ad_connect  sys_concat_intc/In4 GND
+ad_connect  sys_concat_intc/In3 GND
+ad_connect  sys_concat_intc/In2 GND
+ad_connect  sys_concat_intc/In1 GND
+ad_connect  sys_concat_intc/In0 GND
+
+
+# ad9361
+
+create_bd_port -dir I rx_clk_in
+create_bd_port -dir I rx_frame_in
+create_bd_port -dir I -from 11 -to 0 rx_data_in
+
+create_bd_port -dir O tx_clk_out
+create_bd_port -dir O tx_frame_out
+create_bd_port -dir O -from 11 -to 0 tx_data_out
+
+create_bd_port -dir O enable
+create_bd_port -dir O txnrx
+create_bd_port -dir I up_enable
+create_bd_port -dir I up_txnrx
+
+# ad9361 core(s)
+
+ad_ip_instance axi_ad9361 axi_ad9361
+ad_ip_parameter axi_ad9361 CONFIG.ID 0
+ad_ip_parameter axi_ad9361 CONFIG.CMOS_OR_LVDS_N 1
+ad_ip_parameter axi_ad9361 CONFIG.MODE_1R1T 0
+ad_ip_parameter axi_ad9361 CONFIG.ADC_INIT_DELAY 21
+
+ad_ip_instance axi_dmac axi_ad9361_dac_dma
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_TYPE_SRC 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_TYPE_DEST 1
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.CYCLIC 1
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.AXI_SLICE_SRC 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.AXI_SLICE_DEST 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_2D_TRANSFER 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_DATA_WIDTH_DEST 64
+
+ad_add_interpolation_filter "tx_fir_interpolator" 8 2 1 {61.44} {7.68} \
+                             "$ad_hdl_dir/library/util_fir_int/coefile_int.coe"
+ad_ip_instance xlslice interp_slice
+ad_ip_instance util_upack2 tx_upack
+
+ad_ip_instance axi_dmac axi_ad9361_adc_dma
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_TYPE_SRC 2
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_TYPE_DEST 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.CYCLIC 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.SYNC_TRANSFER_START 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.AXI_SLICE_SRC 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.AXI_SLICE_DEST 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_2D_TRANSFER 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_DATA_WIDTH_SRC 64
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.SYNC_TRANSFER_START {true}
+
+ad_add_decimation_filter "rx_fir_decimator" 8 2 1 {61.44} {61.44} \
+                         "$ad_hdl_dir/library/util_fir_int/coefile_int.coe"
+ad_ip_instance xlslice decim_slice
+ad_ip_instance util_cpack2 cpack
+
+# connections
+
+ad_connect  rx_clk_in axi_ad9361/rx_clk_in
+ad_connect  rx_frame_in axi_ad9361/rx_frame_in
+ad_connect  rx_data_in axi_ad9361/rx_data_in
+ad_connect  tx_clk_out axi_ad9361/tx_clk_out
+ad_connect  tx_frame_out axi_ad9361/tx_frame_out
+ad_connect  tx_data_out axi_ad9361/tx_data_out
+ad_connect  enable axi_ad9361/enable
+ad_connect  txnrx axi_ad9361/txnrx
+ad_connect  up_enable axi_ad9361/up_enable
+ad_connect  up_txnrx axi_ad9361/up_txnrx
+
+ad_connect  axi_ad9361/tdd_sync GND
+ad_connect  sys_200m_clk axi_ad9361/delay_clk
+ad_connect  axi_ad9361/l_clk axi_ad9361/clk
+
+ad_connect axi_ad9361/l_clk rx_fir_decimator/aclk
+
+ad_connect axi_ad9361/adc_valid_i0 rx_fir_decimator/valid_in_0
+ad_connect axi_ad9361/adc_enable_i0 rx_fir_decimator/enable_in_0
+ad_connect axi_ad9361/adc_data_i0 rx_fir_decimator/data_in_0
+ad_connect axi_ad9361/adc_valid_q0 rx_fir_decimator/valid_in_1
+ad_connect axi_ad9361/adc_enable_q0 rx_fir_decimator/enable_in_1
+ad_connect axi_ad9361/adc_data_q0 rx_fir_decimator/data_in_1
+
+ad_connect axi_ad9361/l_clk cpack/clk
+ad_connect axi_ad9361/rst cpack/reset
+
+ad_connect axi_ad9361/adc_enable_i1 cpack/enable_2
+ad_connect axi_ad9361/adc_data_i1 cpack/fifo_wr_data_2
+ad_connect axi_ad9361/adc_enable_q1 cpack/enable_3
+ad_connect axi_ad9361/adc_data_q1 cpack/fifo_wr_data_3
+
+ad_connect cpack/enable_0 rx_fir_decimator/enable_out_0
+ad_connect cpack/enable_1 rx_fir_decimator/enable_out_1
+ad_connect cpack/fifo_wr_data_0 rx_fir_decimator/data_out_0
+ad_connect cpack/fifo_wr_data_1 rx_fir_decimator/data_out_1
+ad_connect rx_fir_decimator/valid_out_0 cpack/fifo_wr_en
+
+ad_connect axi_ad9361_adc_dma/fifo_wr cpack/packed_fifo_wr
+ad_connect axi_ad9361/up_adc_gpio_out decim_slice/Din
+ad_connect rx_fir_decimator/active decim_slice/Dout
+
+ad_connect axi_ad9361/l_clk tx_fir_interpolator/aclk
+
+ad_connect axi_ad9361/dac_enable_i0 tx_fir_interpolator/dac_enable_0
+ad_connect axi_ad9361/dac_valid_i0 tx_fir_interpolator/dac_valid_0
+ad_connect axi_ad9361/dac_data_i0 tx_fir_interpolator/data_out_0
+ad_connect axi_ad9361/dac_enable_q0 tx_fir_interpolator/dac_enable_1
+ad_connect axi_ad9361/dac_valid_q0 tx_fir_interpolator/dac_valid_1
+ad_connect axi_ad9361/dac_data_q0 tx_fir_interpolator/data_out_1
+
+ad_connect  axi_ad9361/l_clk tx_upack/clk
+
+ad_connect  tx_upack/fifo_rd_data_0  tx_fir_interpolator/data_in_0
+ad_connect  tx_upack/enable_0  tx_fir_interpolator/enable_out_0
+ad_connect  tx_upack/fifo_rd_data_1  tx_fir_interpolator/data_in_1
+ad_connect  tx_upack/enable_1  tx_fir_interpolator/enable_out_1
+
+ad_connect axi_ad9361/dac_enable_i1 tx_upack/enable_2
+ad_connect axi_ad9361/dac_data_i1 tx_upack/fifo_rd_data_2
+ad_connect axi_ad9361/dac_enable_q1 tx_upack/enable_3
+ad_connect axi_ad9361/dac_data_q1 tx_upack/fifo_rd_data_3
+
+ad_connect tx_upack/s_axis  axi_ad9361_dac_dma/m_axis
+
+ad_ip_instance util_vector_logic logic_or [list \
+  C_OPERATION {or} \
+  C_SIZE 1]
+
+ad_connect  logic_or/Op1  tx_fir_interpolator/valid_out_0
+ad_connect  logic_or/Op2  axi_ad9361/dac_valid_i1
+ad_connect  logic_or/Res  tx_upack/fifo_rd_en
+ad_connect  tx_upack/fifo_rd_underflow axi_ad9361/dac_dunf
+
+ad_connect axi_ad9361/up_dac_gpio_out interp_slice/Din
+ad_connect  tx_fir_interpolator/active interp_slice/Dout
+
+ad_connect  axi_ad9361/l_clk axi_ad9361_adc_dma/fifo_wr_clk
+ad_connect  axi_ad9361/l_clk axi_ad9361_dac_dma/m_axis_aclk
+ad_connect  cpack/fifo_wr_overflow axi_ad9361/adc_dovf
+
+# External TDD
+set TDD_CHANNEL_CNT 3
+set TDD_DEFAULT_POL 0b010
+set TDD_REG_WIDTH 32
+set TDD_BURST_WIDTH 32
+set TDD_SYNC_WIDTH 0
+set TDD_SYNC_INT 0
+set TDD_SYNC_EXT 1
+set TDD_SYNC_EXT_CDC 1
+ad_tdd_gen_create axi_tdd_0 $TDD_CHANNEL_CNT \
+                            $TDD_DEFAULT_POL \
+                            $TDD_REG_WIDTH \
+                            $TDD_BURST_WIDTH \
+                            $TDD_SYNC_WIDTH \
+                            $TDD_SYNC_INT \
+                            $TDD_SYNC_EXT \
+                            $TDD_SYNC_EXT_CDC
+
+ad_ip_instance util_vector_logic logic_inv [list \
+  C_OPERATION {not} \
+  C_SIZE 1]
+
+ad_ip_instance util_vector_logic logic_or_1 [list \
+  C_OPERATION {or} \
+  C_SIZE 1]
+
+ad_connect logic_inv/Op1  axi_ad9361/rst
+ad_connect logic_inv/Res  axi_tdd_0/resetn
+ad_connect axi_ad9361/l_clk axi_tdd_0/clk
+ad_connect axi_tdd_0/sync_in tdd_ext_sync
+ad_connect axi_tdd_0/tdd_channel_0 txdata_o
+ad_connect axi_tdd_0/tdd_channel_1 axi_ad9361_adc_dma/fifo_wr_sync
+
+ad_connect  logic_or_1/Op1  axi_ad9361/rst
+ad_connect  logic_or_1/Op2  axi_tdd_0/tdd_channel_2
+ad_connect  logic_or_1/Res  tx_upack/reset
+
+# interconnects
+
+ad_cpu_interconnect 0x79020000 axi_ad9361
+ad_cpu_interconnect 0x7C400000 axi_ad9361_adc_dma
+ad_cpu_interconnect 0x7C420000 axi_ad9361_dac_dma
+ad_cpu_interconnect 0x7C440000 axi_tdd_0
+ad_cpu_interconnect 0x43C00000 axi_vcxo_ctrl
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP1 {1}
+ad_connect sys_cpu_clk sys_ps7/S_AXI_HP1_ACLK
+ad_connect axi_ad9361_adc_dma/m_dest_axi sys_ps7/S_AXI_HP1
+
+create_bd_addr_seg -range 0x20000000 -offset 0x00000000 \
+                    [get_bd_addr_spaces axi_ad9361_adc_dma/m_dest_axi] \
+                    [get_bd_addr_segs sys_ps7/S_AXI_HP1/HP1_DDR_LOWOCM] \
+                    SEG_sys_ps7_HP1_DDR_LOWOCM
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP2 {1}
+ad_connect sys_cpu_clk sys_ps7/S_AXI_HP2_ACLK
+ad_connect axi_ad9361_dac_dma/m_src_axi sys_ps7/S_AXI_HP2
+
+create_bd_addr_seg -range 0x20000000 -offset 0x00000000 \
+                    [get_bd_addr_spaces axi_ad9361_dac_dma/m_src_axi] \
+                    [get_bd_addr_segs sys_ps7/S_AXI_HP2/HP2_DDR_LOWOCM] \
+                    SEG_sys_ps7_HP2_DDR_LOWOCM
+
+ad_connect sys_cpu_clk axi_ad9361_dac_dma/m_src_axi_aclk
+ad_connect sys_cpu_clk axi_ad9361_adc_dma/m_dest_axi_aclk
+ad_connect sys_cpu_resetn axi_ad9361_adc_dma/m_dest_axi_aresetn
+ad_connect sys_cpu_resetn axi_ad9361_dac_dma/m_src_axi_aresetn
+
+# interrupts
+
+ad_cpu_interrupt ps-13 mb-13 axi_ad9361_adc_dma/irq
+ad_cpu_interrupt ps-12 mb-12 axi_ad9361_dac_dma/irq
+
+
diff --git a/projects/e200/system_constr.xdc b/projects/e200/system_constr.xdc
new file mode 100644
index 000000000..ef6ec3e90
--- /dev/null
+++ b/projects/e200/system_constr.xdc
@@ -0,0 +1,108 @@
+set_property -dict {PACKAGE_PIN V6 IOSTANDARD LVCMOS33} [get_ports CLK_40M_DAC_nSYNC];
+set_property -dict {PACKAGE_PIN W6 IOSTANDARD LVCMOS33} [get_ports CLK_40M_DAC_SCLK];
+set_property -dict {PACKAGE_PIN V10 IOSTANDARD LVCMOS33} [get_ports CLK_40M_DAC_DIN];
+set_property -dict {PACKAGE_PIN V11 IOSTANDARD LVCMOS33} [get_ports PPS_IN];
+set_property -dict {PACKAGE_PIN K17 IOSTANDARD LVCMOS18} [get_ports CLK_40MHz_FPGA];
+set_property -dict {PACKAGE_PIN J18 IOSTANDARD LVCMOS18} [get_ports CLKIN_10MHz];
+set_property -dict {PACKAGE_PIN M20 IOSTANDARD LVCMOS18} [get_ports CLKIN_10MHz_REQ];
+
+
+set_property -dict {PACKAGE_PIN C20 IOSTANDARD LVCMOS18} [get_ports {RGMII_td[3]}];
+set_property -dict {PACKAGE_PIN D19 IOSTANDARD LVCMOS18} [get_ports {RGMII_td[2]}];
+set_property -dict {PACKAGE_PIN D20 IOSTANDARD LVCMOS18} [get_ports {RGMII_td[1]}];
+set_property -dict {PACKAGE_PIN F19 IOSTANDARD LVCMOS18} [get_ports {RGMII_td[0]}];
+set_property -dict {PACKAGE_PIN E18 IOSTANDARD LVCMOS18} [get_ports {RGMII_rd[3]}];
+set_property -dict {PACKAGE_PIN E19 IOSTANDARD LVCMOS18} [get_ports {RGMII_rd[2]}];
+set_property -dict {PACKAGE_PIN E17 IOSTANDARD LVCMOS18} [get_ports {RGMII_rd[1]}];
+set_property -dict {PACKAGE_PIN F16 IOSTANDARD LVCMOS18} [get_ports {RGMII_rd[0]}];
+
+set_property -dict {PACKAGE_PIN F20 IOSTANDARD LVCMOS18} [get_ports RGMII_tx_ctl];
+set_property -dict {PACKAGE_PIN D18 IOSTANDARD LVCMOS18} [get_ports RGMII_txc];
+set_property -dict {PACKAGE_PIN G17 IOSTANDARD LVCMOS18} [get_ports RGMII_rx_ctl];
+set_property -dict {PACKAGE_PIN H16 IOSTANDARD LVCMOS18} [get_ports RGMII_rxc];
+set_property -dict {PACKAGE_PIN B19 IOSTANDARD LVCMOS18} [get_ports eth_rst_n];
+set_property -dict {PACKAGE_PIN A20 IOSTANDARD LVCMOS18} [get_ports MDIO_PHY_mdio_io];
+set_property -dict {PACKAGE_PIN B20 IOSTANDARD LVCMOS18} [get_ports MDIO_PHY_mdc];
+
+set_property -dict {PACKAGE_PIN G15 IOSTANDARD LVCMOS18} [get_ports tx_amp_en];
+
+create_clock -period 8.000 [get_ports RGMII_rxc];
+
+set_property -dict {PACKAGE_PIN T15 IOSTANDARD LVCMOS18} [get_ports {gpio_status[7]}];
+set_property -dict {PACKAGE_PIN K16 IOSTANDARD LVCMOS18} [get_ports {gpio_status[6]}];
+set_property -dict {PACKAGE_PIN P14 IOSTANDARD LVCMOS18} [get_ports {gpio_status[5]}];
+set_property -dict {PACKAGE_PIN P15 IOSTANDARD LVCMOS18} [get_ports {gpio_status[4]}];
+set_property -dict {PACKAGE_PIN R14 IOSTANDARD LVCMOS18} [get_ports {gpio_status[3]}];
+set_property -dict {PACKAGE_PIN J16 IOSTANDARD LVCMOS18} [get_ports {gpio_status[2]}];
+set_property -dict {PACKAGE_PIN J15 IOSTANDARD LVCMOS18} [get_ports {gpio_status[1]}];
+set_property -dict {PACKAGE_PIN T10 IOSTANDARD LVCMOS18} [get_ports {gpio_status[0]}];
+set_property -dict {PACKAGE_PIN T11 IOSTANDARD LVCMOS18} [get_ports {gpio_ctl[3]}];
+set_property -dict {PACKAGE_PIN V13 IOSTANDARD LVCMOS18} [get_ports {gpio_ctl[2]}];
+set_property -dict {PACKAGE_PIN T14 IOSTANDARD LVCMOS18} [get_ports {gpio_ctl[1]}];
+set_property -dict {PACKAGE_PIN U13 IOSTANDARD LVCMOS18} [get_ports {gpio_ctl[0]}];
+set_property -dict {PACKAGE_PIN P16 IOSTANDARD LVCMOS18} [get_ports gpio_en_agc];
+set_property -dict {PACKAGE_PIN T17 IOSTANDARD LVCMOS18} [get_ports gpio_resetb];
+set_property -dict {PACKAGE_PIN R18 IOSTANDARD LVCMOS18} [get_ports enable];
+set_property -dict {PACKAGE_PIN N17 IOSTANDARD LVCMOS18} [get_ports txnrx];
+
+set_property PACKAGE_PIN T20 [get_ports spi_csn];
+set_property IOSTANDARD LVCMOS18 [get_ports spi_csn];
+set_property PULLUP true [get_ports spi_csn];
+set_property -dict {PACKAGE_PIN R19 IOSTANDARD LVCMOS18} [get_ports spi_clk];
+set_property -dict {PACKAGE_PIN P18 IOSTANDARD LVCMOS18} [get_ports spi_mosi];
+set_property -dict {PACKAGE_PIN T19 IOSTANDARD LVCMOS18} [get_ports spi_miso];
+
+
+set_property -dict {PACKAGE_PIN N20 IOSTANDARD LVCMOS18} [get_ports rx_clk_in];
+set_property -dict {PACKAGE_PIN Y16 IOSTANDARD LVCMOS18} [get_ports rx_frame_in];
+set_property -dict {PACKAGE_PIN W14 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[11]}];
+set_property -dict {PACKAGE_PIN Y14 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[10]}];
+set_property -dict {PACKAGE_PIN V20 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[9]}];
+set_property -dict {PACKAGE_PIN W20 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[8]}];
+set_property -dict {PACKAGE_PIN R16 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[7]}];
+set_property -dict {PACKAGE_PIN R17 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[6]}];
+set_property -dict {PACKAGE_PIN W18 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[5]}];
+set_property -dict {PACKAGE_PIN W19 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[4]}];
+set_property -dict {PACKAGE_PIN V17 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[3]}];
+set_property -dict {PACKAGE_PIN V18 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[2]}];
+set_property -dict {PACKAGE_PIN Y18 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[1]}];
+set_property -dict {PACKAGE_PIN Y19 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[0]}];
+set_property -dict {PACKAGE_PIN N18 IOSTANDARD LVCMOS18} [get_ports tx_clk_out];
+set_property -dict {PACKAGE_PIN V16 IOSTANDARD LVCMOS18} [get_ports tx_frame_out];
+set_property -dict {PACKAGE_PIN V15 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[11]}];
+set_property -dict {PACKAGE_PIN W15 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[10]}];
+set_property -dict {PACKAGE_PIN T12 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[9]}];
+set_property -dict {PACKAGE_PIN U12 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[8]}];
+set_property -dict {PACKAGE_PIN V12 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[7]}];
+set_property -dict {PACKAGE_PIN W13 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[6]}];
+set_property -dict {PACKAGE_PIN U14 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[5]}];
+set_property -dict {PACKAGE_PIN U15 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[4]}];
+set_property -dict {PACKAGE_PIN U18 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[3]}];
+set_property -dict {PACKAGE_PIN U19 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[2]}];
+set_property -dict {PACKAGE_PIN T16 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[1]}];
+set_property -dict {PACKAGE_PIN U17 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[0]}];
+
+set_property -dict {PACKAGE_PIN Y9 IOSTANDARD LVCMOS33} [get_ports {GPIOB[7]}];
+set_property -dict {PACKAGE_PIN Y6 IOSTANDARD LVCMOS33} [get_ports {GPIOB[6]}];
+set_property -dict {PACKAGE_PIN Y7 IOSTANDARD LVCMOS33} [get_ports {GPIOB[5]}];
+set_property -dict {PACKAGE_PIN U10 IOSTANDARD LVCMOS33} [get_ports {GPIOB[4]}];
+set_property -dict {PACKAGE_PIN T9 IOSTANDARD LVCMOS33} [get_ports {GPIOB[3]}];
+set_property -dict {PACKAGE_PIN V7 IOSTANDARD LVCMOS33} [get_ports {GPIOB[2]}];
+set_property -dict {PACKAGE_PIN U7 IOSTANDARD LVCMOS33} [get_ports {GPIOB[1]}];
+set_property -dict {PACKAGE_PIN V5 IOSTANDARD LVCMOS33} [get_ports {GPIOB[0]}];
+
+
+create_clock -name rx_clk -period  16.27 [get_ports rx_clk_in];
+
+create_clock -name clk_fpga_0 -period 10 [get_pins "i_system_wrapper/system_i/sys_ps7/inst/PS7_i/FCLKCLK[0]"];
+create_clock -name clk_fpga_1 -period  5 [get_pins "i_system_wrapper/system_i/sys_ps7/inst/PS7_i/FCLKCLK[1]"];
+
+create_clock -name spi0_clk      -period 40   [get_pins -hier */EMIOSPI0SCLKO];
+
+set_input_jitter clk_fpga_0 0.3;
+set_input_jitter clk_fpga_1 0.15;
+
+
+set_false_path -from [get_pins {i_system_wrapper/system_i/axi_ad9361/inst/i_rx/i_up_adc_common/up_adc_gpio_out_int_reg[0]/C}];
+set_false_path -from [get_pins {i_system_wrapper/system_i/axi_ad9361/inst/i_tx/i_up_dac_common/up_dac_gpio_out_int_reg[0]/C}];
+
diff --git a/projects/e200/system_project.tcl b/projects/e200/system_project.tcl
new file mode 100644
index 000000000..c21f79785
--- /dev/null
+++ b/projects/e200/system_project.tcl
@@ -0,0 +1,16 @@
+source ../../scripts/adi_env.tcl
+source $ad_hdl_dir/projects/scripts/adi_project_xilinx.tcl
+source $ad_hdl_dir/projects/scripts/adi_board.tcl
+
+adi_project_create e200 0 {} "xc7z020clg400-2"
+
+adi_project_files e200 [list \
+  "system_top.v" \
+  "system_constr.xdc" \
+  "$ad_hdl_dir/library/common/ad_iobuf.v"]
+
+
+set_property is_enabled false [get_files  *system_sys_ps7_0.xdc]
+adi_project_run e200
+source $ad_hdl_dir/library/axi_ad9361/axi_ad9361_delay.tcl
+
diff --git a/projects/e200/system_top.v b/projects/e200/system_top.v
new file mode 100644
index 000000000..0416399e4
--- /dev/null
+++ b/projects/e200/system_top.v
@@ -0,0 +1,251 @@
+// ***************************************************************************
+// ***************************************************************************
+// Copyright (C) 2014-2023 Analog Devices, Inc. All rights reserved.
+//
+// In this HDL repository, there are many different and unique modules, consisting
+// of various HDL (Verilog or VHDL) components. The individual modules are
+// developed independently, and may be accompanied by separate and unique license
+// terms.
+//
+// The user should read each of these license terms, and understand the
+// freedoms and responsibilities that he or she has by using this source/core.
+//
+// This core is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+// A PARTICULAR PURPOSE.
+//
+// Redistribution and use of source or resulting binaries, with or without modification
+// of this file, are permitted under one of the following two license terms:
+//
+//   1. The GNU General Public License version 2 as published by the
+//      Free Software Foundation, which can be found in the top level directory
+//      of this repository (LICENSE_GPL2), and also online at:
+//      <https://www.gnu.org/licenses/old-licenses/gpl-2.0.html>
+//
+// OR
+//
+//   2. An ADI specific BSD license, which can be found in the top level directory
+//      of this repository (LICENSE_ADIBSD), and also on-line at:
+//      https://github.com/analogdevicesinc/hdl/blob/master/LICENSE_ADIBSD
+//      This will allow to generate bit files and not release the source code,
+//      as long as it attaches to an ADI device.
+//
+// ***************************************************************************
+// ***************************************************************************
+
+`timescale 1ns/100ps
+
+module system_top (
+  output          MDIO_PHY_mdc,
+  inout           MDIO_PHY_mdio_io,
+  input [3:0]     RGMII_rd,
+  input           RGMII_rx_ctl,
+  input           RGMII_rxc,
+  output [3:0]    RGMII_td,
+  output          RGMII_tx_ctl,
+  output          RGMII_txc,
+  output          eth_rst_n ,
+
+  inout   [14:0]  ddr_addr,
+  inout   [ 2:0]  ddr_ba,
+  inout           ddr_cas_n,
+  inout           ddr_ck_n,
+  inout           ddr_ck_p,
+  inout           ddr_cke,
+  inout           ddr_cs_n,
+  inout   [ 1:0]  ddr_dm,
+  inout   [31:0]  ddr_dq,
+  inout   [ 1:0]  ddr_dqs_n,
+  inout   [ 1:0]  ddr_dqs_p,
+  inout           ddr_odt,
+  inout           ddr_ras_n,
+  inout           ddr_reset_n,
+  inout           ddr_we_n,
+
+  inout           fixed_io_ddr_vrn,
+  inout           fixed_io_ddr_vrp,
+  inout   [31:0]  fixed_io_mio,
+  inout           fixed_io_ps_clk,
+  inout           fixed_io_ps_porb,
+  inout           fixed_io_ps_srstb,
+
+  input           rx_clk_in,
+  input           rx_frame_in,
+  input   [11:0]  rx_data_in,
+  output          tx_clk_out,
+  output          tx_frame_out,
+  output  [11:0]  tx_data_out,
+
+  output          enable,
+  output          txnrx,
+  
+  inout           gpio_resetb,
+  inout           gpio_en_agc,
+  inout   [ 3:0]  gpio_ctl,
+  inout   [ 7:0]  gpio_status,
+
+  output          spi_csn,
+  output          spi_clk,
+  output          spi_mosi,
+  input           spi_miso,
+
+  
+  // clock form vctcxo
+  input  wire	 			      CLK_40MHz_FPGA  ,
+  // PPS or 10 MHz (need to choose from SW)
+  input  wire             PPS_IN          ,
+  input  wire             CLKIN_10MHz     ,
+  output wire             CLKIN_10MHz_REQ ,
+
+  // Clock disciplining / AD5662 controls
+  output wire             CLK_40M_DAC_nSYNC,
+  output wire             CLK_40M_DAC_SCLK ,
+  output wire             CLK_40M_DAC_DIN ,
+
+  output                  tx_amp_en,
+
+  inout   [7:0]           GPIOB
+);
+
+  // internal signals
+
+  wire    [63:0]  gpio_i;
+  wire    [63:0]  gpio_o;
+  wire    [63:0]  gpio_t;
+
+  wire            iic_scl;
+  wire            iic_sda;
+  wire            phaser_enable;
+  wire            pl_burst;
+  wire            pl_muxout;
+  wire            pl_spi_clk_o;
+  wire            pl_spi_miso;
+  wire            pl_spi_mosi;
+  wire            pl_txdata;
+
+  // instantiations
+
+  ad_iobuf #(
+    .DATA_WIDTH(14)
+  ) i_iobuf (
+    .dio_t (gpio_t[13:0]),
+    .dio_i (gpio_o[13:0]),
+    .dio_o (gpio_i[13:0]),
+    .dio_p ({ gpio_resetb,        // 13:13
+              gpio_en_agc,        // 12:12
+              gpio_ctl,           // 11: 8
+              gpio_status}));     //  7: 0
+
+  assign gpio_i[16:14] = gpio_o[16:14];
+
+  ad_iobuf #(.DATA_WIDTH(8)) gpio_io_buf (
+    .dio_t (gpio_t[42:35]),
+    .dio_i (gpio_o[42:35]),
+    .dio_o (gpio_i[42:35]),
+    .dio_p (GPIOB       )
+    );
+
+  assign gpio_i[17] = pl_muxout;
+  assign phaser_enable = gpio_o[14];
+
+
+  //PL_GPIO2
+  ad_iobuf #(
+    .DATA_WIDTH(1)
+  ) i_pl_gpio_iobuf (
+    .dio_t (phaser_enable),
+    .dio_i (pl_spi_clk_o),
+    .dio_o (pl_muxout),
+    .dio_p (pl_gpio2));
+
+  //PL_GPIO1
+  // assign pl_spi_miso = pl_gpio1 & ~phaser_enable;
+  // assign pl_burst    = pl_gpio1 &  phaser_enable;
+
+  //PL_GPIO0
+  assign pl_gpio0 = phaser_enable ? pl_txdata : pl_spi_mosi;
+
+  assign CLKIN_10MHz_REQ = 1'b1;
+  assign eth_rst_n = 1'b1;
+  assign tx_amp_en = 1'b1;
+
+  system_wrapper i_system_wrapper (
+    .CLKIN_10MHz(CLKIN_10MHz),
+    .CLK_40MHz_FPGA(CLK_40MHz_FPGA),
+    .CLK_40M_DAC_DIN(CLK_40M_DAC_DIN),
+    .CLK_40M_DAC_SCLK(CLK_40M_DAC_SCLK),
+    .CLK_40M_DAC_nSYNC(CLK_40M_DAC_nSYNC),
+    .PPS_GPS(1'b0),
+    .PPS_IN(PPS_IN),
+    .PPS_LED(),
+    .PPS_LOCKED(),
+    .REF_10M_LOCKED(),
+    .MDIO_PHY_mdc(MDIO_PHY_mdc),
+    .MDIO_PHY_mdio_io(MDIO_PHY_mdio_io),
+    .RGMII_rd(RGMII_rd),
+    .RGMII_rx_ctl(RGMII_rx_ctl),
+    .RGMII_rxc(RGMII_rxc),
+    .RGMII_td(RGMII_td),
+    .RGMII_tx_ctl(RGMII_tx_ctl),
+    .RGMII_txc(RGMII_txc),
+    .eth_rst_n(),
+    .ddr_addr (ddr_addr),
+    .ddr_ba (ddr_ba),
+    .ddr_cas_n (ddr_cas_n),
+    .ddr_ck_n (ddr_ck_n),
+    .ddr_ck_p (ddr_ck_p),
+    .ddr_cke (ddr_cke),
+    .ddr_cs_n (ddr_cs_n),
+    .ddr_dm (ddr_dm),
+    .ddr_dq (ddr_dq),
+    .ddr_dqs_n (ddr_dqs_n),
+    .ddr_dqs_p (ddr_dqs_p),
+    .ddr_odt (ddr_odt),
+    .ddr_ras_n (ddr_ras_n),
+    .ddr_reset_n (ddr_reset_n),
+    .ddr_we_n (ddr_we_n),
+    .enable (enable),
+    .fixed_io_ddr_vrn (fixed_io_ddr_vrn),
+    .fixed_io_ddr_vrp (fixed_io_ddr_vrp),
+    .fixed_io_mio (fixed_io_mio),
+    .fixed_io_ps_clk (fixed_io_ps_clk),
+    .fixed_io_ps_porb (fixed_io_ps_porb),
+    .fixed_io_ps_srstb (fixed_io_ps_srstb),
+    .gpio_i (gpio_i),
+    .gpio_o (gpio_o),
+    .gpio_t (gpio_t),
+    // .iic_main_scl_io (iic_scl),
+    // .iic_main_sda_io (iic_sda),
+    .rx_clk_in (rx_clk_in),
+    .rx_data_in (rx_data_in),
+    .rx_frame_in (rx_frame_in),
+
+    .spi0_clk_i (1'b0),
+    .spi0_clk_o (spi_clk),
+    .spi0_csn_0_o (spi_csn),
+    .spi0_csn_1_o (),
+    .spi0_csn_2_o (),
+    .spi0_csn_i (1'b1),
+    .spi0_sdi_i (spi_miso),
+    .spi0_sdo_i (1'b0),
+    .spi0_sdo_o (spi_mosi),
+
+    // .spi_clk_i(1'b0),
+    // .spi_clk_o(pl_spi_clk_o),
+    // .spi_csn_i(1'b1),
+    // .spi_csn_o(),
+    // .spi_sdi_i(pl_spi_miso),
+    // .spi_sdo_i(1'b0),
+    // .spi_sdo_o(pl_spi_mosi),
+
+    .tdd_ext_sync(pl_burst),
+    .txdata_o(pl_txdata),
+
+    .tx_clk_out (tx_clk_out),
+    .tx_data_out (tx_data_out),
+    .tx_frame_out (tx_frame_out),
+    .txnrx (txnrx),
+    .up_enable (gpio_o[15]),
+    .up_txnrx (gpio_o[16]));
+
+endmodule
diff --git a/projects/e310v2/Makefile b/projects/e310v2/Makefile
new file mode 100644
index 000000000..8e5455c2d
--- /dev/null
+++ b/projects/e310v2/Makefile
@@ -0,0 +1,25 @@
+####################################################################################
+## Copyright (c) 2018 - 2023 Analog Devices, Inc.
+### SPDX short identifier: BSD-1-Clause
+## Auto-generated, do not modify!
+####################################################################################
+
+PROJECT_NAME := e310v2
+
+M_DEPS += ../common/xilinx/adi_fir_filter_constr.xdc
+M_DEPS += ../common/xilinx/adi_fir_filter_bd.tcl
+M_DEPS += ../../library/util_cdc/sync_bits.v
+M_DEPS += ../../library/common/util_pulse_gen.v
+M_DEPS += ../../library/common/ad_iobuf.v
+M_DEPS += ../../library/common/ad_bus_mux.v
+M_DEPS += ../../library/axi_tdd/scripts/axi_tdd.tcl
+M_DEPS += ../../library/axi_ad9361/axi_ad9361_delay.tcl
+
+LIB_DEPS += axi_ad9361
+LIB_DEPS += axi_dmac
+LIB_DEPS += axi_tdd
+LIB_DEPS += util_pack/util_cpack2
+LIB_DEPS += util_pack/util_upack2
+
+
+include ../scripts/project-xilinx.mk
diff --git a/projects/e310v2/system_bd.tcl b/projects/e310v2/system_bd.tcl
new file mode 100644
index 000000000..56d4632bc
--- /dev/null
+++ b/projects/e310v2/system_bd.tcl
@@ -0,0 +1,408 @@
+# create board design
+
+source $ad_hdl_dir/projects/common/xilinx/adi_fir_filter_bd.tcl
+source $ad_hdl_dir/library/axi_tdd/scripts/axi_tdd.tcl
+set_property  ip_repo_paths  { ../../library/} [current_project]
+update_ip_catalog
+
+# default ports
+
+create_bd_intf_port -mode Master -vlnv xilinx.com:interface:ddrx_rtl:1.0 ddr
+create_bd_intf_port -mode Master -vlnv xilinx.com:display_processing_system7:fixedio_rtl:1.0 fixed_io
+
+create_bd_intf_port -mode Master -vlnv xilinx.com:interface:mdio_rtl:1.0 MDIO_PHY
+create_bd_intf_port -mode Master -vlnv xilinx.com:interface:rgmii_rtl:1.0 RGMII
+create_bd_intf_port -mode Master -vlnv xilinx.com:interface:uart_rtl:1.0 uart_gps
+
+create_bd_port -dir O spi0_csn_2_o
+create_bd_port -dir O spi0_csn_1_o
+create_bd_port -dir O spi0_csn_0_o
+create_bd_port -dir I spi0_csn_i
+create_bd_port -dir I spi0_clk_i
+create_bd_port -dir O spi0_clk_o
+create_bd_port -dir I spi0_sdo_i
+create_bd_port -dir O spi0_sdo_o
+create_bd_port -dir I spi0_sdi_i
+
+create_bd_port -dir I -from 63 -to 0 gpio_i
+create_bd_port -dir O -from 63 -to 0 gpio_o
+create_bd_port -dir O -from 63 -to 0 gpio_t
+
+create_bd_port -dir O txdata_o
+create_bd_port -dir I tdd_ext_sync
+
+
+create_bd_port -dir I CLKIN_10MHz
+create_bd_port -dir I CLK_40MHz_FPGA
+create_bd_port -dir O CLK_40M_DAC_DIN
+create_bd_port -dir O CLK_40M_DAC_SCLK
+create_bd_port -dir O CLK_40M_DAC_nSYNC
+create_bd_port -dir I PPS_GPS
+create_bd_port -dir I PPS_IN
+create_bd_port -dir O PPS_LED
+create_bd_port -dir O PPS_LOCKED
+create_bd_port -dir O REF_10M_LOCKED
+
+# instance: sys_ps7
+
+ad_ip_instance processing_system7 sys_ps7
+
+# ps7 settings
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_PRESET_BANK0_VOLTAGE {LVCMOS 3.3V}
+ad_ip_parameter sys_ps7 CONFIG.PCW_PRESET_BANK1_VOLTAGE {LVCMOS 3.3V}
+ad_ip_parameter sys_ps7 CONFIG.PCW_PACKAGE_NAME clg400
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP1 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP2 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_EN_CLK1_PORT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_EN_RST1_PORT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_EN_CLK2_PORT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_EN_RST2_PORT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_FPGA0_PERIPHERAL_FREQMHZ 100.0
+ad_ip_parameter sys_ps7 CONFIG.PCW_FPGA1_PERIPHERAL_FREQMHZ 200.0
+ad_ip_parameter sys_ps7 CONFIG.PCW_FPGA2_PERIPHERAL_FREQMHZ 200.0
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_EMIO_GPIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_EMIO_GPIO_IO 64
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_ENET0_IO "EMIO"
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_GRP_MDIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_GRP_MDIO_IO "EMIO"
+ad_ip_parameter sys_ps7 CONFIG.PCW_SPI1_PERIPHERAL_ENABLE 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_I2C0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_I2C0_I2C0_IO {MIO 10 .. 11}
+ad_ip_parameter sys_ps7 CONFIG.PCW_UART1_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UART1_UART1_IO {MIO 12 .. 13}
+ad_ip_parameter sys_ps7 CONFIG.PCW_UART0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UART0_UART0_IO "EMIO"
+ad_ip_parameter sys_ps7 CONFIG.PCW_I2C1_PERIPHERAL_ENABLE 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_QSPI_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_QSPI_GRP_SINGLE_SS_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_SD0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_SDIO_PERIPHERAL_FREQMHZ 50
+ad_ip_parameter sys_ps7 CONFIG.PCW_SPI0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_SPI0_SPI0_IO EMIO
+ad_ip_parameter sys_ps7 CONFIG.PCW_TTC0_PERIPHERAL_ENABLE 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_FABRIC_INTERRUPT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_USB0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_MIO_GPIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_MIO_GPIO_IO MIO
+ad_ip_parameter sys_ps7 CONFIG.PCW_USB0_RESET_IO {MIO 47}
+ad_ip_parameter sys_ps7 CONFIG.PCW_USB0_RESET_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_IRQ_F2P_INTR 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_IRQ_F2P_MODE REVERSE
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_0_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_9_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_10_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_11_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_48_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_49_PULLUP {disabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_53_PULLUP {enabled}
+
+# DDR MT41K256M16 HA-125 (32M, 16bit, 8banks)
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_PARTNO {MT41J256M16 RE-125}
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_BUS_WIDTH {32 Bit}
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_USE_INTERNAL_VREF 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_TRAIN_WRITE_LEVEL 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_TRAIN_READ_GATE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_TRAIN_DATA_EYE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_DQS_TO_CLK_DELAY_0 0.048
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_DQS_TO_CLK_DELAY_1 0.050
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_BOARD_DELAY0 0.241
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_BOARD_DELAY1 0.240
+
+ad_ip_instance xlconcat sys_concat_intc
+ad_ip_parameter sys_concat_intc CONFIG.NUM_PORTS 16
+
+ad_ip_instance proc_sys_reset sys_rstgen
+ad_ip_parameter sys_rstgen CONFIG.C_EXT_RST_WIDTH 1
+
+# add external ethernet phy
+ad_ip_instance gmii_to_rgmii sys_rgmii
+ad_ip_parameter sys_rgmii CONFIG.SupportLevel Include_Shared_Logic_in_Core
+
+
+
+set axi_vcxo_ctrl [ create_bd_cell -type ip -vlnv user.org:user:axi_vcxo_ctrl:1.0 axi_vcxo_ctrl ]
+ad_connect axi_vcxo_ctrl/CLK_40M_DAC_DIN CLK_40M_DAC_DIN
+ad_connect axi_vcxo_ctrl/CLK_40M_DAC_SCLK CLK_40M_DAC_SCLK
+ad_connect axi_vcxo_ctrl/CLK_40M_DAC_nSYNC CLK_40M_DAC_nSYNC
+ad_connect axi_vcxo_ctrl/CLKIN_10MHz CLKIN_10MHz
+ad_connect axi_vcxo_ctrl/CLK_40MHz_FPGA CLK_40MHz_FPGA
+ad_connect axi_vcxo_ctrl/PPS_GPS PPS_GPS
+ad_connect axi_vcxo_ctrl/PPS_IN PPS_IN
+ad_connect axi_vcxo_ctrl/PPS_LED PPS_LED
+ad_connect axi_vcxo_ctrl/PPS_LOCKED PPS_LOCKED
+ad_connect axi_vcxo_ctrl/REF_10M_LOCKED REF_10M_LOCKED
+
+
+
+
+ad_connect  sys_cpu_clk sys_ps7/FCLK_CLK0
+ad_connect  sys_200m_clk sys_ps7/FCLK_CLK1
+ad_connect  sys_cpu_reset sys_rstgen/peripheral_reset
+ad_connect  sys_cpu_resetn sys_rstgen/peripheral_aresetn
+ad_connect  sys_cpu_clk sys_rstgen/slowest_sync_clk
+ad_connect  sys_rstgen/ext_reset_in sys_ps7/FCLK_RESET0_N
+
+ad_connect  sys_rgmii/tx_reset sys_rstgen/peripheral_reset
+ad_connect  sys_rgmii/rx_reset sys_rstgen/peripheral_reset
+ad_connect  sys_rgmii/clkin sys_ps7/FCLK_CLK1 
+ad_connect  sys_ps7/MDIO_ETHERNET_0 sys_rgmii/MDIO_GEM
+ad_connect  sys_ps7/GMII_ETHERNET_0 sys_rgmii/GMII
+ad_connect  sys_rgmii/MDIO_PHY MDIO_PHY
+ad_connect  sys_rgmii/RGMII RGMII
+
+# interface connections
+
+ad_connect  ddr sys_ps7/DDR
+ad_connect  gpio_i sys_ps7/GPIO_I
+ad_connect  gpio_o sys_ps7/GPIO_O
+ad_connect  gpio_t sys_ps7/GPIO_T
+ad_connect  fixed_io sys_ps7/FIXED_IO
+ad_connect  uart_gps sys_ps7/UART_0 
+
+# ps7 spi connections
+
+ad_connect  spi0_csn_2_o sys_ps7/SPI0_SS2_O
+ad_connect  spi0_csn_1_o sys_ps7/SPI0_SS1_O
+ad_connect  spi0_csn_0_o sys_ps7/SPI0_SS_O
+ad_connect  spi0_csn_i sys_ps7/SPI0_SS_I
+ad_connect  spi0_clk_i sys_ps7/SPI0_SCLK_I
+ad_connect  spi0_clk_o sys_ps7/SPI0_SCLK_O
+ad_connect  spi0_sdo_i sys_ps7/SPI0_MOSI_I
+ad_connect  spi0_sdo_o sys_ps7/SPI0_MOSI_O
+ad_connect  spi0_sdi_i sys_ps7/SPI0_MISO_I
+
+
+# interrupts
+
+ad_connect  sys_concat_intc/dout sys_ps7/IRQ_F2P
+ad_connect  sys_concat_intc/In15 GND
+ad_connect  sys_concat_intc/In14 GND
+ad_connect  sys_concat_intc/In13 GND
+ad_connect  sys_concat_intc/In12 GND
+ad_connect  sys_concat_intc/In11 GND
+ad_connect  sys_concat_intc/In10 GND
+ad_connect  sys_concat_intc/In9 GND
+ad_connect  sys_concat_intc/In8 GND
+ad_connect  sys_concat_intc/In7 GND
+ad_connect  sys_concat_intc/In6 GND
+ad_connect  sys_concat_intc/In5 GND
+ad_connect  sys_concat_intc/In4 GND
+ad_connect  sys_concat_intc/In3 GND
+ad_connect  sys_concat_intc/In2 GND
+ad_connect  sys_concat_intc/In1 GND
+ad_connect  sys_concat_intc/In0 GND
+
+
+# ad9361
+
+create_bd_port -dir I rx_clk_in
+create_bd_port -dir I rx_frame_in
+create_bd_port -dir I -from 11 -to 0 rx_data_in
+
+create_bd_port -dir O tx_clk_out
+create_bd_port -dir O tx_frame_out
+create_bd_port -dir O -from 11 -to 0 tx_data_out
+
+create_bd_port -dir O enable
+create_bd_port -dir O txnrx
+create_bd_port -dir I up_enable
+create_bd_port -dir I up_txnrx
+
+# ad9361 core(s)
+
+ad_ip_instance axi_ad9361 axi_ad9361
+ad_ip_parameter axi_ad9361 CONFIG.ID 0
+ad_ip_parameter axi_ad9361 CONFIG.CMOS_OR_LVDS_N 1
+ad_ip_parameter axi_ad9361 CONFIG.MODE_1R1T 0
+ad_ip_parameter axi_ad9361 CONFIG.ADC_INIT_DELAY 21
+
+ad_ip_instance axi_dmac axi_ad9361_dac_dma
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_TYPE_SRC 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_TYPE_DEST 1
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.CYCLIC 1
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.AXI_SLICE_SRC 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.AXI_SLICE_DEST 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_2D_TRANSFER 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_DATA_WIDTH_DEST 64
+
+ad_add_interpolation_filter "tx_fir_interpolator" 8 2 1 {61.44} {7.68} \
+                             "$ad_hdl_dir/library/util_fir_int/coefile_int.coe"
+ad_ip_instance xlslice interp_slice
+ad_ip_instance util_upack2 tx_upack
+
+ad_ip_instance axi_dmac axi_ad9361_adc_dma
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_TYPE_SRC 2
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_TYPE_DEST 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.CYCLIC 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.SYNC_TRANSFER_START 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.AXI_SLICE_SRC 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.AXI_SLICE_DEST 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_2D_TRANSFER 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_DATA_WIDTH_SRC 64
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.SYNC_TRANSFER_START {true}
+
+ad_add_decimation_filter "rx_fir_decimator" 8 2 1 {61.44} {61.44} \
+                         "$ad_hdl_dir/library/util_fir_int/coefile_int.coe"
+ad_ip_instance xlslice decim_slice
+ad_ip_instance util_cpack2 cpack
+
+# connections
+
+ad_connect  rx_clk_in axi_ad9361/rx_clk_in
+ad_connect  rx_frame_in axi_ad9361/rx_frame_in
+ad_connect  rx_data_in axi_ad9361/rx_data_in
+ad_connect  tx_clk_out axi_ad9361/tx_clk_out
+ad_connect  tx_frame_out axi_ad9361/tx_frame_out
+ad_connect  tx_data_out axi_ad9361/tx_data_out
+ad_connect  enable axi_ad9361/enable
+ad_connect  txnrx axi_ad9361/txnrx
+ad_connect  up_enable axi_ad9361/up_enable
+ad_connect  up_txnrx axi_ad9361/up_txnrx
+
+ad_connect  axi_ad9361/tdd_sync GND
+ad_connect  sys_200m_clk axi_ad9361/delay_clk
+ad_connect  axi_ad9361/l_clk axi_ad9361/clk
+
+ad_connect axi_ad9361/l_clk rx_fir_decimator/aclk
+
+ad_connect axi_ad9361/adc_valid_i0 rx_fir_decimator/valid_in_0
+ad_connect axi_ad9361/adc_enable_i0 rx_fir_decimator/enable_in_0
+ad_connect axi_ad9361/adc_data_i0 rx_fir_decimator/data_in_0
+ad_connect axi_ad9361/adc_valid_q0 rx_fir_decimator/valid_in_1
+ad_connect axi_ad9361/adc_enable_q0 rx_fir_decimator/enable_in_1
+ad_connect axi_ad9361/adc_data_q0 rx_fir_decimator/data_in_1
+
+ad_connect axi_ad9361/l_clk cpack/clk
+ad_connect axi_ad9361/rst cpack/reset
+
+ad_connect axi_ad9361/adc_enable_i1 cpack/enable_2
+ad_connect axi_ad9361/adc_data_i1 cpack/fifo_wr_data_2
+ad_connect axi_ad9361/adc_enable_q1 cpack/enable_3
+ad_connect axi_ad9361/adc_data_q1 cpack/fifo_wr_data_3
+
+ad_connect cpack/enable_0 rx_fir_decimator/enable_out_0
+ad_connect cpack/enable_1 rx_fir_decimator/enable_out_1
+ad_connect cpack/fifo_wr_data_0 rx_fir_decimator/data_out_0
+ad_connect cpack/fifo_wr_data_1 rx_fir_decimator/data_out_1
+ad_connect rx_fir_decimator/valid_out_0 cpack/fifo_wr_en
+
+ad_connect axi_ad9361_adc_dma/fifo_wr cpack/packed_fifo_wr
+ad_connect axi_ad9361/up_adc_gpio_out decim_slice/Din
+ad_connect rx_fir_decimator/active decim_slice/Dout
+
+ad_connect axi_ad9361/l_clk tx_fir_interpolator/aclk
+
+ad_connect axi_ad9361/dac_enable_i0 tx_fir_interpolator/dac_enable_0
+ad_connect axi_ad9361/dac_valid_i0 tx_fir_interpolator/dac_valid_0
+ad_connect axi_ad9361/dac_data_i0 tx_fir_interpolator/data_out_0
+ad_connect axi_ad9361/dac_enable_q0 tx_fir_interpolator/dac_enable_1
+ad_connect axi_ad9361/dac_valid_q0 tx_fir_interpolator/dac_valid_1
+ad_connect axi_ad9361/dac_data_q0 tx_fir_interpolator/data_out_1
+
+ad_connect  axi_ad9361/l_clk tx_upack/clk
+
+ad_connect  tx_upack/fifo_rd_data_0  tx_fir_interpolator/data_in_0
+ad_connect  tx_upack/enable_0  tx_fir_interpolator/enable_out_0
+ad_connect  tx_upack/fifo_rd_data_1  tx_fir_interpolator/data_in_1
+ad_connect  tx_upack/enable_1  tx_fir_interpolator/enable_out_1
+
+ad_connect axi_ad9361/dac_enable_i1 tx_upack/enable_2
+ad_connect axi_ad9361/dac_data_i1 tx_upack/fifo_rd_data_2
+ad_connect axi_ad9361/dac_enable_q1 tx_upack/enable_3
+ad_connect axi_ad9361/dac_data_q1 tx_upack/fifo_rd_data_3
+
+ad_connect tx_upack/s_axis  axi_ad9361_dac_dma/m_axis
+
+ad_ip_instance util_vector_logic logic_or [list \
+  C_OPERATION {or} \
+  C_SIZE 1]
+
+ad_connect  logic_or/Op1  tx_fir_interpolator/valid_out_0
+ad_connect  logic_or/Op2  axi_ad9361/dac_valid_i1
+ad_connect  logic_or/Res  tx_upack/fifo_rd_en
+ad_connect  tx_upack/fifo_rd_underflow axi_ad9361/dac_dunf
+
+ad_connect axi_ad9361/up_dac_gpio_out interp_slice/Din
+ad_connect  tx_fir_interpolator/active interp_slice/Dout
+
+ad_connect  axi_ad9361/l_clk axi_ad9361_adc_dma/fifo_wr_clk
+ad_connect  axi_ad9361/l_clk axi_ad9361_dac_dma/m_axis_aclk
+ad_connect  cpack/fifo_wr_overflow axi_ad9361/adc_dovf
+
+# External TDD
+set TDD_CHANNEL_CNT 3
+set TDD_DEFAULT_POL 0b010
+set TDD_REG_WIDTH 32
+set TDD_BURST_WIDTH 32
+set TDD_SYNC_WIDTH 0
+set TDD_SYNC_INT 0
+set TDD_SYNC_EXT 1
+set TDD_SYNC_EXT_CDC 1
+ad_tdd_gen_create axi_tdd_0 $TDD_CHANNEL_CNT \
+                            $TDD_DEFAULT_POL \
+                            $TDD_REG_WIDTH \
+                            $TDD_BURST_WIDTH \
+                            $TDD_SYNC_WIDTH \
+                            $TDD_SYNC_INT \
+                            $TDD_SYNC_EXT \
+                            $TDD_SYNC_EXT_CDC
+
+ad_ip_instance util_vector_logic logic_inv [list \
+  C_OPERATION {not} \
+  C_SIZE 1]
+
+ad_ip_instance util_vector_logic logic_or_1 [list \
+  C_OPERATION {or} \
+  C_SIZE 1]
+
+ad_connect logic_inv/Op1  axi_ad9361/rst
+ad_connect logic_inv/Res  axi_tdd_0/resetn
+ad_connect axi_ad9361/l_clk axi_tdd_0/clk
+ad_connect axi_tdd_0/sync_in tdd_ext_sync
+ad_connect axi_tdd_0/tdd_channel_0 txdata_o
+ad_connect axi_tdd_0/tdd_channel_1 axi_ad9361_adc_dma/fifo_wr_sync
+
+ad_connect  logic_or_1/Op1  axi_ad9361/rst
+ad_connect  logic_or_1/Op2  axi_tdd_0/tdd_channel_2
+ad_connect  logic_or_1/Res  tx_upack/reset
+
+# interconnects
+
+ad_cpu_interconnect 0x79020000 axi_ad9361
+ad_cpu_interconnect 0x7C400000 axi_ad9361_adc_dma
+ad_cpu_interconnect 0x7C420000 axi_ad9361_dac_dma
+ad_cpu_interconnect 0x7C440000 axi_tdd_0
+ad_cpu_interconnect 0x43C00000 axi_vcxo_ctrl
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP1 {1}
+ad_connect sys_cpu_clk sys_ps7/S_AXI_HP1_ACLK
+ad_connect axi_ad9361_adc_dma/m_dest_axi sys_ps7/S_AXI_HP1
+
+create_bd_addr_seg -range 0x40000000 -offset 0x00000000 \
+                    [get_bd_addr_spaces axi_ad9361_adc_dma/m_dest_axi] \
+                    [get_bd_addr_segs sys_ps7/S_AXI_HP1/HP1_DDR_LOWOCM] \
+                    SEG_sys_ps7_HP1_DDR_LOWOCM
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP2 {1}
+ad_connect sys_cpu_clk sys_ps7/S_AXI_HP2_ACLK
+ad_connect axi_ad9361_dac_dma/m_src_axi sys_ps7/S_AXI_HP2
+
+create_bd_addr_seg -range 0x40000000 -offset 0x00000000 \
+                    [get_bd_addr_spaces axi_ad9361_dac_dma/m_src_axi] \
+                    [get_bd_addr_segs sys_ps7/S_AXI_HP2/HP2_DDR_LOWOCM] \
+                    SEG_sys_ps7_HP2_DDR_LOWOCM
+
+ad_connect sys_cpu_clk axi_ad9361_dac_dma/m_src_axi_aclk
+ad_connect sys_cpu_clk axi_ad9361_adc_dma/m_dest_axi_aclk
+ad_connect sys_cpu_resetn axi_ad9361_adc_dma/m_dest_axi_aresetn
+ad_connect sys_cpu_resetn axi_ad9361_dac_dma/m_src_axi_aresetn
+
+# interrupts
+
+ad_cpu_interrupt ps-13 mb-13 axi_ad9361_adc_dma/irq
+ad_cpu_interrupt ps-12 mb-12 axi_ad9361_dac_dma/irq
+
+
diff --git a/projects/e310v2/system_constr.xdc b/projects/e310v2/system_constr.xdc
new file mode 100644
index 000000000..8e1235df7
--- /dev/null
+++ b/projects/e310v2/system_constr.xdc
@@ -0,0 +1,123 @@
+set_property -dict {PACKAGE_PIN C20 IOSTANDARD LVCMOS18} [get_ports {RGMII_td[3]}];
+set_property -dict {PACKAGE_PIN D19 IOSTANDARD LVCMOS18} [get_ports {RGMII_td[2]}];
+set_property -dict {PACKAGE_PIN D20 IOSTANDARD LVCMOS18} [get_ports {RGMII_td[1]}];
+set_property -dict {PACKAGE_PIN F19 IOSTANDARD LVCMOS18} [get_ports {RGMII_td[0]}];
+set_property -dict {PACKAGE_PIN E18 IOSTANDARD LVCMOS18} [get_ports {RGMII_rd[3]}];
+set_property -dict {PACKAGE_PIN E19 IOSTANDARD LVCMOS18} [get_ports {RGMII_rd[2]}];
+set_property -dict {PACKAGE_PIN E17 IOSTANDARD LVCMOS18} [get_ports {RGMII_rd[1]}];
+set_property -dict {PACKAGE_PIN F16 IOSTANDARD LVCMOS18} [get_ports {RGMII_rd[0]}];
+
+set_property -dict {PACKAGE_PIN F20 IOSTANDARD LVCMOS18} [get_ports RGMII_tx_ctl];
+set_property -dict {PACKAGE_PIN D18 IOSTANDARD LVCMOS18} [get_ports RGMII_txc];
+set_property -dict {PACKAGE_PIN G17 IOSTANDARD LVCMOS18} [get_ports RGMII_rx_ctl];
+set_property -dict {PACKAGE_PIN H16 IOSTANDARD LVCMOS18} [get_ports RGMII_rxc];
+set_property -dict {PACKAGE_PIN B19 IOSTANDARD LVCMOS18} [get_ports eth_rst_n];
+set_property -dict {PACKAGE_PIN A20 IOSTANDARD LVCMOS18} [get_ports MDIO_PHY_mdio_io];
+set_property -dict {PACKAGE_PIN B20 IOSTANDARD LVCMOS18} [get_ports MDIO_PHY_mdc];
+
+create_clock -period 8.000 [get_ports RGMII_rxc];
+
+set_property -dict {PACKAGE_PIN V13 IOSTANDARD LVCMOS18} [get_ports {gpio_status[7]}];
+set_property -dict {PACKAGE_PIN U13 IOSTANDARD LVCMOS18} [get_ports {gpio_status[6]}];
+set_property -dict {PACKAGE_PIN T20 IOSTANDARD LVCMOS18} [get_ports {gpio_status[5]}];
+set_property -dict {PACKAGE_PIN T19 IOSTANDARD LVCMOS18} [get_ports {gpio_status[4]}];
+set_property -dict {PACKAGE_PIN T17 IOSTANDARD LVCMOS18} [get_ports {gpio_status[3]}];
+set_property -dict {PACKAGE_PIN T15 IOSTANDARD LVCMOS18} [get_ports {gpio_status[2]}];
+set_property -dict {PACKAGE_PIN T14 IOSTANDARD LVCMOS18} [get_ports {gpio_status[1]}];
+set_property -dict {PACKAGE_PIN T11 IOSTANDARD LVCMOS18} [get_ports {gpio_status[0]}];
+set_property -dict {PACKAGE_PIN M20 IOSTANDARD LVCMOS18} [get_ports {gpio_ctl[3]}];
+set_property -dict {PACKAGE_PIN M19 IOSTANDARD LVCMOS18} [get_ports {gpio_ctl[2]}];
+set_property -dict {PACKAGE_PIN F17 IOSTANDARD LVCMOS18} [get_ports {gpio_ctl[1]}];
+set_property -dict {PACKAGE_PIN T10 IOSTANDARD LVCMOS18} [get_ports {gpio_ctl[0]}];
+set_property -dict {PACKAGE_PIN P16 IOSTANDARD LVCMOS18} [get_ports gpio_en_agc];
+set_property -dict {PACKAGE_PIN N17 IOSTANDARD LVCMOS18} [get_ports gpio_resetb];
+set_property -dict {PACKAGE_PIN R18 IOSTANDARD LVCMOS18} [get_ports enable];
+set_property -dict {PACKAGE_PIN P14 IOSTANDARD LVCMOS18} [get_ports txnrx];
+
+set_property PACKAGE_PIN P18 [get_ports spi_csn];
+set_property IOSTANDARD LVCMOS18 [get_ports spi_csn];
+set_property PULLUP true [get_ports spi_csn];
+set_property -dict {PACKAGE_PIN R14 IOSTANDARD LVCMOS18} [get_ports spi_clk];
+set_property -dict {PACKAGE_PIN P15 IOSTANDARD LVCMOS18} [get_ports spi_mosi];
+set_property -dict {PACKAGE_PIN R19 IOSTANDARD LVCMOS18} [get_ports spi_miso];
+
+
+
+set_property -dict {PACKAGE_PIN N18 IOSTANDARD LVCMOS18} [get_ports rx_clk_in];
+# set_property  -dict {PACKAGE_PIN  P19  IOSTANDARD LVCMOS18 }     [get_ports rx_clk_in_n]       ;;
+set_property -dict {PACKAGE_PIN N20 IOSTANDARD LVCMOS18} [get_ports rx_frame_in];
+set_property -dict {PACKAGE_PIN W18 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[11]}];
+set_property -dict {PACKAGE_PIN W19 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[10]}];
+set_property -dict {PACKAGE_PIN Y18 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[9]}];
+set_property -dict {PACKAGE_PIN Y19 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[8]}];
+set_property -dict {PACKAGE_PIN V20 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[7]}];
+set_property -dict {PACKAGE_PIN W20 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[6]}];
+set_property -dict {PACKAGE_PIN V17 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[5]}];
+set_property -dict {PACKAGE_PIN V18 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[4]}];
+set_property -dict {PACKAGE_PIN T16 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[3]}];
+set_property -dict {PACKAGE_PIN U17 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[2]}];
+set_property -dict {PACKAGE_PIN V15 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[1]}];
+set_property -dict {PACKAGE_PIN W15 IOSTANDARD LVCMOS18} [get_ports {rx_data_in[0]}];
+
+set_property -dict {PACKAGE_PIN Y16 IOSTANDARD LVCMOS18} [get_ports tx_clk_out];
+set_property -dict {PACKAGE_PIN W14 IOSTANDARD LVCMOS18} [get_ports tx_frame_out];
+set_property -dict {PACKAGE_PIN U14 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[11]}];
+set_property -dict {PACKAGE_PIN U15 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[10]}];
+set_property -dict {PACKAGE_PIN R16 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[9]}];
+set_property -dict {PACKAGE_PIN R17 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[8]}];
+set_property -dict {PACKAGE_PIN V16 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[7]}];
+set_property -dict {PACKAGE_PIN W16 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[6]}];
+set_property -dict {PACKAGE_PIN V12 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[5]}];
+set_property -dict {PACKAGE_PIN W13 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[4]}];
+set_property -dict {PACKAGE_PIN U18 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[3]}];
+set_property -dict {PACKAGE_PIN U19 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[2]}];
+set_property -dict {PACKAGE_PIN T12 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[1]}];
+set_property -dict {PACKAGE_PIN U12 IOSTANDARD LVCMOS18} [get_ports {tx_data_out[0]}];
+
+
+set_property -dict {PACKAGE_PIN T9 IOSTANDARD LVCMOS33} [get_ports CLK_40M_DAC_nSYNC];
+set_property -dict {PACKAGE_PIN V5 IOSTANDARD LVCMOS33} [get_ports CLK_40M_DAC_SCLK];
+set_property -dict {PACKAGE_PIN U10 IOSTANDARD LVCMOS33} [get_ports CLK_40M_DAC_DIN];
+
+
+
+set_property -dict {PACKAGE_PIN U9 IOSTANDARD LVCMOS33} [get_ports PPS_GPS];
+set_property -dict {PACKAGE_PIN W8 IOSTANDARD LVCMOS33} [get_ports GPS_RSTN];
+set_property -dict {PACKAGE_PIN W9 IOSTANDARD LVCMOS33} [get_ports GPS_PWEN];
+set_property -dict {PACKAGE_PIN T5 IOSTANDARD LVCMOS33} [get_ports FE_RX1_SEL1];
+set_property -dict {PACKAGE_PIN Y12 IOSTANDARD LVCMOS33} [get_ports FE_RX2_SEL1];
+set_property -dict {PACKAGE_PIN V11 IOSTANDARD LVCMOS33} [get_ports FE_TXRX1_SEL1];
+set_property -dict {PACKAGE_PIN V6 IOSTANDARD LVCMOS33} [get_ports FE_TXRX2_SEL1];
+set_property -dict {PACKAGE_PIN W11 IOSTANDARD LVCMOS33} [get_ports TX1_AMP_EN];
+set_property -dict {PACKAGE_PIN Y11 IOSTANDARD LVCMOS33} [get_ports TX2_AMP_EN];
+set_property -dict {PACKAGE_PIN Y13 IOSTANDARD LVCMOS33} [get_ports uart_gps_rxd];
+set_property -dict {PACKAGE_PIN W10 IOSTANDARD LVCMOS33} [get_ports uart_gps_txd];
+
+set_property -dict {PACKAGE_PIN L16 IOSTANDARD LVCMOS18} [get_ports CLK_40MHz_FPGA];
+set_property -dict {PACKAGE_PIN J18 IOSTANDARD LVCMOS18} [get_ports CLKIN_10MHz];
+set_property -dict {PACKAGE_PIN Y7 IOSTANDARD LVCMOS33} [get_ports PPS_IN];
+set_property -dict {PACKAGE_PIN Y8 IOSTANDARD LVCMOS33} [get_ports PPS_LED];
+set_property -dict {PACKAGE_PIN Y6 IOSTANDARD LVCMOS33} [get_ports PPS_LOCKED];
+set_property -dict {PACKAGE_PIN Y9 IOSTANDARD LVCMOS33} [get_ports REF_10M_LOCKED];
+# TX_AMP_EN	    G15;
+# FPGA_GCLK1	K17;
+# EEPROM_I2C_SDA	C6;
+# EEPROM_I2C_SCL	E9;
+
+
+
+create_clock -period 16.270 -name rx_clk [get_ports rx_clk_in];
+create_clock -period 10.000 -name clk_fpga_0 [get_pins {i_system_wrapper/system_i/sys_ps7/inst/PS7_i/FCLKCLK[0]}];
+create_clock -period 5.000 -name clk_fpga_1 [get_pins {i_system_wrapper/system_i/sys_ps7/inst/PS7_i/FCLKCLK[1]}];
+
+create_clock -period 40.000 -name spi0_clk [get_pins -hier */EMIOSPI0SCLKO];
+
+set_input_jitter clk_fpga_0 0.300;
+set_input_jitter clk_fpga_1 0.150;
+
+
+
+
+
+set_false_path -from [get_clocks clk_fpga_0] -to [get_clocks rx_clk];
+set_false_path -from [get_clocks rx_clk] -to [get_clocks clk_fpga_0];
diff --git a/projects/e310v2/system_project.tcl b/projects/e310v2/system_project.tcl
new file mode 100644
index 000000000..0a7b98378
--- /dev/null
+++ b/projects/e310v2/system_project.tcl
@@ -0,0 +1,16 @@
+source ../../scripts/adi_env.tcl
+source $ad_hdl_dir/projects/scripts/adi_project_xilinx.tcl
+source $ad_hdl_dir/projects/scripts/adi_board.tcl
+
+adi_project_create e310v2 0 {} "xc7z020clg400-2"
+
+adi_project_files e310v2 [list \
+  "system_top.v" \
+  "system_constr.xdc" \
+  "$ad_hdl_dir/library/common/ad_iobuf.v"]
+
+
+set_property is_enabled false [get_files  *system_sys_ps7_0.xdc]
+adi_project_run e310v2
+source $ad_hdl_dir/library/axi_ad9361/axi_ad9361_delay.tcl
+
diff --git a/projects/e310v2/system_top.v b/projects/e310v2/system_top.v
new file mode 100644
index 000000000..67072969d
--- /dev/null
+++ b/projects/e310v2/system_top.v
@@ -0,0 +1,272 @@
+// ***************************************************************************
+// ***************************************************************************
+// Copyright (C) 2014-2023 Analog Devices, Inc. All rights reserved.
+//
+// In this HDL repository, there are many different and unique modules, consisting
+// of various HDL (Verilog or VHDL) components. The individual modules are
+// developed independently, and may be accompanied by separate and unique license
+// terms.
+//
+// The user should read each of these license terms, and understand the
+// freedoms and responsibilities that he or she has by using this source/core.
+//
+// This core is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+// A PARTICULAR PURPOSE.
+//
+// Redistribution and use of source or resulting binaries, with or without modification
+// of this file, are permitted under one of the following two license terms:
+//
+//   1. The GNU General Public License version 2 as published by the
+//      Free Software Foundation, which can be found in the top level directory
+//      of this repository (LICENSE_GPL2), and also online at:
+//      <https://www.gnu.org/licenses/old-licenses/gpl-2.0.html>
+//
+// OR
+//
+//   2. An ADI specific BSD license, which can be found in the top level directory
+//      of this repository (LICENSE_ADIBSD), and also on-line at:
+//      https://github.com/analogdevicesinc/hdl/blob/master/LICENSE_ADIBSD
+//      This will allow to generate bit files and not release the source code,
+//      as long as it attaches to an ADI device.
+//
+// ***************************************************************************
+// ***************************************************************************
+
+`timescale 1ns/100ps
+
+module system_top (
+  output          MDIO_PHY_mdc,
+  inout           MDIO_PHY_mdio_io,
+  input [3:0]     RGMII_rd,
+  input           RGMII_rx_ctl,
+  input           RGMII_rxc,
+  output [3:0]    RGMII_td,
+  output          RGMII_tx_ctl,
+  output          RGMII_txc,
+  output          eth_rst_n ,
+
+  inout   [14:0]  ddr_addr,
+  inout   [ 2:0]  ddr_ba,
+  inout           ddr_cas_n,
+  inout           ddr_ck_n,
+  inout           ddr_ck_p,
+  inout           ddr_cke,
+  inout           ddr_cs_n,
+  inout   [ 3:0]  ddr_dm,
+  inout   [31:0]  ddr_dq,
+  inout   [ 3:0]  ddr_dqs_n,
+  inout   [ 3:0]  ddr_dqs_p,
+  inout           ddr_odt,
+  inout           ddr_ras_n,
+  inout           ddr_reset_n,
+  inout           ddr_we_n,
+
+  inout           fixed_io_ddr_vrn,
+  inout           fixed_io_ddr_vrp,
+  inout   [53:0]  fixed_io_mio,
+  inout           fixed_io_ps_clk,
+  inout           fixed_io_ps_porb,
+  inout           fixed_io_ps_srstb,
+
+  input           uart_gps_rxd,
+  output          uart_gps_txd,
+
+  input           rx_clk_in,
+  input           rx_frame_in,
+  input   [11:0]  rx_data_in,
+  output          tx_clk_out,
+  output          tx_frame_out,
+  output  [11:0]  tx_data_out,
+
+  output          enable,
+  output          txnrx,
+  
+  inout           gpio_resetb,
+  inout           gpio_en_agc,
+  inout   [ 3:0]  gpio_ctl,
+  inout   [ 7:0]  gpio_status,
+
+  output          spi_csn,
+  output          spi_clk,
+  output          spi_mosi,
+  input           spi_miso,
+
+  
+  // clock form vctcxo
+  input  wire	 			      CLK_40MHz_FPGA  ,
+  // PPS or 10 MHz (need to choose from SW)
+  input  wire             PPS_IN          ,
+  input  wire             CLKIN_10MHz     ,
+  // output wire             CLKIN_10MHz_REQ ,
+  input  wire             PPS_GPS         ,
+  output wire             PPS_LED         ,
+  output wire             PPS_LOCKED      ,
+  output wire             REF_10M_LOCKED  ,
+
+// GPS
+  output wire             GPS_RSTN        ,
+  output wire             GPS_PWEN        ,
+
+
+  // Clock disciplining / AD5662 controls
+  output wire             CLK_40M_DAC_nSYNC,
+  output wire             CLK_40M_DAC_SCLK ,
+  output wire             CLK_40M_DAC_DIN ,
+
+  
+  output wire             FE_TXRX2_SEL1 ,
+  output wire             FE_TXRX1_SEL1 ,
+  output wire             FE_RX2_SEL1 ,
+  output wire             FE_RX1_SEL1 ,
+
+  output wire             TX1_AMP_EN,
+  output wire             TX2_AMP_EN
+);
+
+  // internal signals
+
+  wire    [63:0]  gpio_i;
+  wire    [63:0]  gpio_o;
+  wire    [63:0]  gpio_t;
+
+  wire            iic_scl;
+  wire            iic_sda;
+  wire            phaser_enable;
+  wire            pl_burst;
+  wire            pl_muxout;
+  wire            pl_spi_clk_o;
+  wire            pl_spi_miso;
+  wire            pl_spi_mosi;
+  wire            pl_txdata;
+
+  // instantiations
+
+  ad_iobuf #(
+    .DATA_WIDTH(14)
+  ) i_iobuf (
+    .dio_t (gpio_t[13:0]),
+    .dio_i (gpio_o[13:0]),
+    .dio_o (gpio_i[13:0]),
+    .dio_p ({ gpio_resetb,        // 13:13
+              gpio_en_agc,        // 12:12
+              gpio_ctl,           // 11: 8
+              gpio_status}));     //  7: 0
+
+
+
+  ad_iobuf #(.DATA_WIDTH(29)) i_iobuf_gpio (
+    .dio_t (gpio_t[63:35]),
+    .dio_i (gpio_o[63:35]),
+    .dio_o (gpio_i[63:35]),
+    .dio_p (GPIOB )
+    ); 
+
+  assign gpio_i[17] = pl_muxout;
+  assign phaser_enable = gpio_o[14];
+
+
+  //PL_GPIO2
+  ad_iobuf #(
+    .DATA_WIDTH(1)
+  ) i_pl_gpio_iobuf (
+    .dio_t (phaser_enable),
+    .dio_i (pl_spi_clk_o),
+    .dio_o (pl_muxout),
+    .dio_p (pl_gpio2));
+
+  //PL_GPIO1
+  // assign pl_spi_miso = pl_gpio1 & ~phaser_enable;
+  // assign pl_burst    = pl_gpio1 &  phaser_enable;
+
+  //PL_GPIO0
+  assign pl_gpio0 = phaser_enable ? pl_txdata : pl_spi_mosi;
+
+  assign CLKIN_10MHz_REQ = 1'b1;
+  assign eth_rst_n = 1'b1;
+  assign tx_amp_en = 1'b1;
+  
+  
+  
+  system_wrapper i_system_wrapper (
+    .CLKIN_10MHz(CLKIN_10MHz),
+    .CLK_40MHz_FPGA(CLK_40MHz_FPGA),
+    .CLK_40M_DAC_DIN(CLK_40M_DAC_DIN),
+    .CLK_40M_DAC_SCLK(CLK_40M_DAC_SCLK),
+    .CLK_40M_DAC_nSYNC(CLK_40M_DAC_nSYNC),
+    .PPS_GPS(PPS_GPS),
+    .PPS_IN(PPS_IN),
+    .PPS_LED(PPS_LED),
+    .PPS_LOCKED(PPS_LOCKED),
+    .REF_10M_LOCKED(REF_10M_LOCKED),
+    .MDIO_PHY_mdc(MDIO_PHY_mdc),
+    .MDIO_PHY_mdio_io(MDIO_PHY_mdio_io),
+    .RGMII_rd(RGMII_rd),
+    .RGMII_rx_ctl(RGMII_rx_ctl),
+    .RGMII_rxc(RGMII_rxc),
+    .RGMII_td(RGMII_td),
+    .RGMII_tx_ctl(RGMII_tx_ctl),
+    .RGMII_txc(RGMII_txc),
+    .ddr_addr (ddr_addr),
+    .ddr_ba (ddr_ba),
+    .ddr_cas_n (ddr_cas_n),
+    .ddr_ck_n (ddr_ck_n),
+    .ddr_ck_p (ddr_ck_p),
+    .ddr_cke (ddr_cke),
+    .ddr_cs_n (ddr_cs_n),
+    .ddr_dm (ddr_dm),
+    .ddr_dq (ddr_dq),
+    .ddr_dqs_n (ddr_dqs_n),
+    .ddr_dqs_p (ddr_dqs_p),
+    .ddr_odt (ddr_odt),
+    .ddr_ras_n (ddr_ras_n),
+    .ddr_reset_n (ddr_reset_n),
+    .ddr_we_n (ddr_we_n),
+    .enable (enable),
+    .fixed_io_ddr_vrn (fixed_io_ddr_vrn),
+    .fixed_io_ddr_vrp (fixed_io_ddr_vrp),
+    .fixed_io_mio (fixed_io_mio),
+    .fixed_io_ps_clk (fixed_io_ps_clk),
+    .fixed_io_ps_porb (fixed_io_ps_porb),
+    .fixed_io_ps_srstb (fixed_io_ps_srstb),
+    .gpio_i (gpio_i),
+    .gpio_o (gpio_o),
+    .gpio_t (gpio_t),
+    // .iic_main_scl_io (iic_scl),
+    // .iic_main_sda_io (iic_sda),
+    .rx_clk_in (rx_clk_in),
+    .rx_data_in (rx_data_in),
+    .rx_frame_in (rx_frame_in),
+    .uart_gps_rxd(uart_gps_rxd),
+    .uart_gps_txd(uart_gps_txd),
+
+
+    .spi0_clk_i (1'b0),
+    .spi0_clk_o (spi_clk),
+    .spi0_csn_0_o (spi_csn),
+    .spi0_csn_1_o (),
+    .spi0_csn_2_o (),
+    .spi0_csn_i (1'b1),
+    .spi0_sdi_i (spi_miso),
+    .spi0_sdo_i (1'b0),
+    .spi0_sdo_o (spi_mosi),
+
+    // .spi_clk_i(1'b0),
+    // .spi_clk_o(pl_spi_clk_o),
+    // .spi_csn_i(1'b1),
+    // .spi_csn_o(),
+    // .spi_sdi_i(pl_spi_miso),
+    // .spi_sdo_i(1'b0),
+    // .spi_sdo_o(pl_spi_mosi),
+
+    .tdd_ext_sync(pl_burst),
+    .txdata_o(pl_txdata),
+
+    .tx_clk_out (tx_clk_out),
+    .tx_data_out (tx_data_out),
+    .tx_frame_out (tx_frame_out),
+    .txnrx (txnrx),
+    .up_enable (gpio_o[15]),
+    .up_txnrx (gpio_o[16]));
+
+endmodule
-- 
2.42.0

