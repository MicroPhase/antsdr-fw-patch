From e796d9e7f9a10e72775cb84607efa5159c289d60 Mon Sep 17 00:00:00 2001
From: jcc <995586238@qq.com>
Date: Tue, 22 Nov 2022 17:21:02 +0800
Subject: [PATCH] add antsdre200 support hdl

---
 projects/antsdre200/Makefile                  |  21 +
 projects/antsdre200/b205_ref_pll.v            | 279 ++++++
 projects/antsdre200/ip/gen_clks/gen_clks.v    |  96 ++
 projects/antsdre200/ip/gen_clks/gen_clks.xci  | 725 +++++++++++++++
 projects/antsdre200/ip/gen_clks/gen_clks.xdc  |  60 ++
 .../antsdre200/ip/gen_clks/gen_clks_board.xdc |   2 +
 .../antsdre200/ip/gen_clks/gen_clks_clk_wiz.v | 219 +++++
 .../antsdre200/ip/gen_clks/gen_clks_ooc.xdc   |  58 ++
 .../ip/gen_clks/gen_clks_sim_netlist.v        | 260 ++++++
 .../ip/gen_clks/gen_clks_sim_netlist.vhdl     | 205 +++++
 .../antsdre200/ip/gen_clks/gen_clks_stub.v    |  23 +
 .../antsdre200/ip/gen_clks/gen_clks_stub.vhdl |  32 +
 .../ip/gen_clks/mmcm_pll_drp_func_7s_mmcm.vh  | 671 ++++++++++++++
 .../ip/gen_clks/mmcm_pll_drp_func_7s_pll.vh   | 531 +++++++++++
 .../ip/gen_clks/mmcm_pll_drp_func_us_mmcm.vh  | 671 ++++++++++++++
 .../ip/gen_clks/mmcm_pll_drp_func_us_pll.vh   | 530 +++++++++++
 .../mmcm_pll_drp_func_us_plus_mmcm.vh         | 861 ++++++++++++++++++
 .../gen_clks/mmcm_pll_drp_func_us_plus_pll.vh | 536 +++++++++++
 projects/antsdre200/ltc2630_spi.v             | 151 +++
 projects/antsdre200/system_bd.tcl             | 333 +++++++
 projects/antsdre200/system_constr.xdc         | 121 +++
 projects/antsdre200/system_project.tcl        |  20 +
 projects/antsdre200/system_top.v              | 246 +++++
 23 files changed, 6651 insertions(+)
 create mode 100644 projects/antsdre200/Makefile
 create mode 100644 projects/antsdre200/b205_ref_pll.v
 create mode 100644 projects/antsdre200/ip/gen_clks/gen_clks.v
 create mode 100644 projects/antsdre200/ip/gen_clks/gen_clks.xci
 create mode 100644 projects/antsdre200/ip/gen_clks/gen_clks.xdc
 create mode 100644 projects/antsdre200/ip/gen_clks/gen_clks_board.xdc
 create mode 100644 projects/antsdre200/ip/gen_clks/gen_clks_clk_wiz.v
 create mode 100644 projects/antsdre200/ip/gen_clks/gen_clks_ooc.xdc
 create mode 100644 projects/antsdre200/ip/gen_clks/gen_clks_sim_netlist.v
 create mode 100644 projects/antsdre200/ip/gen_clks/gen_clks_sim_netlist.vhdl
 create mode 100644 projects/antsdre200/ip/gen_clks/gen_clks_stub.v
 create mode 100644 projects/antsdre200/ip/gen_clks/gen_clks_stub.vhdl
 create mode 100755 projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_7s_mmcm.vh
 create mode 100755 projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_7s_pll.vh
 create mode 100755 projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_us_mmcm.vh
 create mode 100755 projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_us_pll.vh
 create mode 100755 projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_us_plus_mmcm.vh
 create mode 100755 projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_us_plus_pll.vh
 create mode 100644 projects/antsdre200/ltc2630_spi.v
 create mode 100644 projects/antsdre200/system_bd.tcl
 create mode 100644 projects/antsdre200/system_constr.xdc
 create mode 100644 projects/antsdre200/system_project.tcl
 create mode 100644 projects/antsdre200/system_top.v

diff --git a/projects/antsdre200/Makefile b/projects/antsdre200/Makefile
new file mode 100644
index 000000000..cb65082c8
--- /dev/null
+++ b/projects/antsdre200/Makefile
@@ -0,0 +1,21 @@
+####################################################################################
+## Copyright 2018(c) Analog Devices, Inc.
+## Auto-generated, do not modify!
+####################################################################################
+
+PROJECT_NAME := antsdre200
+
+M_DEPS += ../common/xilinx/adi_fir_filter_constr.xdc
+M_DEPS += ../common/xilinx/adi_fir_filter_bd.tcl
+M_DEPS += ../../library/common/ad_iobuf.v
+M_DEPS += ../../library/util_cdc/sync_bits.v
+M_DEPS += ../../library/common/util_pulse_gen.v
+M_DEPS += ../../library/common/ad_bus_mux.v
+M_DEPS += ../../library/axi_ad9361/axi_ad9361_delay.tcl
+
+LIB_DEPS += axi_ad9361
+LIB_DEPS += axi_dmac
+LIB_DEPS += util_pack/util_cpack2
+LIB_DEPS += util_pack/util_upack2
+
+include ../scripts/project-xilinx.mk
diff --git a/projects/antsdre200/b205_ref_pll.v b/projects/antsdre200/b205_ref_pll.v
new file mode 100644
index 000000000..4771598f9
--- /dev/null
+++ b/projects/antsdre200/b205_ref_pll.v
@@ -0,0 +1,279 @@
+//
+// Copyright 2015 Ettus Research, a National Instruments Company
+//
+// SPDX-License-Identifier: LGPL-3.0-or-later
+//
+
+module b205_ref_pll(
+    input reset,
+    input clk,      // 200 MHz sample clock
+    input refclk,   // 40 MHz reference clock
+    input ref_x ,      // PPS or 10 MHz external reference
+    output reg locked,
+
+    // SPI lines to AD5662
+    output sclk,
+    output mosi,
+    output sync_n
+    );
+
+    // Base parameters
+    localparam SAMPLE_CLOCK_FREQ=200_000_000;
+    localparam REF_FREQ_PPS=1;
+    localparam REF_FREQ_10MHZ=10_000_000;
+    localparam REF_CLK_FREQ=40_000_000;
+    localparam PFD_FREQ_PPS=1;
+    localparam PFD_FREQ_10MHZ=10;
+
+    // Lock detection parameters
+    localparam LOCK_TOLERANCE_PPM=1;
+    localparam LOCK_MARGIN_PPS=(SAMPLE_CLOCK_FREQ/PFD_FREQ_PPS)*LOCK_TOLERANCE_PPM/1_000_000;
+    localparam LOCK_MARGIN_10MHZ=(SAMPLE_CLOCK_FREQ/PFD_FREQ_10MHZ)*LOCK_TOLERANCE_PPM/1_000_000;
+
+    // Reference frequency detection parameters
+    // References are only valid if they are +/-5ppm because that is the range of the VCTXCO
+    localparam REF_PERIOD_PPS=SAMPLE_CLOCK_FREQ/REF_FREQ_PPS;
+    localparam REF_PERIOD_10MHZ=SAMPLE_CLOCK_FREQ/REF_FREQ_10MHZ;
+    localparam REF_PERIOD_PPS_MIN=REF_PERIOD_PPS-(REF_PERIOD_PPS*5/1_000_000)-1;
+    localparam REF_PERIOD_PPS_MAX=REF_PERIOD_PPS+(REF_PERIOD_PPS*5/1_000_000)+1;
+    localparam REF_PERIOD_10MHZ_MIN=REF_PERIOD_10MHZ-(REF_PERIOD_10MHZ*5/1_000_000)-1;
+    localparam REF_PERIOD_10MHZ_MAX=REF_PERIOD_10MHZ+(REF_PERIOD_10MHZ*5/1_000_000)+1;
+
+    // R divider parameters
+    localparam RDIV_PPS=REF_FREQ_PPS/PFD_FREQ_PPS;
+    localparam RDIV_10MHZ=REF_FREQ_10MHZ/PFD_FREQ_10MHZ;
+
+    // N divider parameters (refclk is divided by 2)
+    localparam NDIV_PPS=REF_CLK_FREQ/2/PFD_FREQ_PPS;
+    localparam NDIV_10MHZ=REF_CLK_FREQ/2/PFD_FREQ_10MHZ;
+
+    // PFD parameters
+    localparam PFD_PERIOD_PPS=SAMPLE_CLOCK_FREQ/PFD_FREQ_PPS;
+    localparam PFD_PERIOD_10MHZ=SAMPLE_CLOCK_FREQ/PFD_FREQ_10MHZ;
+
+
+    // Initial divide by 2 for 40 MHz clock
+    // (since refclk cannot be sampled directly)
+    reg refclk_div;
+    always @(posedge refclk) begin
+        refclk_div <= ~refclk_div;
+    end
+
+    // flop signals into sample clock domain together
+    reg [3:0] refsmp;
+    reg [3:0] refclksmp;
+    always @(posedge clk) begin
+        refsmp <= {refsmp[2:0],ref_x};
+        refclksmp <= {refclksmp[2:0],refclk_div};
+    end
+
+    // rising edge detection
+    wire ref_rising = (refsmp[3:2] == 2'b01);
+    wire refclk_rising = (refclksmp[3:2] == 2'b01);
+
+    // reference frequency detection
+    reg [27:0] refcnt;
+    reg ref_detected;
+    reg ref_is_10M;
+    reg ref_is_pps;
+    wire valid_ref = ref_is_10M | ref_is_pps;
+    always @(posedge clk) begin
+        if (reset) begin
+            refcnt <= 28'd0;
+            ref_detected <= 1'b0;
+            ref_is_10M <= 1'b0;
+            ref_is_pps <= 1'b0;
+        end
+        else if (ref_rising) begin
+            refcnt <= 28'd1;
+            ref_detected <= 1'b1;
+            ref_is_10M <= ((refcnt >= REF_PERIOD_10MHZ_MIN) && (refcnt <= REF_PERIOD_10MHZ_MAX));
+            ref_is_pps <= ((refcnt >= REF_PERIOD_PPS_MIN) && (refcnt <= REF_PERIOD_PPS_MAX));
+        end
+        else if ((ref_is_10M && (refcnt > REF_PERIOD_10MHZ_MAX)) || (refcnt > REF_PERIOD_PPS_MAX)) begin
+            // consider the reference lost
+            refcnt <= 28'd0;
+            ref_detected <= 1'b0;
+            ref_is_10M <= 1'b0;
+            ref_is_pps <= 1'b0;
+        end
+        else if (ref_detected)
+            refcnt <= refcnt + 28'd1;
+    end
+
+    // R divider
+    wire [23:0] rdiv = ref_is_10M ? RDIV_10MHZ : RDIV_PPS;
+    reg [23:0] rcnt;
+    wire [23:0] next_rcnt = ~valid_ref ? 24'd0 : (rcnt == rdiv) ? 24'd1 : rcnt + 1'b1;
+    reg r_rising;
+    always @(posedge clk) begin
+        if (ref_rising)
+            rcnt <= next_rcnt;
+        r_rising <= (ref_rising && ((ref_is_10M && (rcnt == rdiv)) || ref_is_pps));
+    end
+
+    // N divider
+    // Enable on rising edge of R after valid_ref
+    // is asserted so R and N signals start aligned.
+    // Disable if reference lost.
+    wire [25:0] ndiv = ref_is_10M ? NDIV_10MHZ : NDIV_PPS;
+    reg [25:0] ncnt;
+    wire [25:0] next_ncnt = ~valid_ref ? 26'd0 : ncnt == ndiv ? 26'd1 : ncnt + 1'b1;
+    reg n_rising;
+    always @(posedge clk) begin
+		if (refclk_rising)
+			ncnt <= next_ncnt;
+		n_rising <= (refclk_rising && (ncnt == ndiv));
+    end
+
+    // Frequency Counter
+    wire signed [28:0] period = ref_is_10M ? PFD_PERIOD_10MHZ : PFD_PERIOD_PPS;
+    reg signed [28:0] r_period_cnt;
+    reg signed [28:0] freq_err;
+    always @(posedge clk) begin
+        if (reset | ~valid_ref) begin
+            r_period_cnt <= 28'd0;
+            freq_err <= 29'sd0;
+        end
+        else if (r_rising) begin
+            r_period_cnt <= 28'd1;
+            freq_err <= period - r_period_cnt;
+        end
+        else
+            r_period_cnt <= r_period_cnt + 28'd1;
+    end
+
+    // Phase Counter
+    reg signed [28:0] lead_cnt;
+    reg lead_cnt_ena;
+    reg signed [28:0] lead;
+    always @(posedge clk) begin
+        // Count how much N leads R
+        // The count is negative because it measures
+        // how much the VCTCXO must be slowed down.
+        if (~valid_ref | n_rising) begin
+            lead_cnt <= 29'sd0;
+            lead_cnt_ena <= 1'b1;
+            if (r_rising)
+                lead <= 29'sd0;
+        end
+        else if (r_rising) begin
+            if (lead_cnt_ena)
+                lead <= lead_cnt - 29'sd1;
+            else begin
+                // R rising with no preceding N rising.
+                // N has changed from leading to lagging R,
+                // but we don't yet know by how much so
+                // assume 1.
+                lead <= 29'sd1;
+            end
+            lead_cnt_ena <= 1'b0;
+        end
+        else if (lead_cnt_ena)
+            lead_cnt <= lead_cnt - 29'sd1;
+    end
+
+    // PFD State Machine
+    localparam MEASURE=4'd0;
+    localparam CAPTURE=4'd1;
+    localparam CAPTURE_LAG=4'd2;
+    localparam CAPTURE_LEAD=4'd3;
+    localparam CALCULATE_ERROR=4'd4;
+    localparam CALCULATE_10M_GAIN=4'd5;
+    localparam CALCULATE_ADJUSTMENT=4'd6;
+    localparam CALCULATE_OUTPUT_VALUE=4'd7;
+    localparam APPLY_OUTPUT_VALUE=4'd8;
+    reg [3:0] state;
+    reg [15:0] daco = 16'd32767;
+    wire signed [28:0] lock_margin = ref_is_10M ? LOCK_MARGIN_10MHZ : LOCK_MARGIN_PPS;
+    wire signed [28:0] lag = lead + period;
+    reg signed [28:0] phase_err;
+    reg signed [28:0] err;
+    reg signed [28:0] shift;
+    reg signed [28:0] adj;
+    wire signed [28:0] dacv = {13'd0, daco};
+    reg signed [28:0] sum;
+    reg [2:0] ld;
+    always @(posedge clk) begin
+        if (reset || ~valid_ref) begin
+            state <= MEASURE;
+            daco <= 16'd32767;
+            err <= 29'sd0;
+            shift <= 29'sd0;
+            adj <= 29'sd0;
+            ld <= 3'd0;
+        end
+        else begin
+            case(state)
+                MEASURE: begin
+                    if (r_rising)
+                        state <= CAPTURE;
+                end
+                CAPTURE: begin
+                    if (lag < -lead)
+                        state <= CAPTURE_LAG;
+                    else
+                        state <= CAPTURE_LEAD;
+                end
+                CAPTURE_LAG: begin
+                    phase_err <= lag;
+                    ld <= {ld[1:0], (lag <= lock_margin)};
+                    state <= CALCULATE_ERROR;
+                end
+                CAPTURE_LEAD: begin
+                    phase_err <= lead;
+                    ld <= {ld[1:0], (-lead <= lock_margin)};
+                    state <= CALCULATE_ERROR;
+                end
+                CALCULATE_ERROR: begin
+                    err <= phase_err + freq_err;
+                    state <= ref_is_10M ? CALCULATE_10M_GAIN : CALCULATE_ADJUSTMENT;
+                end
+                CALCULATE_10M_GAIN: begin
+                    shift <= (err < -7 || err > 7) ? 7 : (err < 0 ? -err : err);
+                    state <= CALCULATE_ADJUSTMENT;
+                end
+                CALCULATE_ADJUSTMENT: begin
+                    // The VCTCXO is +/-5 ppm from 0.3V to 1.5V and the DAC is 16 bits,
+                    // which works out to 0.000228885 ppm per DAC unit.
+                    // The 200 MHz sampling clock means each unit of error is 0.005 ppm,
+                    // which works out to 21.845 DAC units to correct each unit of error.
+                    // Theory is nice, but the proportional and integral gains used here
+                    // were determined through manual tuning.
+                    if (ref_is_10M)
+                        adj <= (err <<< shift);
+                    else
+                        adj <= (err <<< 4) - err;
+                    state <= CALCULATE_OUTPUT_VALUE;
+                end
+                CALCULATE_OUTPUT_VALUE: begin
+                    sum <= dacv + adj;
+                    state <= APPLY_OUTPUT_VALUE;
+                end
+                APPLY_OUTPUT_VALUE: begin
+                    // Clip and apply
+                    if (sum < 29'sd0)
+                        daco <= 16'd0;
+                    else if (sum > 29'sd65535)
+                        daco <= 16'd65535;
+                    else
+                        daco <= sum[15:0];
+                    state <= MEASURE;
+                end
+            endcase
+        end
+    end
+
+    always @(posedge clk)
+        locked <= (ld == 3'b111);
+
+    ltc2630_spi u_ltc2630_spi(
+        .clk  ( clk  ),
+        .rst  ( reset  ),
+        .data ( daco ),
+        .sclk ( sclk ),
+        .mosi ( mosi ),
+        .sync_n  ( sync_n  )
+    );
+
+endmodule
diff --git a/projects/antsdre200/ip/gen_clks/gen_clks.v b/projects/antsdre200/ip/gen_clks/gen_clks.v
new file mode 100644
index 000000000..6ea95c252
--- /dev/null
+++ b/projects/antsdre200/ip/gen_clks/gen_clks.v
@@ -0,0 +1,96 @@
+
+// file: gen_clks.v
+// 
+// (c) Copyright 2008 - 2013 Xilinx, Inc. All rights reserved.
+// 
+// This file contains confidential and proprietary information
+// of Xilinx, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+// 
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// Xilinx, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) Xilinx shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or Xilinx had been advised of the
+// possibility of the same.
+// 
+// CRITICAL APPLICATIONS
+// Xilinx products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of Xilinx products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+// 
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+// 
+//----------------------------------------------------------------------------
+// User entered comments
+//----------------------------------------------------------------------------
+// None
+//
+//----------------------------------------------------------------------------
+//  Output     Output      Phase    Duty Cycle   Pk-to-Pk     Phase
+//   Clock     Freq (MHz)  (degrees)    (%)     Jitter (ps)  Error (ps)
+//----------------------------------------------------------------------------
+// clk_out1____40.000______0.000______50.0______232.099____191.950
+// clk_out2___100.000______0.000______50.0______180.876____191.950
+// clk_out3___200.000______0.000______50.0______158.299____191.950
+//
+//----------------------------------------------------------------------------
+// Input Clock   Freq (MHz)    Input Jitter (UI)
+//----------------------------------------------------------------------------
+// __primary______________40____________0.010
+
+`timescale 1ps/1ps
+
+(* CORE_GENERATION_INFO = "gen_clks,clk_wiz_v6_0_3_0_0,{component_name=gen_clks,use_phase_alignment=true,use_min_o_jitter=false,use_max_i_jitter=false,use_dyn_phase_shift=false,use_inclk_switchover=false,use_dyn_reconfig=false,enable_axi=0,feedback_source=FDBK_AUTO,PRIMITIVE=MMCM,num_out_clk=3,clkin1_period=25.000,clkin2_period=10.0,use_power_down=false,use_reset=false,use_locked=true,use_inclk_stopped=false,feedback_type=SINGLE,CLOCK_MGR_TYPE=NA,manual_override=false}" *)
+
+module gen_clks 
+ (
+  // Clock out ports
+  output        clk_out1,
+  output        clk_out2,
+  output        clk_out3,
+  // Status and control signals
+  output        locked,
+ // Clock in ports
+  input         clk_in1
+ );
+
+  gen_clks_clk_wiz inst
+  (
+  // Clock out ports  
+  .clk_out1(clk_out1),
+  .clk_out2(clk_out2),
+  .clk_out3(clk_out3),
+  // Status and control signals               
+  .locked(locked),
+ // Clock in ports
+  .clk_in1(clk_in1)
+  );
+
+endmodule
diff --git a/projects/antsdre200/ip/gen_clks/gen_clks.xci b/projects/antsdre200/ip/gen_clks/gen_clks.xci
new file mode 100644
index 000000000..ef235e0cf
--- /dev/null
+++ b/projects/antsdre200/ip/gen_clks/gen_clks.xci
@@ -0,0 +1,725 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<spirit:design xmlns:xilinx="http://www.xilinx.com" xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
+  <spirit:vendor>xilinx.com</spirit:vendor>
+  <spirit:library>xci</spirit:library>
+  <spirit:name>unknown</spirit:name>
+  <spirit:version>1.0</spirit:version>
+  <spirit:componentInstances>
+    <spirit:componentInstance>
+      <spirit:instanceName>gen_clks</spirit:instanceName>
+      <spirit:componentRef spirit:vendor="xilinx.com" spirit:library="ip" spirit:name="clk_wiz" spirit:version="6.0"/>
+      <spirit:configurableElementValues>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLKFB_IN_D.CAN_DEBUG">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLKFB_IN_D.FREQ_HZ">100000000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLKFB_OUT_D.CAN_DEBUG">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLKFB_OUT_D.FREQ_HZ">100000000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLK_IN1_D.CAN_DEBUG">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLK_IN1_D.FREQ_HZ">100000000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLK_IN2_D.CAN_DEBUG">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLK_IN2_D.FREQ_HZ">100000000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_IN1.ASSOCIATED_BUSIF"/>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_IN1.ASSOCIATED_RESET"/>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_IN1.CLK_DOMAIN"/>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_IN1.FREQ_HZ">100000000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_IN1.INSERT_VIP">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_IN1.PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT1.ASSOCIATED_BUSIF"/>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT1.ASSOCIATED_RESET"/>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT1.CLK_DOMAIN"/>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT1.FREQ_HZ">100000000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT1.INSERT_VIP">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT1.PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT2.ASSOCIATED_BUSIF"/>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT2.ASSOCIATED_RESET"/>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT2.CLK_DOMAIN"/>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT2.FREQ_HZ">100000000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT2.INSERT_VIP">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT2.PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT3.ASSOCIATED_BUSIF"/>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT3.ASSOCIATED_RESET"/>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT3.CLK_DOMAIN"/>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT3.FREQ_HZ">100000000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT3.INSERT_VIP">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLOCK_CLK_OUT3.PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.INTR.PortWidth">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.INTR.SENSITIVITY">LEVEL_HIGH</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.REF_CLK.ASSOCIATED_BUSIF"/>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.REF_CLK.ASSOCIATED_RESET"/>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.REF_CLK.CLK_DOMAIN"/>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.REF_CLK.FREQ_HZ">100000000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.REF_CLK.INSERT_VIP">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.REF_CLK.PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.RESET.INSERT_VIP">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.RESETN.INSERT_VIP">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_ACLK.CLK_DOMAIN"/>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_ACLK.FREQ_HZ">100000000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_ACLK.INSERT_VIP">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_ACLK.PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.ADDR_WIDTH">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.ARUSER_WIDTH">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.AWUSER_WIDTH">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.BUSER_WIDTH">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.CLK_DOMAIN"/>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.DATA_WIDTH">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.FREQ_HZ">100000000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_BRESP">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_BURST">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_CACHE">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_LOCK">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_PROT">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_QOS">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_REGION">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_RRESP">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_WSTRB">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.ID_WIDTH">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.INSERT_VIP">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.MAX_BURST_LENGTH">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.NUM_READ_OUTSTANDING">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.NUM_READ_THREADS">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.NUM_WRITE_OUTSTANDING">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.NUM_WRITE_THREADS">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.PROTOCOL">AXI4LITE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.READ_WRITE_MODE">READ_WRITE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.RUSER_BITS_PER_BYTE">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.RUSER_WIDTH">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.SUPPORTS_NARROW_BURST">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.WUSER_BITS_PER_BYTE">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.WUSER_WIDTH">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXI_RESETN.INSERT_VIP">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_AUTO_PRIMITIVE">MMCM</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CDDCDONE_PORT">cddcdone</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CDDCREQ_PORT">cddcreq</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKFBOUT_1">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKFBOUT_2">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKFB_IN_N_PORT">clkfb_in_n</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKFB_IN_PORT">clkfb_in</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKFB_IN_P_PORT">clkfb_in_p</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKFB_IN_SIGNALING">SINGLE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKFB_OUT_N_PORT">clkfb_out_n</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKFB_OUT_PORT">clkfb_out</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKFB_OUT_P_PORT">clkfb_out_p</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKFB_STOPPED_PORT">clkfb_stopped</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKIN1_JITTER_PS">250.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKIN2_JITTER_PS">100.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT0_1">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT0_2">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT0_ACTUAL_FREQ">40.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT1_1">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT1_2">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT1_ACTUAL_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT1_DRIVES">BUFG</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT1_DUTY_CYCLE">50.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT1_MATCHED_ROUTING">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT1_OUT_FREQ">40.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT1_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT1_REQUESTED_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT1_REQUESTED_OUT_FREQ">40</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT1_REQUESTED_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT1_SEQUENCE_NUMBER">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT2_1">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT2_2">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT2_ACTUAL_FREQ">200.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT2_DRIVES">BUFG</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT2_DUTY_CYCLE">50.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT2_MATCHED_ROUTING">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT2_OUT_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT2_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT2_REQUESTED_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT2_REQUESTED_OUT_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT2_REQUESTED_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT2_SEQUENCE_NUMBER">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT2_USED">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT3_1">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT3_2">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT3_ACTUAL_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT3_DRIVES">BUFG</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT3_DUTY_CYCLE">50.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT3_MATCHED_ROUTING">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT3_OUT_FREQ">200.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT3_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT3_REQUESTED_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT3_REQUESTED_OUT_FREQ">200.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT3_REQUESTED_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT3_SEQUENCE_NUMBER">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT3_USED">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT4_1">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT4_2">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT4_ACTUAL_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT4_DRIVES">BUFG</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT4_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT4_MATCHED_ROUTING">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT4_OUT_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT4_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT4_REQUESTED_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT4_REQUESTED_OUT_FREQ">200.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT4_REQUESTED_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT4_SEQUENCE_NUMBER">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT4_USED">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT5_1">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT5_2">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT5_ACTUAL_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT5_DRIVES">BUFG</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT5_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT5_MATCHED_ROUTING">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT5_OUT_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT5_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT5_REQUESTED_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT5_REQUESTED_OUT_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT5_REQUESTED_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT5_SEQUENCE_NUMBER">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT5_USED">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT6_1">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT6_2">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT6_ACTUAL_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT6_DRIVES">BUFG</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT6_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT6_MATCHED_ROUTING">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT6_OUT_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT6_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT6_REQUESTED_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT6_REQUESTED_OUT_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT6_REQUESTED_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT6_SEQUENCE_NUMBER">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT6_USED">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT7_DRIVES">BUFG</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT7_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT7_MATCHED_ROUTING">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT7_OUT_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT7_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT7_REQUESTED_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT7_REQUESTED_OUT_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT7_REQUESTED_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT7_SEQUENCE_NUMBER">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUT7_USED">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLKOUTPHY_MODE">VCO</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLK_IN_SEL_PORT">clk_in_sel</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLK_OUT1_PORT">clk_out1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLK_OUT2_PORT">clk_out2</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLK_OUT3_PORT">clk_out3</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLK_OUT4_PORT">clk_out4</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLK_OUT5_PORT">clk_out5</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLK_OUT6_PORT">clk_out6</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLK_OUT7_PORT">clk_out7</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLK_VALID_PORT">CLK_VALID</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_CLOCK_MGR_TYPE">NA</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_DADDR_PORT">daddr</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_DCLK_PORT">dclk</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_DEN_PORT">den</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_DIN_PORT">din</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_DIVCLK">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_DIVIDE1_AUTO">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_DIVIDE2_AUTO">0.4</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_DIVIDE3_AUTO">0.2</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_DIVIDE4_AUTO">0.2</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_DIVIDE5_AUTO">0.4</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_DIVIDE6_AUTO">0.4</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_DIVIDE7_AUTO">0.4</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_DOUT_PORT">dout</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_DRDY_PORT">drdy</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_DWE_PORT">dwe</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_ENABLE_CLKOUTPHY">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_ENABLE_CLOCK_MONITOR">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_ENABLE_USER_CLOCK0">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_ENABLE_USER_CLOCK1">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_ENABLE_USER_CLOCK2">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_ENABLE_USER_CLOCK3">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_Enable_PLL0">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_Enable_PLL1">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_FEEDBACK_SOURCE">FDBK_AUTO</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_FILTER_1">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_FILTER_2">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_HAS_CDDC">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_INCLK_SUM_ROW0">Input Clock   Freq (MHz)    Input Jitter (UI)</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_INCLK_SUM_ROW1">__primary______________40____________0.010</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_INCLK_SUM_ROW2">no_secondary_input_clock </spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_INPUT_CLK_STOPPED_PORT">input_clk_stopped</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_INTERFACE_SELECTION">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_IN_FREQ_UNITS">Units_MHz</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_JITTER_SEL">No_Jitter</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_LOCKED_PORT">locked</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_LOCK_1">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_LOCK_2">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_LOCK_3">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCMBUFGCEDIV">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCMBUFGCEDIV1">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCMBUFGCEDIV2">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCMBUFGCEDIV3">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCMBUFGCEDIV4">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCMBUFGCEDIV5">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCMBUFGCEDIV6">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCMBUFGCEDIV7">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_BANDWIDTH">OPTIMIZED</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKFBOUT_MULT_F">25.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKFBOUT_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKFBOUT_USE_FINE_PS">FALSE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKIN1_PERIOD">25.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKIN2_PERIOD">10.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT0_DIVIDE_F">25.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT0_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT0_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT0_USE_FINE_PS">FALSE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT1_DIVIDE">10</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT1_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT1_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT1_USE_FINE_PS">FALSE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT2_DIVIDE">5</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT2_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT2_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT2_USE_FINE_PS">FALSE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT3_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT3_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT3_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT3_USE_FINE_PS">FALSE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT4_CASCADE">FALSE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT4_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT4_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT4_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT4_USE_FINE_PS">FALSE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT5_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT5_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT5_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT5_USE_FINE_PS">FALSE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT6_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT6_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT6_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLKOUT6_USE_FINE_PS">FALSE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_CLOCK_HOLD">FALSE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_COMPENSATION">ZHOLD</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_DIVCLK_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_NOTES">None</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_REF_JITTER1">0.010</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_REF_JITTER2">0.010</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_MMCM_STARTUP_WAIT">FALSE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_NUM_OUT_CLKS">3</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_OUTCLK_SUM_ROW0A"> Output     Output      Phase    Duty Cycle   Pk-to-Pk     Phase</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_OUTCLK_SUM_ROW0B">  Clock     Freq (MHz)  (degrees)    (%)     Jitter (ps)  Error (ps)</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_OUTCLK_SUM_ROW1">clk_out1____40.000______0.000______50.0______232.099____191.950</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_OUTCLK_SUM_ROW2">clk_out2___100.000______0.000______50.0______180.876____191.950</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_OUTCLK_SUM_ROW3">clk_out3___200.000______0.000______50.0______158.299____191.950</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_OUTCLK_SUM_ROW4">no_CLK_OUT4_output</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_OUTCLK_SUM_ROW5">no_CLK_OUT5_output</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_OUTCLK_SUM_ROW6">no_CLK_OUT6_output</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_OUTCLK_SUM_ROW7">no_CLK_OUT7_output</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_OVERRIDE_MMCM">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_OVERRIDE_PLL">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PHASESHIFT_MODE">WAVEFORM</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLATFORM">UNKNOWN</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLLBUFGCEDIV">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLLBUFGCEDIV1">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLLBUFGCEDIV2">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLLBUFGCEDIV3">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLLBUFGCEDIV4">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_BANDWIDTH">OPTIMIZED</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKFBOUT_MULT">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKFBOUT_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKIN_PERIOD">1.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT0_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT0_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT0_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT1_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT1_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT1_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT2_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT2_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT2_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT3_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT3_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT3_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT4_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT4_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT4_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT5_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT5_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLKOUT5_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_CLK_FEEDBACK">CLKFBOUT</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_COMPENSATION">SYSTEM_SYNCHRONOUS</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_DIVCLK_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_NOTES">No notes</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PLL_REF_JITTER">0.010</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_POWER_DOWN_PORT">power_down</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_POWER_REG">0000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PRECISION">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PRIMARY_PORT">clk_in1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PRIMITIVE">MMCM</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PRIMTYPE_SEL">AUTO</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PRIM_IN_FREQ">40</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PRIM_IN_JITTER">0.010</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PRIM_IN_TIMEPERIOD">10.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PRIM_SOURCE">Single_ended_clock_capable_pin</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PSCLK_PORT">psclk</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PSDONE_PORT">psdone</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PSEN_PORT">psen</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PSINCDEC_PORT">psincdec</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_REF_CLK_FREQ">100.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_RESET_LOW">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_RESET_PORT">reset</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_SECONDARY_IN_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_SECONDARY_IN_JITTER">0.010</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_SECONDARY_IN_TIMEPERIOD">10.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_SECONDARY_PORT">clk_in2</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_SECONDARY_SOURCE">Single_ended_clock_capable_pin</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_SS_MODE">CENTER_HIGH</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_SS_MOD_PERIOD">4000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_SS_MOD_TIME">0.004</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_STATUS_PORT">STATUS</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_S_AXI_ADDR_WIDTH">11</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_S_AXI_DATA_WIDTH">32</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USER_CLK_FREQ0">100.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USER_CLK_FREQ1">100.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USER_CLK_FREQ2">100.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USER_CLK_FREQ3">100.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_CLKFB_STOPPED">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_CLKOUT1_BAR">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_CLKOUT2_BAR">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_CLKOUT3_BAR">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_CLKOUT4_BAR">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_CLK_VALID">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_CLOCK_SEQUENCING">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_DYN_PHASE_SHIFT">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_DYN_RECONFIG">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_FAST_SIMULATION">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_FREEZE">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_FREQ_SYNTH">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_INCLK_STOPPED">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_INCLK_SWITCHOVER">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_LOCKED">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_MAX_I_JITTER">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_MIN_O_JITTER">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_MIN_POWER">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_PHASE_ALIGNMENT">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_POWER_DOWN">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_RESET">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_SAFE_CLOCK_STARTUP">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_SPREAD_SPECTRUM">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_STATUS">0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_component_name">gen_clks</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AUTO_PRIMITIVE">MMCM</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AXI_DRP">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CALC_DONE">empty</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CDDCDONE_PORT">cddcdone</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CDDCREQ_PORT">cddcreq</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKFB_IN_N_PORT">clkfb_in_n</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKFB_IN_PORT">clkfb_in</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKFB_IN_P_PORT">clkfb_in_p</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKFB_IN_SIGNALING">SINGLE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKFB_OUT_N_PORT">clkfb_out_n</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKFB_OUT_PORT">clkfb_out</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKFB_OUT_P_PORT">clkfb_out_p</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKFB_STOPPED_PORT">clkfb_stopped</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKIN1_JITTER_PS">250.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKIN1_UI_JITTER">0.010</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKIN2_JITTER_PS">100.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKIN2_UI_JITTER">0.010</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT1_DRIVES">BUFG</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT1_JITTER">232.099</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT1_MATCHED_ROUTING">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT1_PHASE_ERROR">191.950</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT1_REQUESTED_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT1_REQUESTED_OUT_FREQ">40</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT1_REQUESTED_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT1_SEQUENCE_NUMBER">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT1_USED">true</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT2_DRIVES">BUFG</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT2_JITTER">180.876</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT2_MATCHED_ROUTING">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT2_PHASE_ERROR">191.950</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT2_REQUESTED_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT2_REQUESTED_OUT_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT2_REQUESTED_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT2_SEQUENCE_NUMBER">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT2_USED">true</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT3_DRIVES">BUFG</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT3_JITTER">158.299</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT3_MATCHED_ROUTING">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT3_PHASE_ERROR">191.950</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT3_REQUESTED_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT3_REQUESTED_OUT_FREQ">200.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT3_REQUESTED_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT3_SEQUENCE_NUMBER">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT3_USED">true</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT4_DRIVES">BUFG</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT4_JITTER">158.299</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT4_MATCHED_ROUTING">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT4_PHASE_ERROR">191.950</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT4_REQUESTED_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT4_REQUESTED_OUT_FREQ">200.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT4_REQUESTED_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT4_SEQUENCE_NUMBER">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT4_USED">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT5_DRIVES">BUFG</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT5_JITTER">0.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT5_MATCHED_ROUTING">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT5_PHASE_ERROR">0.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT5_REQUESTED_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT5_REQUESTED_OUT_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT5_REQUESTED_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT5_SEQUENCE_NUMBER">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT5_USED">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT6_DRIVES">BUFG</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT6_JITTER">0.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT6_MATCHED_ROUTING">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT6_PHASE_ERROR">0.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT6_REQUESTED_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT6_REQUESTED_OUT_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT6_REQUESTED_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT6_SEQUENCE_NUMBER">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT6_USED">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT7_DRIVES">BUFG</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT7_JITTER">0.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT7_MATCHED_ROUTING">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT7_PHASE_ERROR">0.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT7_REQUESTED_DUTY_CYCLE">50.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT7_REQUESTED_OUT_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT7_REQUESTED_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT7_SEQUENCE_NUMBER">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUT7_USED">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLKOUTPHY_REQUESTED_FREQ">600.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_IN1_BOARD_INTERFACE">Custom</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_IN2_BOARD_INTERFACE">Custom</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_IN_SEL_PORT">clk_in_sel</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_OUT1_PORT">clk_out1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_OUT1_USE_FINE_PS_GUI">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_OUT2_PORT">clk_out2</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_OUT2_USE_FINE_PS_GUI">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_OUT3_PORT">clk_out3</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_OUT3_USE_FINE_PS_GUI">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_OUT4_PORT">clk_out4</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_OUT4_USE_FINE_PS_GUI">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_OUT5_PORT">clk_out5</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_OUT5_USE_FINE_PS_GUI">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_OUT6_PORT">clk_out6</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_OUT6_USE_FINE_PS_GUI">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_OUT7_PORT">clk_out7</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_OUT7_USE_FINE_PS_GUI">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLK_VALID_PORT">CLK_VALID</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CLOCK_MGR_TYPE">auto</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Component_Name">gen_clks</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.DADDR_PORT">daddr</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.DCLK_PORT">dclk</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.DEN_PORT">den</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.DIFF_CLK_IN1_BOARD_INTERFACE">Custom</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.DIFF_CLK_IN2_BOARD_INTERFACE">Custom</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.DIN_PORT">din</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.DOUT_PORT">dout</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.DRDY_PORT">drdy</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.DWE_PORT">dwe</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.ENABLE_CDDC">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.ENABLE_CLKOUTPHY">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.ENABLE_CLOCK_MONITOR">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.ENABLE_USER_CLOCK0">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.ENABLE_USER_CLOCK1">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.ENABLE_USER_CLOCK2">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.ENABLE_USER_CLOCK3">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Enable_PLL0">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Enable_PLL1">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.FEEDBACK_SOURCE">FDBK_AUTO</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.INPUT_CLK_STOPPED_PORT">input_clk_stopped</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.INPUT_MODE">frequency</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.INTERFACE_SELECTION">Enable_AXI</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.IN_FREQ_UNITS">Units_MHz</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.IN_JITTER_UNITS">Units_UI</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.JITTER_OPTIONS">UI</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.JITTER_SEL">No_Jitter</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.LOCKED_PORT">locked</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_BANDWIDTH">OPTIMIZED</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKFBOUT_MULT_F">25.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKFBOUT_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKFBOUT_USE_FINE_PS">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKIN1_PERIOD">25.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKIN2_PERIOD">10.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT0_DIVIDE_F">25.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT0_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT0_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT0_USE_FINE_PS">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT1_DIVIDE">10</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT1_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT1_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT1_USE_FINE_PS">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT2_DIVIDE">5</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT2_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT2_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT2_USE_FINE_PS">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT3_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT3_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT3_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT3_USE_FINE_PS">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT4_CASCADE">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT4_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT4_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT4_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT4_USE_FINE_PS">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT5_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT5_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT5_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT5_USE_FINE_PS">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT6_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT6_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT6_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLKOUT6_USE_FINE_PS">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_CLOCK_HOLD">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_COMPENSATION">ZHOLD</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_DIVCLK_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_NOTES">None</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_REF_JITTER1">0.010</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_REF_JITTER2">0.010</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MMCM_STARTUP_WAIT">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.NUM_OUT_CLKS">3</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.OVERRIDE_MMCM">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.OVERRIDE_PLL">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PHASESHIFT_MODE">WAVEFORM</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PHASE_DUTY_CONFIG">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLATFORM">UNKNOWN</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_BANDWIDTH">OPTIMIZED</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKFBOUT_MULT">4</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKFBOUT_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKIN_PERIOD">10.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT0_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT0_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT0_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT1_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT1_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT1_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT2_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT2_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT2_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT3_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT3_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT3_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT4_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT4_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT4_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT5_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT5_DUTY_CYCLE">0.500</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLKOUT5_PHASE">0.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_CLK_FEEDBACK">CLKFBOUT</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_COMPENSATION">SYSTEM_SYNCHRONOUS</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_DIVCLK_DIVIDE">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_NOTES">None</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PLL_REF_JITTER">0.010</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.POWER_DOWN_PORT">power_down</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PRECISION">1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PRIMARY_PORT">clk_in1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PRIMITIVE">MMCM</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PRIMTYPE_SEL">mmcm_adv</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PRIM_IN_FREQ">40</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PRIM_IN_JITTER">0.010</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PRIM_IN_TIMEPERIOD">10.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PRIM_SOURCE">Single_ended_clock_capable_pin</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PSCLK_PORT">psclk</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PSDONE_PORT">psdone</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PSEN_PORT">psen</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PSINCDEC_PORT">psincdec</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.REF_CLK_FREQ">100.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.RELATIVE_INCLK">REL_PRIMARY</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.RESET_BOARD_INTERFACE">Custom</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.RESET_PORT">reset</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.RESET_TYPE">ACTIVE_HIGH</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.SECONDARY_IN_FREQ">100.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.SECONDARY_IN_JITTER">0.010</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.SECONDARY_IN_TIMEPERIOD">10.000</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.SECONDARY_PORT">clk_in2</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.SECONDARY_SOURCE">Single_ended_clock_capable_pin</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.SS_MODE">CENTER_HIGH</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.SS_MOD_FREQ">250</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.SS_MOD_TIME">0.004</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.STATUS_PORT">STATUS</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.SUMMARY_STRINGS">empty</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USER_CLK_FREQ0">100.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USER_CLK_FREQ1">100.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USER_CLK_FREQ2">100.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USER_CLK_FREQ3">100.0</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_BOARD_FLOW">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_CLKFB_STOPPED">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_CLK_VALID">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_CLOCK_SEQUENCING">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_DYN_PHASE_SHIFT">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_DYN_RECONFIG">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_FREEZE">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_FREQ_SYNTH">true</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_INCLK_STOPPED">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_INCLK_SWITCHOVER">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_LOCKED">true</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_MAX_I_JITTER">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_MIN_O_JITTER">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_MIN_POWER">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_PHASE_ALIGNMENT">true</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_POWER_DOWN">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_RESET">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_SAFE_CLOCK_STARTUP">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_SPREAD_SPECTRUM">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_STATUS">false</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.ARCHITECTURE">zynq</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.BASE_BOARD_PART"/>
+        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.BOARD_CONNECTIONS"/>
+        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.DEVICE">xc7z020</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.PACKAGE">clg400</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.PREFHDL">VERILOG</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.SILICON_REVISION"/>
+        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.SIMULATOR_LANGUAGE">MIXED</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.SPEEDGRADE">-2</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.STATIC_POWER"/>
+        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.TEMPERATURE_GRADE"/>
+        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.USE_RDI_CUSTOMIZATION">TRUE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.USE_RDI_GENERATION">TRUE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.IPCONTEXT">IP_Flow</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.IPREVISION">3</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.MANAGED">TRUE</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.OUTPUTDIR">.</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.SELECTEDSIMMODEL"/>
+        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.SHAREDDIR">.</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.SWVERSION">2019.1</spirit:configurableElementValue>
+        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.SYNTHESISFLOW">OUT_OF_CONTEXT</spirit:configurableElementValue>
+      </spirit:configurableElementValues>
+      <spirit:vendorExtensions>
+        <xilinx:componentInstanceExtensions>
+          <xilinx:configElementInfos>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.ADDR_WIDTH" xilinx:valueSource="auto"/>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.ARUSER_WIDTH" xilinx:valueSource="constant"/>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.AWUSER_WIDTH" xilinx:valueSource="constant"/>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.BUSER_WIDTH" xilinx:valueSource="constant"/>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.DATA_WIDTH" xilinx:valueSource="auto"/>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_BRESP" xilinx:valueSource="auto"/>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_BURST" xilinx:valueSource="constant"/>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_CACHE" xilinx:valueSource="constant"/>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_LOCK" xilinx:valueSource="constant"/>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_PROT" xilinx:valueSource="constant"/>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_QOS" xilinx:valueSource="constant"/>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_REGION" xilinx:valueSource="constant"/>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_RRESP" xilinx:valueSource="auto"/>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.HAS_WSTRB" xilinx:valueSource="auto"/>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.ID_WIDTH" xilinx:valueSource="constant"/>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.PROTOCOL" xilinx:valueSource="constant"/>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.RUSER_WIDTH" xilinx:valueSource="constant"/>
+            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_LITE.WUSER_WIDTH" xilinx:valueSource="constant"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.CLKIN1_JITTER_PS" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.CLKOUT1_JITTER" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.CLKOUT1_PHASE_ERROR" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.CLKOUT1_REQUESTED_OUT_FREQ" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.CLKOUT2_JITTER" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.CLKOUT2_PHASE_ERROR" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.CLKOUT2_USED" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.CLKOUT3_JITTER" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.CLKOUT3_PHASE_ERROR" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.CLKOUT3_REQUESTED_OUT_FREQ" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.CLKOUT3_USED" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.CLKOUT4_JITTER" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.CLKOUT4_PHASE_ERROR" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.CLKOUT4_REQUESTED_OUT_FREQ" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.CLKOUT4_USED" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.MMCM_CLKFBOUT_MULT_F" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.MMCM_CLKIN1_PERIOD" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.MMCM_CLKIN2_PERIOD" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.MMCM_CLKOUT0_DIVIDE_F" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.MMCM_CLKOUT1_DIVIDE" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.MMCM_CLKOUT2_DIVIDE" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.MMCM_CLKOUT3_DIVIDE" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.NUM_OUT_CLKS" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.PRIM_IN_FREQ" xilinx:valueSource="user"/>
+            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.USE_RESET" xilinx:valueSource="user"/>
+          </xilinx:configElementInfos>
+        </xilinx:componentInstanceExtensions>
+      </spirit:vendorExtensions>
+    </spirit:componentInstance>
+  </spirit:componentInstances>
+</spirit:design>
diff --git a/projects/antsdre200/ip/gen_clks/gen_clks.xdc b/projects/antsdre200/ip/gen_clks/gen_clks.xdc
new file mode 100644
index 000000000..ac09b240f
--- /dev/null
+++ b/projects/antsdre200/ip/gen_clks/gen_clks.xdc
@@ -0,0 +1,60 @@
+
+# file: gen_clks.xdc
+# 
+# (c) Copyright 2008 - 2013 Xilinx, Inc. All rights reserved.
+# 
+# This file contains confidential and proprietary information
+# of Xilinx, Inc. and is protected under U.S. and
+# international copyright and other intellectual property
+# laws.
+# 
+# DISCLAIMER
+# This disclaimer is not a license and does not grant any
+# rights to the materials distributed herewith. Except as
+# otherwise provided in a valid license issued to you by
+# Xilinx, and to the maximum extent permitted by applicable
+# law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+# WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
+# AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+# BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+# INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+# (2) Xilinx shall not be liable (whether in contract or tort,
+# including negligence, or under any other theory of
+# liability) for any loss or damage of any kind or nature
+# related to, arising under or in connection with these
+# materials, including for any direct, or any indirect,
+# special, incidental, or consequential loss or damage
+# (including loss of data, profits, goodwill, or any type of
+# loss or damage suffered as a result of any action brought
+# by a third party) even if such damage or loss was
+# reasonably foreseeable or Xilinx had been advised of the
+# possibility of the same.
+# 
+# CRITICAL APPLICATIONS
+# Xilinx products are not designed or intended to be fail-
+# safe, or for use in any application requiring fail-safe
+# performance, such as life-support or safety devices or
+# systems, Class III medical devices, nuclear facilities,
+# applications related to the deployment of airbags, or any
+# other applications that could lead to death, personal
+# injury, or severe property or environmental damage
+# (individually and collectively, "Critical
+# Applications"). Customer assumes the sole risk and
+# liability of any use of Xilinx products in Critical
+# Applications, subject only to applicable laws and
+# regulations governing limitations on product liability.
+# 
+# THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+# PART OF THIS FILE AT ALL TIMES.
+# 
+
+# Input clock periods. These duplicate the values entered for the
+# input clocks. You can use these to time your system. If required
+# commented constraints can be used in the top level xdc 
+#----------------------------------------------------------------
+# Connect to input port when clock capable pin is selected for input
+create_clock -period 25.000 [get_ports clk_in1]
+set_input_jitter [get_clocks -of_objects [get_ports clk_in1]] 0.25
+
+
+set_property PHASESHIFT_MODE WAVEFORM [get_cells -hierarchical *adv*]
diff --git a/projects/antsdre200/ip/gen_clks/gen_clks_board.xdc b/projects/antsdre200/ip/gen_clks/gen_clks_board.xdc
new file mode 100644
index 000000000..3422a8eba
--- /dev/null
+++ b/projects/antsdre200/ip/gen_clks/gen_clks_board.xdc
@@ -0,0 +1,2 @@
+#--------------------Physical Constraints-----------------
+
diff --git a/projects/antsdre200/ip/gen_clks/gen_clks_clk_wiz.v b/projects/antsdre200/ip/gen_clks/gen_clks_clk_wiz.v
new file mode 100644
index 000000000..6c50fbb1c
--- /dev/null
+++ b/projects/antsdre200/ip/gen_clks/gen_clks_clk_wiz.v
@@ -0,0 +1,219 @@
+
+// file: gen_clks.v
+// 
+// (c) Copyright 2008 - 2013 Xilinx, Inc. All rights reserved.
+// 
+// This file contains confidential and proprietary information
+// of Xilinx, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+// 
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// Xilinx, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) Xilinx shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or Xilinx had been advised of the
+// possibility of the same.
+// 
+// CRITICAL APPLICATIONS
+// Xilinx products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of Xilinx products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+// 
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+// 
+//----------------------------------------------------------------------------
+// User entered comments
+//----------------------------------------------------------------------------
+// None
+//
+//----------------------------------------------------------------------------
+//  Output     Output      Phase    Duty Cycle   Pk-to-Pk     Phase
+//   Clock     Freq (MHz)  (degrees)    (%)     Jitter (ps)  Error (ps)
+//----------------------------------------------------------------------------
+// clk_out1____40.000______0.000______50.0______232.099____191.950
+// clk_out2___100.000______0.000______50.0______180.876____191.950
+// clk_out3___200.000______0.000______50.0______158.299____191.950
+//
+//----------------------------------------------------------------------------
+// Input Clock   Freq (MHz)    Input Jitter (UI)
+//----------------------------------------------------------------------------
+// __primary______________40____________0.010
+
+`timescale 1ps/1ps
+
+module gen_clks_clk_wiz 
+
+ (// Clock in ports
+  // Clock out ports
+  output        clk_out1,
+  output        clk_out2,
+  output        clk_out3,
+  // Status and control signals
+  output        locked,
+  input         clk_in1
+ );
+  // Input buffering
+  //------------------------------------
+wire clk_in1_gen_clks;
+wire clk_in2_gen_clks;
+  IBUF clkin1_ibufg
+   (.O (clk_in1_gen_clks),
+    .I (clk_in1));
+
+
+
+
+  // Clocking PRIMITIVE
+  //------------------------------------
+
+  // Instantiation of the MMCM PRIMITIVE
+  //    * Unused inputs are tied off
+  //    * Unused outputs are labeled unused
+
+  wire        clk_out1_gen_clks;
+  wire        clk_out2_gen_clks;
+  wire        clk_out3_gen_clks;
+  wire        clk_out4_gen_clks;
+  wire        clk_out5_gen_clks;
+  wire        clk_out6_gen_clks;
+  wire        clk_out7_gen_clks;
+
+  wire [15:0] do_unused;
+  wire        drdy_unused;
+  wire        psdone_unused;
+  wire        locked_int;
+  wire        clkfbout_gen_clks;
+  wire        clkfbout_buf_gen_clks;
+  wire        clkfboutb_unused;
+    wire clkout0b_unused;
+   wire clkout1b_unused;
+   wire clkout2b_unused;
+   wire clkout3_unused;
+   wire clkout3b_unused;
+   wire clkout4_unused;
+  wire        clkout5_unused;
+  wire        clkout6_unused;
+  wire        clkfbstopped_unused;
+  wire        clkinstopped_unused;
+
+  MMCME2_ADV
+  #(.BANDWIDTH            ("OPTIMIZED"),
+    .CLKOUT4_CASCADE      ("FALSE"),
+    .COMPENSATION         ("ZHOLD"),
+    .STARTUP_WAIT         ("FALSE"),
+    .DIVCLK_DIVIDE        (1),
+    .CLKFBOUT_MULT_F      (25.000),
+    .CLKFBOUT_PHASE       (0.000),
+    .CLKFBOUT_USE_FINE_PS ("FALSE"),
+    .CLKOUT0_DIVIDE_F     (25.000),
+    .CLKOUT0_PHASE        (0.000),
+    .CLKOUT0_DUTY_CYCLE   (0.500),
+    .CLKOUT0_USE_FINE_PS  ("FALSE"),
+    .CLKOUT1_DIVIDE       (10),
+    .CLKOUT1_PHASE        (0.000),
+    .CLKOUT1_DUTY_CYCLE   (0.500),
+    .CLKOUT1_USE_FINE_PS  ("FALSE"),
+    .CLKOUT2_DIVIDE       (5),
+    .CLKOUT2_PHASE        (0.000),
+    .CLKOUT2_DUTY_CYCLE   (0.500),
+    .CLKOUT2_USE_FINE_PS  ("FALSE"),
+    .CLKIN1_PERIOD        (25.000))
+  mmcm_adv_inst
+    // Output clocks
+   (
+    .CLKFBOUT            (clkfbout_gen_clks),
+    .CLKFBOUTB           (clkfboutb_unused),
+    .CLKOUT0             (clk_out1_gen_clks),
+    .CLKOUT0B            (clkout0b_unused),
+    .CLKOUT1             (clk_out2_gen_clks),
+    .CLKOUT1B            (clkout1b_unused),
+    .CLKOUT2             (clk_out3_gen_clks),
+    .CLKOUT2B            (clkout2b_unused),
+    .CLKOUT3             (clkout3_unused),
+    .CLKOUT3B            (clkout3b_unused),
+    .CLKOUT4             (clkout4_unused),
+    .CLKOUT5             (clkout5_unused),
+    .CLKOUT6             (clkout6_unused),
+     // Input clock control
+    .CLKFBIN             (clkfbout_buf_gen_clks),
+    .CLKIN1              (clk_in1_gen_clks),
+    .CLKIN2              (1'b0),
+     // Tied to always select the primary input clock
+    .CLKINSEL            (1'b1),
+    // Ports for dynamic reconfiguration
+    .DADDR               (7'h0),
+    .DCLK                (1'b0),
+    .DEN                 (1'b0),
+    .DI                  (16'h0),
+    .DO                  (do_unused),
+    .DRDY                (drdy_unused),
+    .DWE                 (1'b0),
+    // Ports for dynamic phase shift
+    .PSCLK               (1'b0),
+    .PSEN                (1'b0),
+    .PSINCDEC            (1'b0),
+    .PSDONE              (psdone_unused),
+    // Other control and status signals
+    .LOCKED              (locked_int),
+    .CLKINSTOPPED        (clkinstopped_unused),
+    .CLKFBSTOPPED        (clkfbstopped_unused),
+    .PWRDWN              (1'b0),
+    .RST                 (1'b0));
+
+  assign locked = locked_int;
+// Clock Monitor clock assigning
+//--------------------------------------
+ // Output buffering
+  //-----------------------------------
+
+  BUFG clkf_buf
+   (.O (clkfbout_buf_gen_clks),
+    .I (clkfbout_gen_clks));
+
+
+
+
+
+
+  BUFG clkout1_buf
+   (.O   (clk_out1),
+    .I   (clk_out1_gen_clks));
+
+
+  BUFG clkout2_buf
+   (.O   (clk_out2),
+    .I   (clk_out2_gen_clks));
+
+  BUFG clkout3_buf
+   (.O   (clk_out3),
+    .I   (clk_out3_gen_clks));
+
+
+
+endmodule
diff --git a/projects/antsdre200/ip/gen_clks/gen_clks_ooc.xdc b/projects/antsdre200/ip/gen_clks/gen_clks_ooc.xdc
new file mode 100644
index 000000000..f126def36
--- /dev/null
+++ b/projects/antsdre200/ip/gen_clks/gen_clks_ooc.xdc
@@ -0,0 +1,58 @@
+
+# file: gen_clks_ooc.xdc
+# 
+# (c) Copyright 2008 - 2013 Xilinx, Inc. All rights reserved.
+# 
+# This file contains confidential and proprietary information
+# of Xilinx, Inc. and is protected under U.S. and
+# international copyright and other intellectual property
+# laws.
+# 
+# DISCLAIMER
+# This disclaimer is not a license and does not grant any
+# rights to the materials distributed herewith. Except as
+# otherwise provided in a valid license issued to you by
+# Xilinx, and to the maximum extent permitted by applicable
+# law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+# WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
+# AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+# BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+# INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+# (2) Xilinx shall not be liable (whether in contract or tort,
+# including negligence, or under any other theory of
+# liability) for any loss or damage of any kind or nature
+# related to, arising under or in connection with these
+# materials, including for any direct, or any indirect,
+# special, incidental, or consequential loss or damage
+# (including loss of data, profits, goodwill, or any type of
+# loss or damage suffered as a result of any action brought
+# by a third party) even if such damage or loss was
+# reasonably foreseeable or Xilinx had been advised of the
+# possibility of the same.
+# 
+# CRITICAL APPLICATIONS
+# Xilinx products are not designed or intended to be fail-
+# safe, or for use in any application requiring fail-safe
+# performance, such as life-support or safety devices or
+# systems, Class III medical devices, nuclear facilities,
+# applications related to the deployment of airbags, or any
+# other applications that could lead to death, personal
+# injury, or severe property or environmental damage
+# (individually and collectively, "Critical
+# Applications"). Customer assumes the sole risk and
+# liability of any use of Xilinx products in Critical
+# Applications, subject only to applicable laws and
+# regulations governing limitations on product liability.
+# 
+# THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+# PART OF THIS FILE AT ALL TIMES.
+# 
+
+#################
+#DEFAULT CLOCK CONSTRAINTS
+
+############################################################
+# Clock Period Constraints                                 #
+############################################################
+#create_clock -period 25.000 [get_ports clk_in1]
+
diff --git a/projects/antsdre200/ip/gen_clks/gen_clks_sim_netlist.v b/projects/antsdre200/ip/gen_clks/gen_clks_sim_netlist.v
new file mode 100644
index 000000000..c91029563
--- /dev/null
+++ b/projects/antsdre200/ip/gen_clks/gen_clks_sim_netlist.v
@@ -0,0 +1,260 @@
+// Copyright 1986-2019 Xilinx, Inc. All Rights Reserved.
+// --------------------------------------------------------------------------------
+// Tool Version: Vivado v.2019.1 (lin64) Build 2552052 Fri May 24 14:47:09 MDT 2019
+// Date        : Tue Nov  8 16:51:47 2022
+// Host        : jcc running 64-bit Ubuntu 18.04.6 LTS
+// Command     : write_verilog -force -mode funcsim
+//               /home/jcc/work/Git-project/antsdr-fw/hdl/projects/antsdre200/ip/gen_clks/gen_clks_sim_netlist.v
+// Design      : gen_clks
+// Purpose     : This verilog netlist is a functional simulation representation of the design and should not be modified
+//               or synthesized. This netlist cannot be used for SDF annotated simulation.
+// Device      : xc7z020clg400-2
+// --------------------------------------------------------------------------------
+`timescale 1 ps / 1 ps
+
+(* NotValidForBitStream *)
+module gen_clks
+   (clk_out1,
+    clk_out2,
+    clk_out3,
+    locked,
+    clk_in1);
+  output clk_out1;
+  output clk_out2;
+  output clk_out3;
+  output locked;
+  input clk_in1;
+
+  (* IBUF_LOW_PWR *) wire clk_in1;
+  wire clk_out1;
+  wire clk_out2;
+  wire clk_out3;
+  wire locked;
+
+  gen_clks_gen_clks_clk_wiz inst
+       (.clk_in1(clk_in1),
+        .clk_out1(clk_out1),
+        .clk_out2(clk_out2),
+        .clk_out3(clk_out3),
+        .locked(locked));
+endmodule
+
+(* ORIG_REF_NAME = "gen_clks_clk_wiz" *) 
+module gen_clks_gen_clks_clk_wiz
+   (clk_out1,
+    clk_out2,
+    clk_out3,
+    locked,
+    clk_in1);
+  output clk_out1;
+  output clk_out2;
+  output clk_out3;
+  output locked;
+  input clk_in1;
+
+  wire clk_in1;
+  wire clk_in1_gen_clks;
+  wire clk_out1;
+  wire clk_out1_gen_clks;
+  wire clk_out2;
+  wire clk_out2_gen_clks;
+  wire clk_out3;
+  wire clk_out3_gen_clks;
+  wire clkfbout_buf_gen_clks;
+  wire clkfbout_gen_clks;
+  wire locked;
+  wire NLW_mmcm_adv_inst_CLKFBOUTB_UNCONNECTED;
+  wire NLW_mmcm_adv_inst_CLKFBSTOPPED_UNCONNECTED;
+  wire NLW_mmcm_adv_inst_CLKINSTOPPED_UNCONNECTED;
+  wire NLW_mmcm_adv_inst_CLKOUT0B_UNCONNECTED;
+  wire NLW_mmcm_adv_inst_CLKOUT1B_UNCONNECTED;
+  wire NLW_mmcm_adv_inst_CLKOUT2B_UNCONNECTED;
+  wire NLW_mmcm_adv_inst_CLKOUT3_UNCONNECTED;
+  wire NLW_mmcm_adv_inst_CLKOUT3B_UNCONNECTED;
+  wire NLW_mmcm_adv_inst_CLKOUT4_UNCONNECTED;
+  wire NLW_mmcm_adv_inst_CLKOUT5_UNCONNECTED;
+  wire NLW_mmcm_adv_inst_CLKOUT6_UNCONNECTED;
+  wire NLW_mmcm_adv_inst_DRDY_UNCONNECTED;
+  wire NLW_mmcm_adv_inst_PSDONE_UNCONNECTED;
+  wire [15:0]NLW_mmcm_adv_inst_DO_UNCONNECTED;
+
+  (* BOX_TYPE = "PRIMITIVE" *) 
+  BUFG clkf_buf
+       (.I(clkfbout_gen_clks),
+        .O(clkfbout_buf_gen_clks));
+  (* BOX_TYPE = "PRIMITIVE" *) 
+  (* CAPACITANCE = "DONT_CARE" *) 
+  (* IBUF_DELAY_VALUE = "0" *) 
+  (* IFD_DELAY_VALUE = "AUTO" *) 
+  IBUF #(
+    .IOSTANDARD("DEFAULT")) 
+    clkin1_ibufg
+       (.I(clk_in1),
+        .O(clk_in1_gen_clks));
+  (* BOX_TYPE = "PRIMITIVE" *) 
+  BUFG clkout1_buf
+       (.I(clk_out1_gen_clks),
+        .O(clk_out1));
+  (* BOX_TYPE = "PRIMITIVE" *) 
+  BUFG clkout2_buf
+       (.I(clk_out2_gen_clks),
+        .O(clk_out2));
+  (* BOX_TYPE = "PRIMITIVE" *) 
+  BUFG clkout3_buf
+       (.I(clk_out3_gen_clks),
+        .O(clk_out3));
+  (* BOX_TYPE = "PRIMITIVE" *) 
+  MMCME2_ADV #(
+    .BANDWIDTH("OPTIMIZED"),
+    .CLKFBOUT_MULT_F(25.000000),
+    .CLKFBOUT_PHASE(0.000000),
+    .CLKFBOUT_USE_FINE_PS("FALSE"),
+    .CLKIN1_PERIOD(25.000000),
+    .CLKIN2_PERIOD(0.000000),
+    .CLKOUT0_DIVIDE_F(25.000000),
+    .CLKOUT0_DUTY_CYCLE(0.500000),
+    .CLKOUT0_PHASE(0.000000),
+    .CLKOUT0_USE_FINE_PS("FALSE"),
+    .CLKOUT1_DIVIDE(10),
+    .CLKOUT1_DUTY_CYCLE(0.500000),
+    .CLKOUT1_PHASE(0.000000),
+    .CLKOUT1_USE_FINE_PS("FALSE"),
+    .CLKOUT2_DIVIDE(5),
+    .CLKOUT2_DUTY_CYCLE(0.500000),
+    .CLKOUT2_PHASE(0.000000),
+    .CLKOUT2_USE_FINE_PS("FALSE"),
+    .CLKOUT3_DIVIDE(1),
+    .CLKOUT3_DUTY_CYCLE(0.500000),
+    .CLKOUT3_PHASE(0.000000),
+    .CLKOUT3_USE_FINE_PS("FALSE"),
+    .CLKOUT4_CASCADE("FALSE"),
+    .CLKOUT4_DIVIDE(1),
+    .CLKOUT4_DUTY_CYCLE(0.500000),
+    .CLKOUT4_PHASE(0.000000),
+    .CLKOUT4_USE_FINE_PS("FALSE"),
+    .CLKOUT5_DIVIDE(1),
+    .CLKOUT5_DUTY_CYCLE(0.500000),
+    .CLKOUT5_PHASE(0.000000),
+    .CLKOUT5_USE_FINE_PS("FALSE"),
+    .CLKOUT6_DIVIDE(1),
+    .CLKOUT6_DUTY_CYCLE(0.500000),
+    .CLKOUT6_PHASE(0.000000),
+    .CLKOUT6_USE_FINE_PS("FALSE"),
+    .COMPENSATION("ZHOLD"),
+    .DIVCLK_DIVIDE(1),
+    .IS_CLKINSEL_INVERTED(1'b0),
+    .IS_PSEN_INVERTED(1'b0),
+    .IS_PSINCDEC_INVERTED(1'b0),
+    .IS_PWRDWN_INVERTED(1'b0),
+    .IS_RST_INVERTED(1'b0),
+    .REF_JITTER1(0.010000),
+    .REF_JITTER2(0.010000),
+    .SS_EN("FALSE"),
+    .SS_MODE("CENTER_HIGH"),
+    .SS_MOD_PERIOD(10000),
+    .STARTUP_WAIT("FALSE")) 
+    mmcm_adv_inst
+       (.CLKFBIN(clkfbout_buf_gen_clks),
+        .CLKFBOUT(clkfbout_gen_clks),
+        .CLKFBOUTB(NLW_mmcm_adv_inst_CLKFBOUTB_UNCONNECTED),
+        .CLKFBSTOPPED(NLW_mmcm_adv_inst_CLKFBSTOPPED_UNCONNECTED),
+        .CLKIN1(clk_in1_gen_clks),
+        .CLKIN2(1'b0),
+        .CLKINSEL(1'b1),
+        .CLKINSTOPPED(NLW_mmcm_adv_inst_CLKINSTOPPED_UNCONNECTED),
+        .CLKOUT0(clk_out1_gen_clks),
+        .CLKOUT0B(NLW_mmcm_adv_inst_CLKOUT0B_UNCONNECTED),
+        .CLKOUT1(clk_out2_gen_clks),
+        .CLKOUT1B(NLW_mmcm_adv_inst_CLKOUT1B_UNCONNECTED),
+        .CLKOUT2(clk_out3_gen_clks),
+        .CLKOUT2B(NLW_mmcm_adv_inst_CLKOUT2B_UNCONNECTED),
+        .CLKOUT3(NLW_mmcm_adv_inst_CLKOUT3_UNCONNECTED),
+        .CLKOUT3B(NLW_mmcm_adv_inst_CLKOUT3B_UNCONNECTED),
+        .CLKOUT4(NLW_mmcm_adv_inst_CLKOUT4_UNCONNECTED),
+        .CLKOUT5(NLW_mmcm_adv_inst_CLKOUT5_UNCONNECTED),
+        .CLKOUT6(NLW_mmcm_adv_inst_CLKOUT6_UNCONNECTED),
+        .DADDR({1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0}),
+        .DCLK(1'b0),
+        .DEN(1'b0),
+        .DI({1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0}),
+        .DO(NLW_mmcm_adv_inst_DO_UNCONNECTED[15:0]),
+        .DRDY(NLW_mmcm_adv_inst_DRDY_UNCONNECTED),
+        .DWE(1'b0),
+        .LOCKED(locked),
+        .PSCLK(1'b0),
+        .PSDONE(NLW_mmcm_adv_inst_PSDONE_UNCONNECTED),
+        .PSEN(1'b0),
+        .PSINCDEC(1'b0),
+        .PWRDWN(1'b0),
+        .RST(1'b0));
+endmodule
+`ifndef GLBL
+`define GLBL
+`timescale  1 ps / 1 ps
+
+module glbl ();
+
+    parameter ROC_WIDTH = 100000;
+    parameter TOC_WIDTH = 0;
+
+//--------   STARTUP Globals --------------
+    wire GSR;
+    wire GTS;
+    wire GWE;
+    wire PRLD;
+    tri1 p_up_tmp;
+    tri (weak1, strong0) PLL_LOCKG = p_up_tmp;
+
+    wire PROGB_GLBL;
+    wire CCLKO_GLBL;
+    wire FCSBO_GLBL;
+    wire [3:0] DO_GLBL;
+    wire [3:0] DI_GLBL;
+   
+    reg GSR_int;
+    reg GTS_int;
+    reg PRLD_int;
+
+//--------   JTAG Globals --------------
+    wire JTAG_TDO_GLBL;
+    wire JTAG_TCK_GLBL;
+    wire JTAG_TDI_GLBL;
+    wire JTAG_TMS_GLBL;
+    wire JTAG_TRST_GLBL;
+
+    reg JTAG_CAPTURE_GLBL;
+    reg JTAG_RESET_GLBL;
+    reg JTAG_SHIFT_GLBL;
+    reg JTAG_UPDATE_GLBL;
+    reg JTAG_RUNTEST_GLBL;
+
+    reg JTAG_SEL1_GLBL = 0;
+    reg JTAG_SEL2_GLBL = 0 ;
+    reg JTAG_SEL3_GLBL = 0;
+    reg JTAG_SEL4_GLBL = 0;
+
+    reg JTAG_USER_TDO1_GLBL = 1'bz;
+    reg JTAG_USER_TDO2_GLBL = 1'bz;
+    reg JTAG_USER_TDO3_GLBL = 1'bz;
+    reg JTAG_USER_TDO4_GLBL = 1'bz;
+
+    assign (strong1, weak0) GSR = GSR_int;
+    assign (strong1, weak0) GTS = GTS_int;
+    assign (weak1, weak0) PRLD = PRLD_int;
+
+    initial begin
+	GSR_int = 1'b1;
+	PRLD_int = 1'b1;
+	#(ROC_WIDTH)
+	GSR_int = 1'b0;
+	PRLD_int = 1'b0;
+    end
+
+    initial begin
+	GTS_int = 1'b1;
+	#(TOC_WIDTH)
+	GTS_int = 1'b0;
+    end
+
+endmodule
+`endif
diff --git a/projects/antsdre200/ip/gen_clks/gen_clks_sim_netlist.vhdl b/projects/antsdre200/ip/gen_clks/gen_clks_sim_netlist.vhdl
new file mode 100644
index 000000000..4a3d0e02c
--- /dev/null
+++ b/projects/antsdre200/ip/gen_clks/gen_clks_sim_netlist.vhdl
@@ -0,0 +1,205 @@
+-- Copyright 1986-2019 Xilinx, Inc. All Rights Reserved.
+-- --------------------------------------------------------------------------------
+-- Tool Version: Vivado v.2019.1 (lin64) Build 2552052 Fri May 24 14:47:09 MDT 2019
+-- Date        : Tue Nov  8 16:51:47 2022
+-- Host        : jcc running 64-bit Ubuntu 18.04.6 LTS
+-- Command     : write_vhdl -force -mode funcsim
+--               /home/jcc/work/Git-project/antsdr-fw/hdl/projects/antsdre200/ip/gen_clks/gen_clks_sim_netlist.vhdl
+-- Design      : gen_clks
+-- Purpose     : This VHDL netlist is a functional simulation representation of the design and should not be modified or
+--               synthesized. This netlist cannot be used for SDF annotated simulation.
+-- Device      : xc7z020clg400-2
+-- --------------------------------------------------------------------------------
+library IEEE;
+use IEEE.STD_LOGIC_1164.ALL;
+library UNISIM;
+use UNISIM.VCOMPONENTS.ALL;
+entity gen_clks_gen_clks_clk_wiz is
+  port (
+    clk_out1 : out STD_LOGIC;
+    clk_out2 : out STD_LOGIC;
+    clk_out3 : out STD_LOGIC;
+    locked : out STD_LOGIC;
+    clk_in1 : in STD_LOGIC
+  );
+  attribute ORIG_REF_NAME : string;
+  attribute ORIG_REF_NAME of gen_clks_gen_clks_clk_wiz : entity is "gen_clks_clk_wiz";
+end gen_clks_gen_clks_clk_wiz;
+
+architecture STRUCTURE of gen_clks_gen_clks_clk_wiz is
+  signal clk_in1_gen_clks : STD_LOGIC;
+  signal clk_out1_gen_clks : STD_LOGIC;
+  signal clk_out2_gen_clks : STD_LOGIC;
+  signal clk_out3_gen_clks : STD_LOGIC;
+  signal clkfbout_buf_gen_clks : STD_LOGIC;
+  signal clkfbout_gen_clks : STD_LOGIC;
+  signal NLW_mmcm_adv_inst_CLKFBOUTB_UNCONNECTED : STD_LOGIC;
+  signal NLW_mmcm_adv_inst_CLKFBSTOPPED_UNCONNECTED : STD_LOGIC;
+  signal NLW_mmcm_adv_inst_CLKINSTOPPED_UNCONNECTED : STD_LOGIC;
+  signal NLW_mmcm_adv_inst_CLKOUT0B_UNCONNECTED : STD_LOGIC;
+  signal NLW_mmcm_adv_inst_CLKOUT1B_UNCONNECTED : STD_LOGIC;
+  signal NLW_mmcm_adv_inst_CLKOUT2B_UNCONNECTED : STD_LOGIC;
+  signal NLW_mmcm_adv_inst_CLKOUT3_UNCONNECTED : STD_LOGIC;
+  signal NLW_mmcm_adv_inst_CLKOUT3B_UNCONNECTED : STD_LOGIC;
+  signal NLW_mmcm_adv_inst_CLKOUT4_UNCONNECTED : STD_LOGIC;
+  signal NLW_mmcm_adv_inst_CLKOUT5_UNCONNECTED : STD_LOGIC;
+  signal NLW_mmcm_adv_inst_CLKOUT6_UNCONNECTED : STD_LOGIC;
+  signal NLW_mmcm_adv_inst_DRDY_UNCONNECTED : STD_LOGIC;
+  signal NLW_mmcm_adv_inst_PSDONE_UNCONNECTED : STD_LOGIC;
+  signal NLW_mmcm_adv_inst_DO_UNCONNECTED : STD_LOGIC_VECTOR ( 15 downto 0 );
+  attribute BOX_TYPE : string;
+  attribute BOX_TYPE of clkf_buf : label is "PRIMITIVE";
+  attribute BOX_TYPE of clkin1_ibufg : label is "PRIMITIVE";
+  attribute CAPACITANCE : string;
+  attribute CAPACITANCE of clkin1_ibufg : label is "DONT_CARE";
+  attribute IBUF_DELAY_VALUE : string;
+  attribute IBUF_DELAY_VALUE of clkin1_ibufg : label is "0";
+  attribute IFD_DELAY_VALUE : string;
+  attribute IFD_DELAY_VALUE of clkin1_ibufg : label is "AUTO";
+  attribute BOX_TYPE of clkout1_buf : label is "PRIMITIVE";
+  attribute BOX_TYPE of clkout2_buf : label is "PRIMITIVE";
+  attribute BOX_TYPE of clkout3_buf : label is "PRIMITIVE";
+  attribute BOX_TYPE of mmcm_adv_inst : label is "PRIMITIVE";
+begin
+clkf_buf: unisim.vcomponents.BUFG
+     port map (
+      I => clkfbout_gen_clks,
+      O => clkfbout_buf_gen_clks
+    );
+clkin1_ibufg: unisim.vcomponents.IBUF
+    generic map(
+      IOSTANDARD => "DEFAULT"
+    )
+        port map (
+      I => clk_in1,
+      O => clk_in1_gen_clks
+    );
+clkout1_buf: unisim.vcomponents.BUFG
+     port map (
+      I => clk_out1_gen_clks,
+      O => clk_out1
+    );
+clkout2_buf: unisim.vcomponents.BUFG
+     port map (
+      I => clk_out2_gen_clks,
+      O => clk_out2
+    );
+clkout3_buf: unisim.vcomponents.BUFG
+     port map (
+      I => clk_out3_gen_clks,
+      O => clk_out3
+    );
+mmcm_adv_inst: unisim.vcomponents.MMCME2_ADV
+    generic map(
+      BANDWIDTH => "OPTIMIZED",
+      CLKFBOUT_MULT_F => 25.000000,
+      CLKFBOUT_PHASE => 0.000000,
+      CLKFBOUT_USE_FINE_PS => false,
+      CLKIN1_PERIOD => 25.000000,
+      CLKIN2_PERIOD => 0.000000,
+      CLKOUT0_DIVIDE_F => 25.000000,
+      CLKOUT0_DUTY_CYCLE => 0.500000,
+      CLKOUT0_PHASE => 0.000000,
+      CLKOUT0_USE_FINE_PS => false,
+      CLKOUT1_DIVIDE => 10,
+      CLKOUT1_DUTY_CYCLE => 0.500000,
+      CLKOUT1_PHASE => 0.000000,
+      CLKOUT1_USE_FINE_PS => false,
+      CLKOUT2_DIVIDE => 5,
+      CLKOUT2_DUTY_CYCLE => 0.500000,
+      CLKOUT2_PHASE => 0.000000,
+      CLKOUT2_USE_FINE_PS => false,
+      CLKOUT3_DIVIDE => 1,
+      CLKOUT3_DUTY_CYCLE => 0.500000,
+      CLKOUT3_PHASE => 0.000000,
+      CLKOUT3_USE_FINE_PS => false,
+      CLKOUT4_CASCADE => false,
+      CLKOUT4_DIVIDE => 1,
+      CLKOUT4_DUTY_CYCLE => 0.500000,
+      CLKOUT4_PHASE => 0.000000,
+      CLKOUT4_USE_FINE_PS => false,
+      CLKOUT5_DIVIDE => 1,
+      CLKOUT5_DUTY_CYCLE => 0.500000,
+      CLKOUT5_PHASE => 0.000000,
+      CLKOUT5_USE_FINE_PS => false,
+      CLKOUT6_DIVIDE => 1,
+      CLKOUT6_DUTY_CYCLE => 0.500000,
+      CLKOUT6_PHASE => 0.000000,
+      CLKOUT6_USE_FINE_PS => false,
+      COMPENSATION => "ZHOLD",
+      DIVCLK_DIVIDE => 1,
+      IS_CLKINSEL_INVERTED => '0',
+      IS_PSEN_INVERTED => '0',
+      IS_PSINCDEC_INVERTED => '0',
+      IS_PWRDWN_INVERTED => '0',
+      IS_RST_INVERTED => '0',
+      REF_JITTER1 => 0.010000,
+      REF_JITTER2 => 0.010000,
+      SS_EN => "FALSE",
+      SS_MODE => "CENTER_HIGH",
+      SS_MOD_PERIOD => 10000,
+      STARTUP_WAIT => false
+    )
+        port map (
+      CLKFBIN => clkfbout_buf_gen_clks,
+      CLKFBOUT => clkfbout_gen_clks,
+      CLKFBOUTB => NLW_mmcm_adv_inst_CLKFBOUTB_UNCONNECTED,
+      CLKFBSTOPPED => NLW_mmcm_adv_inst_CLKFBSTOPPED_UNCONNECTED,
+      CLKIN1 => clk_in1_gen_clks,
+      CLKIN2 => '0',
+      CLKINSEL => '1',
+      CLKINSTOPPED => NLW_mmcm_adv_inst_CLKINSTOPPED_UNCONNECTED,
+      CLKOUT0 => clk_out1_gen_clks,
+      CLKOUT0B => NLW_mmcm_adv_inst_CLKOUT0B_UNCONNECTED,
+      CLKOUT1 => clk_out2_gen_clks,
+      CLKOUT1B => NLW_mmcm_adv_inst_CLKOUT1B_UNCONNECTED,
+      CLKOUT2 => clk_out3_gen_clks,
+      CLKOUT2B => NLW_mmcm_adv_inst_CLKOUT2B_UNCONNECTED,
+      CLKOUT3 => NLW_mmcm_adv_inst_CLKOUT3_UNCONNECTED,
+      CLKOUT3B => NLW_mmcm_adv_inst_CLKOUT3B_UNCONNECTED,
+      CLKOUT4 => NLW_mmcm_adv_inst_CLKOUT4_UNCONNECTED,
+      CLKOUT5 => NLW_mmcm_adv_inst_CLKOUT5_UNCONNECTED,
+      CLKOUT6 => NLW_mmcm_adv_inst_CLKOUT6_UNCONNECTED,
+      DADDR(6 downto 0) => B"0000000",
+      DCLK => '0',
+      DEN => '0',
+      DI(15 downto 0) => B"0000000000000000",
+      DO(15 downto 0) => NLW_mmcm_adv_inst_DO_UNCONNECTED(15 downto 0),
+      DRDY => NLW_mmcm_adv_inst_DRDY_UNCONNECTED,
+      DWE => '0',
+      LOCKED => locked,
+      PSCLK => '0',
+      PSDONE => NLW_mmcm_adv_inst_PSDONE_UNCONNECTED,
+      PSEN => '0',
+      PSINCDEC => '0',
+      PWRDWN => '0',
+      RST => '0'
+    );
+end STRUCTURE;
+library IEEE;
+use IEEE.STD_LOGIC_1164.ALL;
+library UNISIM;
+use UNISIM.VCOMPONENTS.ALL;
+entity gen_clks is
+  port (
+    clk_out1 : out STD_LOGIC;
+    clk_out2 : out STD_LOGIC;
+    clk_out3 : out STD_LOGIC;
+    locked : out STD_LOGIC;
+    clk_in1 : in STD_LOGIC
+  );
+  attribute NotValidForBitStream : boolean;
+  attribute NotValidForBitStream of gen_clks : entity is true;
+end gen_clks;
+
+architecture STRUCTURE of gen_clks is
+begin
+inst: entity work.gen_clks_gen_clks_clk_wiz
+     port map (
+      clk_in1 => clk_in1,
+      clk_out1 => clk_out1,
+      clk_out2 => clk_out2,
+      clk_out3 => clk_out3,
+      locked => locked
+    );
+end STRUCTURE;
diff --git a/projects/antsdre200/ip/gen_clks/gen_clks_stub.v b/projects/antsdre200/ip/gen_clks/gen_clks_stub.v
new file mode 100644
index 000000000..4187b7bcc
--- /dev/null
+++ b/projects/antsdre200/ip/gen_clks/gen_clks_stub.v
@@ -0,0 +1,23 @@
+// Copyright 1986-2019 Xilinx, Inc. All Rights Reserved.
+// --------------------------------------------------------------------------------
+// Tool Version: Vivado v.2019.1 (lin64) Build 2552052 Fri May 24 14:47:09 MDT 2019
+// Date        : Tue Nov  8 16:51:46 2022
+// Host        : jcc running 64-bit Ubuntu 18.04.6 LTS
+// Command     : write_verilog -force -mode synth_stub
+//               /home/jcc/work/Git-project/antsdr-fw/hdl/projects/antsdre200/ip/gen_clks/gen_clks_stub.v
+// Design      : gen_clks
+// Purpose     : Stub declaration of top-level module interface
+// Device      : xc7z020clg400-2
+// --------------------------------------------------------------------------------
+
+// This empty module with port declaration file causes synthesis tools to infer a black box for IP.
+// The synthesis directives are for Synopsys Synplify support to prevent IO buffer insertion.
+// Please paste the declaration into a Verilog source file or add the file as an additional source.
+module gen_clks(clk_out1, clk_out2, clk_out3, locked, clk_in1)
+/* synthesis syn_black_box black_box_pad_pin="clk_out1,clk_out2,clk_out3,locked,clk_in1" */;
+  output clk_out1;
+  output clk_out2;
+  output clk_out3;
+  output locked;
+  input clk_in1;
+endmodule
diff --git a/projects/antsdre200/ip/gen_clks/gen_clks_stub.vhdl b/projects/antsdre200/ip/gen_clks/gen_clks_stub.vhdl
new file mode 100644
index 000000000..30dd43605
--- /dev/null
+++ b/projects/antsdre200/ip/gen_clks/gen_clks_stub.vhdl
@@ -0,0 +1,32 @@
+-- Copyright 1986-2019 Xilinx, Inc. All Rights Reserved.
+-- --------------------------------------------------------------------------------
+-- Tool Version: Vivado v.2019.1 (lin64) Build 2552052 Fri May 24 14:47:09 MDT 2019
+-- Date        : Tue Nov  8 16:51:46 2022
+-- Host        : jcc running 64-bit Ubuntu 18.04.6 LTS
+-- Command     : write_vhdl -force -mode synth_stub
+--               /home/jcc/work/Git-project/antsdr-fw/hdl/projects/antsdre200/ip/gen_clks/gen_clks_stub.vhdl
+-- Design      : gen_clks
+-- Purpose     : Stub declaration of top-level module interface
+-- Device      : xc7z020clg400-2
+-- --------------------------------------------------------------------------------
+library IEEE;
+use IEEE.STD_LOGIC_1164.ALL;
+
+entity gen_clks is
+  Port ( 
+    clk_out1 : out STD_LOGIC;
+    clk_out2 : out STD_LOGIC;
+    clk_out3 : out STD_LOGIC;
+    locked : out STD_LOGIC;
+    clk_in1 : in STD_LOGIC
+  );
+
+end gen_clks;
+
+architecture stub of gen_clks is
+attribute syn_black_box : boolean;
+attribute black_box_pad_pin : string;
+attribute syn_black_box of stub : architecture is true;
+attribute black_box_pad_pin of stub : architecture is "clk_out1,clk_out2,clk_out3,locked,clk_in1";
+begin
+end;
diff --git a/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_7s_mmcm.vh b/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_7s_mmcm.vh
new file mode 100755
index 000000000..652d7d11a
--- /dev/null
+++ b/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_7s_mmcm.vh
@@ -0,0 +1,671 @@
+///////////////////////////////////////////////////////////////////////////////
+//    
+//    Company:          Xilinx
+//    Engineer:         Jim Tatsukawa, Karl Kurbjun and Carl Ribbing
+//    Date:             7/30/2014
+//    Design Name:      MMCME2 DRP
+//    Module Name:      mmcme2_drp_func.h
+//    Version:          1.04
+//    Target Devices:   7 Series || MMCM
+//    Tool versions:    2014.3
+//    Description:      This header provides the functions necessary to  
+//                      calculate the DRP register values for the V6 MMCM.
+//                      
+//	Revision Notes:	3/12 - Updating lookup_low/lookup_high (CR)
+//			4/13 - Fractional divide function in mmcm_frac_count_calc function. CRS610807
+// 
+//    Disclaimer:  XILINX IS PROVIDING THIS DESIGN, CODE, OR
+//                 INFORMATION "AS IS" SOLELY FOR USE IN DEVELOPING
+//                 PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY
+//                 PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+//                 ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+//                 APPLICATION OR STANDARD, XILINX IS MAKING NO
+//                 REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+//                 FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE
+//                 RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY
+//                 REQUIRE FOR YOUR IMPLEMENTATION.  XILINX
+//                 EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH
+//                 RESPECT TO THE ADEQUACY OF THE IMPLEMENTATION,
+//                 INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+//                 REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE
+//                 FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES
+//                 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+//                 PURPOSE.
+// 
+//                 (c) Copyright 2009-2010 Xilinx, Inc.
+//                 All rights reserved.
+// 
+///////////////////////////////////////////////////////////////////////////////
+
+// These are user functions that should not be modified.  Changes to the defines
+// or code within the functions may alter the accuracy of the calculations.
+
+// Define debug to provide extra messages durring elaboration
+//`define DEBUG 1
+
+// FRAC_PRECISION describes the width of the fractional portion of the fixed
+//    point numbers.  These should not be modified, they are for development 
+//    only
+`define FRAC_PRECISION  10
+// FIXED_WIDTH describes the total size for fixed point calculations(int+frac).
+// Warning: L.50 and below will not calculate properly with FIXED_WIDTHs 
+//    greater than 32
+`define FIXED_WIDTH     32 
+
+// This function takes a fixed point number and rounds it to the nearest
+//    fractional precision bit.
+function [`FIXED_WIDTH:1] round_frac
+   (
+      // Input is (FIXED_WIDTH-FRAC_PRECISION).FRAC_PRECISION fixed point number
+      input [`FIXED_WIDTH:1] decimal,  
+
+      // This describes the precision of the fraction, for example a value
+      //    of 1 would modify the fractional so that instead of being a .16
+      //    fractional, it would be a .1 (rounded to the nearest 0.5 in turn)
+      input [`FIXED_WIDTH:1] precision 
+   );
+
+   begin
+   
+   `ifdef DEBUG
+      $display("round_frac - decimal: %h, precision: %h", decimal, precision);
+   `endif
+      // If the fractional precision bit is high then round up
+      if( decimal[(`FRAC_PRECISION-precision)] == 1'b1) begin
+         round_frac = decimal + (1'b1 << (`FRAC_PRECISION-precision));
+      end else begin
+         round_frac = decimal;
+      end
+   `ifdef DEBUG
+      $display("round_frac: %h", round_frac);
+   `endif
+   end
+endfunction
+
+// This function calculates high_time, low_time, w_edge, and no_count
+//    of a non-fractional counter based on the divide and duty cycle
+//
+// NOTE: high_time and low_time are returned as integers between 0 and 63 
+//    inclusive.  64 should equal 6'b000000 (in other words it is okay to 
+//    ignore the overflow)
+function [13:0] mmcm_pll_divider
+   (
+      input [7:0] divide,        // Max divide is 128
+      input [31:0] duty_cycle    // Duty cycle is multiplied by 100,000
+   );
+
+   reg [`FIXED_WIDTH:1]    duty_cycle_fix;
+   
+   // High/Low time is initially calculated with a wider integer to prevent a
+   // calculation error when it overflows to 64.
+   reg [6:0]               high_time;
+   reg [6:0]               low_time;
+   reg                     w_edge;
+   reg                     no_count;
+
+   reg [`FIXED_WIDTH:1]    temp;
+
+   begin
+      // Duty Cycle must be between 0 and 1,000
+      if(duty_cycle <=0 || duty_cycle >= 100000) begin
+`ifndef SYNTHESIS
+         $display("ERROR: duty_cycle: %d is invalid", duty_cycle);
+   `endif
+         $finish;
+      end
+
+      // Convert to FIXED_WIDTH-FRAC_PRECISION.FRAC_PRECISION fixed point
+      duty_cycle_fix = (duty_cycle << `FRAC_PRECISION) / 100_000;
+      
+   `ifdef DEBUG
+      $display("duty_cycle_fix: %h", duty_cycle_fix);
+   `endif
+
+      // If the divide is 1 nothing needs to be set except the no_count bit.
+      //    Other values are dummies
+      if(divide == 7'h01) begin
+         high_time   = 7'h01;
+         w_edge      = 1'b0;
+         low_time    = 7'h01;
+         no_count    = 1'b1;
+      end else begin
+         temp = round_frac(duty_cycle_fix*divide, 1);
+
+         // comes from above round_frac
+         high_time   = temp[`FRAC_PRECISION+7:`FRAC_PRECISION+1]; 
+         // If the duty cycle * divide rounded is .5 or greater then this bit
+         //    is set.
+         w_edge      = temp[`FRAC_PRECISION]; // comes from round_frac
+         
+         // If the high time comes out to 0, it needs to be set to at least 1
+         // and w_edge set to 0
+         if(high_time == 7'h00) begin
+            high_time   = 7'h01;
+            w_edge      = 1'b0;
+         end
+
+         if(high_time == divide) begin
+            high_time   = divide - 1;
+            w_edge      = 1'b1;
+         end
+         
+         // Calculate low_time based on the divide setting and set no_count to
+         //    0 as it is only used when divide is 1.
+         low_time    = divide - high_time; 
+         no_count    = 1'b0;
+      end
+
+      // Set the return value.
+      mmcm_pll_divider = {w_edge,no_count,high_time[5:0],low_time[5:0]};
+   end
+endfunction
+
+// This function calculates mx, delay_time, and phase_mux 
+//  of a non-fractional counter based on the divide and phase
+//
+// NOTE: The only valid value for the MX bits is 2'b00 to ensure the coarse mux
+//    is used.
+function [10:0] mmcm_pll_phase
+   (
+      // divide must be an integer (use fractional if not)
+      //  assumed that divide already checked to be valid
+      input [7:0] divide, // Max divide is 128
+
+      // Phase is given in degrees (-360,000 to 360,000)
+      input signed [31:0] phase
+   );
+
+   reg [`FIXED_WIDTH:1] phase_in_cycles;
+   reg [`FIXED_WIDTH:1] phase_fixed;
+   reg [1:0]            mx;
+   reg [5:0]            delay_time;
+   reg [2:0]            phase_mux;
+
+   reg [`FIXED_WIDTH:1] temp;
+
+   begin
+`ifdef DEBUG
+      $display("mmcm_pll_phase-divide:%d,phase:%d",
+         divide, phase);
+`endif
+   
+      if ((phase < -360000) || (phase > 360000)) begin
+`ifndef SYNTHESIS
+      $display("ERROR: phase of $phase is not between -360000 and 360000");
+	`endif
+         $finish;
+      end
+
+      // If phase is less than 0, convert it to a positive phase shift
+      // Convert to (FIXED_WIDTH-FRAC_PRECISION).FRAC_PRECISION fixed point
+      if(phase < 0) begin
+         phase_fixed = ( (phase + 360000) << `FRAC_PRECISION ) / 1000;
+      end else begin
+         phase_fixed = ( phase << `FRAC_PRECISION ) / 1000;
+      end
+
+      // Put phase in terms of decimal number of vco clock cycles
+      phase_in_cycles = ( phase_fixed * divide ) / 360;
+
+`ifdef DEBUG
+      $display("phase_in_cycles: %h", phase_in_cycles);
+`endif  
+      
+
+	 temp  =  round_frac(phase_in_cycles, 3);
+
+	 // set mx to 2'b00 that the phase mux from the VCO is enabled
+	 mx    			=  2'b00; 
+	 phase_mux      =  temp[`FRAC_PRECISION:`FRAC_PRECISION-2];
+	 delay_time     =  temp[`FRAC_PRECISION+6:`FRAC_PRECISION+1];
+      
+   `ifdef DEBUG
+      $display("temp: %h", temp);
+   `endif
+
+      // Setup the return value
+      mmcm_pll_phase={mx, phase_mux, delay_time};
+   end
+endfunction
+
+// This function takes the divide value and outputs the necessary lock values
+function [39:0] mmcm_pll_lock_lookup
+   (
+      input [6:0] divide // Max divide is 64
+   );
+   
+   reg [2559:0]   lookup;
+   
+   begin
+      lookup = {
+         // This table is composed of:
+         // LockRefDly_LockFBDly_LockCnt_LockSatHigh_UnlockCnt
+         40'b00110_00110_1111101000_1111101001_0000000001,
+         40'b00110_00110_1111101000_1111101001_0000000001,
+         40'b01000_01000_1111101000_1111101001_0000000001,
+         40'b01011_01011_1111101000_1111101001_0000000001,
+         40'b01110_01110_1111101000_1111101001_0000000001,
+         40'b10001_10001_1111101000_1111101001_0000000001,
+         40'b10011_10011_1111101000_1111101001_0000000001,
+         40'b10110_10110_1111101000_1111101001_0000000001,
+         40'b11001_11001_1111101000_1111101001_0000000001,
+         40'b11100_11100_1111101000_1111101001_0000000001,
+         40'b11111_11111_1110000100_1111101001_0000000001,
+         40'b11111_11111_1100111001_1111101001_0000000001,
+         40'b11111_11111_1011101110_1111101001_0000000001,
+         40'b11111_11111_1010111100_1111101001_0000000001,
+         40'b11111_11111_1010001010_1111101001_0000000001,
+         40'b11111_11111_1001110001_1111101001_0000000001,
+         40'b11111_11111_1000111111_1111101001_0000000001,
+         40'b11111_11111_1000100110_1111101001_0000000001,
+         40'b11111_11111_1000001101_1111101001_0000000001,
+         40'b11111_11111_0111110100_1111101001_0000000001,
+         40'b11111_11111_0111011011_1111101001_0000000001,
+         40'b11111_11111_0111000010_1111101001_0000000001,
+         40'b11111_11111_0110101001_1111101001_0000000001,
+         40'b11111_11111_0110010000_1111101001_0000000001,
+         40'b11111_11111_0110010000_1111101001_0000000001,
+         40'b11111_11111_0101110111_1111101001_0000000001,
+         40'b11111_11111_0101011110_1111101001_0000000001,
+         40'b11111_11111_0101011110_1111101001_0000000001,
+         40'b11111_11111_0101000101_1111101001_0000000001,
+         40'b11111_11111_0101000101_1111101001_0000000001,
+         40'b11111_11111_0100101100_1111101001_0000000001,
+         40'b11111_11111_0100101100_1111101001_0000000001,
+         40'b11111_11111_0100101100_1111101001_0000000001,
+         40'b11111_11111_0100010011_1111101001_0000000001,
+         40'b11111_11111_0100010011_1111101001_0000000001,
+         40'b11111_11111_0100010011_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001
+      };
+      
+      // Set lookup_entry with the explicit bits from lookup with a part select
+      mmcm_pll_lock_lookup = lookup[ ((64-divide)*40) +: 40];
+   `ifdef DEBUG
+      $display("lock_lookup: %b", mmcm_pll_lock_lookup);
+   `endif
+   end
+endfunction
+
+// This function takes the divide value and the bandwidth setting of the MMCM
+//  and outputs the digital filter settings necessary.
+function [9:0] mmcm_pll_filter_lookup
+   (
+      input [6:0] divide, // Max divide is 64
+      input [8*9:0] BANDWIDTH
+   );
+   
+   reg [639:0] lookup_low;
+   reg [639:0] lookup_high;
+   
+   reg [9:0] lookup_entry;
+   
+   begin
+      lookup_low = {
+         // CP_RES_LFHF
+         10'b0010_1111_00,
+         10'b0010_1111_00,
+         10'b0010_1111_00,
+         10'b0010_1111_00,
+         10'b0010_0111_00,
+         10'b0010_1011_00,
+         10'b0010_1101_00,
+         10'b0010_0011_00,
+         10'b0010_0101_00,
+         10'b0010_0101_00,
+         10'b0010_1001_00,
+         10'b0010_1110_00,
+         10'b0010_1110_00,
+         10'b0010_1110_00,
+         10'b0010_1110_00,
+         10'b0010_0001_00,
+         10'b0010_0001_00,
+         10'b0010_0001_00,
+         10'b0010_0110_00,
+         10'b0010_0110_00,
+         10'b0010_0110_00,
+         10'b0010_0110_00,
+         10'b0010_0110_00,
+         10'b0010_0110_00,
+         10'b0010_0110_00,
+         10'b0010_1010_00,
+         10'b0010_1010_00,
+         10'b0010_1010_00,
+         10'b0010_1010_00,
+         10'b0010_1010_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00
+      };
+      
+      lookup_high = {
+         // CP_RES_LFHF
+         10'b0010_1111_00,
+         10'b0100_1111_00,
+         10'b0101_1011_00,
+         10'b0111_0111_00,
+         10'b1101_0111_00,
+         10'b1110_1011_00,
+         10'b1110_1101_00,
+         10'b1111_0011_00,
+         10'b1110_0101_00,
+         10'b1111_0101_00,
+         10'b1111_1001_00,
+         10'b1101_0001_00,
+         10'b1111_1001_00,
+         10'b1111_1001_00,
+         10'b1111_1001_00,
+         10'b1111_1001_00,
+         10'b1111_0101_00,
+         10'b1111_0101_00,
+         10'b1100_0001_00,
+         10'b1100_0001_00,
+         10'b1100_0001_00,
+         10'b0101_1100_00,
+         10'b0101_1100_00,
+         10'b0101_1100_00,
+         10'b0101_1100_00,
+         10'b0011_0100_00,
+         10'b0011_0100_00,
+         10'b0011_0100_00,
+         10'b0011_0100_00,
+         10'b0011_0100_00,
+         10'b0011_0100_00,
+         10'b0011_0100_00,
+         10'b0011_0100_00,
+         10'b0011_0100_00,
+         10'b0011_0100_00,
+         10'b0011_0100_00,
+         10'b0011_0100_00,
+         10'b0011_0100_00,
+         10'b0011_0100_00,
+         10'b0011_0100_00,
+         10'b0011_0100_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0111_0001_00,
+         10'b0111_0001_00,
+         10'b0100_1100_00,
+         10'b0100_1100_00,
+         10'b0100_1100_00,
+         10'b0100_1100_00,
+         10'b0110_0001_00,
+         10'b0110_0001_00,
+         10'b0101_0110_00,
+         10'b0101_0110_00,
+         10'b0101_0110_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0100_1010_00,
+         10'b0011_1100_00,
+         10'b0011_1100_00
+      };
+      
+      // Set lookup_entry with the explicit bits from lookup with a part select
+      if(BANDWIDTH == "LOW") begin
+         // Low Bandwidth
+         mmcm_pll_filter_lookup = lookup_low[ ((64-divide)*10) +: 10];
+      end else begin
+         // High or optimized bandwidth
+         mmcm_pll_filter_lookup = lookup_high[ ((64-divide)*10) +: 10];
+      end
+      
+   `ifdef DEBUG
+      $display("filter_lookup: %b", mmcm_pll_filter_lookup);
+   `endif
+   end
+endfunction
+
+// This function takes in the divide, phase, and duty cycle
+// setting to calculate the upper and lower counter registers.
+function [37:0] mmcm_pll_count_calc
+   (
+      input [7:0] divide, // Max divide is 128
+      input signed [31:0] phase,
+      input [31:0] duty_cycle // Multiplied by 100,000
+   );
+   
+   reg [13:0] div_calc;
+   reg [16:0] phase_calc;
+   
+   begin
+   `ifdef DEBUG
+      $display("mmcm_pll_count_calc- divide:%h, phase:%d, duty_cycle:%d",
+         divide, phase, duty_cycle);
+   `endif
+   
+      // w_edge[13], no_count[12], high_time[11:6], low_time[5:0]
+      div_calc = mmcm_pll_divider(divide, duty_cycle);
+      // mx[10:9], pm[8:6], dt[5:0]
+      phase_calc = mmcm_pll_phase(divide, phase);
+
+      // Return value is the upper and lower address of counter
+      //    Upper address is:
+      //       RESERVED    [31:26]
+      //       MX          [25:24]
+      //       EDGE        [23]
+      //       NOCOUNT     [22]
+      //       DELAY_TIME  [21:16]
+      //    Lower Address is:
+      //       PHASE_MUX   [15:13]
+      //       RESERVED    [12]
+      //       HIGH_TIME   [11:6]
+      //       LOW_TIME    [5:0]
+      
+   `ifdef DEBUG
+      $display("div:%d dc:%d phase:%d ht:%d lt:%d ed:%d nc:%d mx:%d dt:%d pm:%d",
+         divide, duty_cycle, phase, div_calc[11:6], div_calc[5:0], 
+         div_calc[13], div_calc[12], 
+         phase_calc[16:15], phase_calc[5:0], phase_calc[14:12]);
+   `endif
+      
+      mmcm_pll_count_calc =
+         {
+            // Upper Address
+            6'h00, phase_calc[10:9], div_calc[13:12], phase_calc[5:0], 
+            // Lower Address
+            phase_calc[8:6], 1'b0, div_calc[11:0]
+         };
+   end
+endfunction
+
+
+// This function takes in the divide, phase, and duty cycle
+// setting to calculate the upper and lower counter registers.
+// for fractional multiply/divide functions.
+//
+// 
+function [37:0] mmcm_frac_count_calc
+   (
+      input [7:0] divide, // Max divide is 128
+      input signed [31:0] phase,
+      input [31:0] duty_cycle, // Multiplied by 1,000
+      input [9:0] frac // Multiplied by 1000
+   );
+   
+	//Required for fractional divide calculations
+			  reg	[7:0]			lt_frac;
+			  reg	[7:0]			ht_frac;
+			
+			  reg	/*[7:0]*/			wf_fall_frac;
+			  reg	/*[7:0]*/			wf_rise_frac;
+
+			  reg [31:0] a;
+			  reg	[7:0]			pm_rise_frac_filtered ;
+			  reg	[7:0]			pm_fall_frac_filtered ;	
+			  reg [7:0]			clkout0_divide_int;
+			  reg [2:0]			clkout0_divide_frac;
+			  reg	[7:0]			even_part_high;
+			  reg	[7:0]			even_part_low;
+
+			  reg	[7:0]			odd;
+			  reg	[7:0]			odd_and_frac;
+
+			  reg	[7:0]			pm_fall;
+			  reg	[7:0]			pm_rise;
+			  reg	[7:0]			dt;
+			  reg	[7:0]			dt_int; 
+			  reg [63:0]		dt_calc;
+
+			  reg	[7:0]			pm_rise_frac; 
+			  reg	[7:0]			pm_fall_frac;
+	 
+			  reg [31:0] a_per_in_octets;
+			  reg [31:0] a_phase_in_cycles;
+
+				parameter precision = 0.125;
+
+			  reg [31:0] phase_fixed; // changed to 31:0 from 32:1 jt 5/2/11
+			  reg [31: 0] phase_pos;
+			  reg [31: 0] phase_vco;
+			  reg [31:0] temp;// changed to 31:0 from 32:1 jt 5/2/11
+			  reg [13:0] div_calc;
+			  reg [16:0] phase_calc;
+
+   begin
+	`ifdef DEBUG
+			$display("mmcm_frac_count_calc- divide:%h, phase:%d, duty_cycle:%d",
+				divide, phase, duty_cycle);
+	`endif
+   
+   //convert phase to fixed
+   if ((phase < -360000) || (phase > 360000)) begin
+`ifndef SYNTHESIS
+      $display("ERROR: phase of $phase is not between -360000 and 360000");
+	`endif
+      $finish;
+   end
+
+
+      // Return value is
+      //    Transfer data
+      //       RESERVED     [37:36]
+      //       FRAC_TIME    [35:33]
+      //       FRAC_WF_FALL [32]
+      //    Upper address is:
+      //       RESERVED     [31:26]
+      //       MX           [25:24]
+      //       EDGE         [23]
+      //       NOCOUNT      [22]
+      //       DELAY_TIME   [21:16]
+      //    Lower Address is:
+      //       PHASE_MUX    [15:13]
+      //       RESERVED     [12]
+      //       HIGH_TIME    [11:6]
+      //       LOW_TIME     [5:0]
+      
+      
+
+	clkout0_divide_frac = frac / 125;
+	clkout0_divide_int = divide;
+
+	even_part_high = clkout0_divide_int >> 1;//$rtoi(clkout0_divide_int / 2);
+	even_part_low = even_part_high;
+									
+	odd = clkout0_divide_int - even_part_high - even_part_low;
+	odd_and_frac = (8*odd) + clkout0_divide_frac;
+
+	lt_frac = even_part_high - (odd_and_frac <= 9);//IF(odd_and_frac>9,even_part_high, even_part_high - 1)
+	ht_frac = even_part_low  - (odd_and_frac <= 8);//IF(odd_and_frac>8,even_part_low, even_part_low- 1)
+
+	pm_fall =  {odd[6:0],2'b00} + {6'h00, clkout0_divide_frac[2:1]}; // using >> instead of clkout0_divide_frac / 2 
+	pm_rise = 0; //0
+    
+	wf_fall_frac = ((odd_and_frac >=2) && (odd_and_frac <=9)) || ((clkout0_divide_frac == 1) && (clkout0_divide_int == 2));//CRS610807
+	wf_rise_frac = (odd_and_frac >=1) && (odd_and_frac <=8);//IF(odd_and_frac>=1,IF(odd_and_frac <= 8,1,0),0)
+
+
+
+	//Calculate phase in fractional cycles
+	a_per_in_octets		= (8 * divide) + (frac / 125) ;
+	a_phase_in_cycles	= (phase+10) * a_per_in_octets / 360000 ;//Adding 1 due to rounding errors
+	pm_rise_frac		= (a_phase_in_cycles[7:0] ==8'h00)?8'h00:a_phase_in_cycles[7:0] - {a_phase_in_cycles[7:3],3'b000};
+
+	dt_calc 	= ((phase+10) * a_per_in_octets / 8 )/360000 ;//TRUNC(phase* divide / 360); //or_simply (a_per_in_octets / 8)
+	dt 	= dt_calc[7:0];
+
+	pm_rise_frac_filtered = (pm_rise_frac >=8) ? (pm_rise_frac ) - 8: pm_rise_frac ;				//((phase_fixed * (divide + frac / 1000)) / 360) - {pm_rise_frac[7:3],3'b000};//$rtoi(clkout0_phase * clkout0_divide / 45);//a;
+
+	dt_int			= dt + (& pm_rise_frac[7:4]); //IF(pm_rise_overwriting>7,dt+1,dt)
+	pm_fall_frac		= pm_fall + pm_rise_frac;
+	pm_fall_frac_filtered	= pm_fall + pm_rise_frac - {pm_fall_frac[7:3], 3'b000};
+
+	div_calc	= mmcm_pll_divider(divide, duty_cycle); //Use to determine edge[7], no count[6]
+	phase_calc	= mmcm_pll_phase(divide, phase);// returns{mx[1:0], phase_mux[2:0], delay_time[5:0]}
+		
+      mmcm_frac_count_calc[37:0] =
+         {		2'b00, pm_fall_frac_filtered[2:0], wf_fall_frac,
+			1'b0, clkout0_divide_frac[2:0], 1'b1, wf_rise_frac, phase_calc[10:9], div_calc[13:12], dt[5:0], 
+			pm_rise_frac_filtered[2], pm_rise_frac_filtered[1], pm_rise_frac_filtered[0], 1'b0, ht_frac[5:0], lt_frac[5:0]
+		} ;
+
+   `ifdef DEBUG
+      $display("-%d.%d p%d>>  :DADDR_9_15 frac30to28.frac_en.wf_r_frac.dt:%b%d%d_%b:DADDR_7_13 pm_f_frac_filtered_29to27.wf_f_frac_26:%b%d:DADDR_8_14.pm_r_frac_filt_15to13.ht_frac.lt_frac:%b%b%b:", divide, frac, phase, clkout0_divide_frac, 1, wf_rise_frac, dt, pm_fall_frac_filtered, wf_fall_frac, pm_rise_frac_filtered, ht_frac, lt_frac);
+   `endif
+
+   end
+endfunction
+
diff --git a/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_7s_pll.vh b/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_7s_pll.vh
new file mode 100755
index 000000000..6a3e7c08c
--- /dev/null
+++ b/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_7s_pll.vh
@@ -0,0 +1,531 @@
+///////////////////////////////////////////////////////////////////////////////
+//    
+//    Company:          Xilinx
+//    Engineer:         Jim Tatsukawa, Karl Kurbjun and Carl Ribbing
+//    Date:             7/30/2014
+//    Design Name:      PLLE2 DRP
+//    Module Name:      plle2_drp_func.h
+//    Version:          2.00
+//    Target Devices:   7 Series || PLL
+//    Tool versions:    2014.3
+//    Description:      This header provides the functions necessary to  
+//                      calculate the DRP register values for the V6 PLL.
+//                      Updated for CR663854.
+// 
+//    Disclaimer:  XILINX IS PROVIDING THIS DESIGN, CODE, OR
+//                 INFORMATION "AS IS" SOLELY FOR USE IN DEVELOPING
+//                 PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY
+//                 PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+//                 ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+//                 APPLICATION OR STANDARD, XILINX IS MAKING NO
+//                 REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+//                 FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE
+//                 RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY
+//                 REQUIRE FOR YOUR IMPLEMENTATION.  XILINX
+//                 EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH
+//                 RESPECT TO THE ADEQUACY OF THE IMPLEMENTATION,
+//                 INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+//                 REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE
+//                 FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES
+//                 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+//                 PURPOSE.
+// 
+//                 (c) Copyright 2009-2010 Xilinx, Inc.
+//                 All rights reserved.
+// 
+///////////////////////////////////////////////////////////////////////////////
+
+// These are user functions that should not be modified.  Changes to the defines
+// or code within the functions may alter the accuracy of the calculations.
+
+// Define debug to provide extra messages durring elaboration
+//`define DEBUG 1
+
+// FRAC_PRECISION describes the width of the fractional portion of the fixed
+//    point numbers.  These should not be modified, they are for development 
+//    only
+`define FRAC_PRECISION  10
+// FIXED_WIDTH describes the total size for fixed point calculations(int+frac).
+// Warning: L.50 and below will not calculate properly with FIXED_WIDTHs 
+//    greater than 32
+`define FIXED_WIDTH     32 
+
+// This function takes a fixed point number and rounds it to the nearest
+//    fractional precision bit.
+function [`FIXED_WIDTH:1] round_frac
+   (
+      // Input is (FIXED_WIDTH-FRAC_PRECISION).FRAC_PRECISION fixed point number
+      input [`FIXED_WIDTH:1] decimal,  
+
+      // This describes the precision of the fraction, for example a value
+      //    of 1 would modify the fractional so that instead of being a .16
+      //    fractional, it would be a .1 (rounded to the nearest 0.5 in turn)
+      input [`FIXED_WIDTH:1] precision 
+   );
+
+   begin
+   
+`ifdef DEBUG
+      $display("round_frac - decimal: %h, precision: %h", decimal, precision);
+`endif
+      // If the fractional precision bit is high then round up
+      if( decimal[(`FRAC_PRECISION-precision)] == 1'b1) begin
+         round_frac = decimal + (1'b1 << (`FRAC_PRECISION-precision));
+      end else begin
+         round_frac = decimal;
+      end
+`ifdef DEBUG
+      $display("round_frac: %h", round_frac);
+`endif
+   end
+endfunction
+
+// This function calculates high_time, low_time, w_edge, and no_count
+//    of a non-fractional counter based on the divide and duty cycle
+//
+// NOTE: high_time and low_time are returned as integers between 0 and 63 
+//    inclusive.  64 should equal 6'b000000 (in other words it is okay to 
+//    ignore the overflow)
+function [13:0] mmcm_pll_divider
+   (
+      input [7:0] divide,        // Max divide is 128
+      input [31:0] duty_cycle    // Duty cycle is multiplied by 100,000
+   );
+
+   reg [`FIXED_WIDTH:1]    duty_cycle_fix;
+   
+   // High/Low time is initially calculated with a wider integer to prevent a
+   // calculation error when it overflows to 64.
+   reg [6:0]               high_time;
+   reg [6:0]               low_time;
+   reg                     w_edge;
+   reg                     no_count;
+
+   reg [`FIXED_WIDTH:1]    temp;
+
+   begin
+      // Duty Cycle must be between 0 and 1,000
+      if(duty_cycle <=0 || duty_cycle >= 100000) begin
+`ifndef SYNTHESIS
+         $display("ERROR: duty_cycle: %d is invalid", duty_cycle);
+   `endif
+         $finish;
+      end
+
+      // Convert to FIXED_WIDTH-FRAC_PRECISION.FRAC_PRECISION fixed point
+      duty_cycle_fix = (duty_cycle << `FRAC_PRECISION) / 100_000;
+      
+`ifdef DEBUG
+      $display("duty_cycle_fix: %h", duty_cycle_fix);
+`endif
+
+      // If the divide is 1 nothing needs to be set except the no_count bit.
+      //    Other values are dummies
+      if(divide == 7'h01) begin
+         high_time   = 7'h01;
+         w_edge      = 1'b0;
+         low_time    = 7'h01;
+         no_count    = 1'b1;
+      end else begin
+         temp = round_frac(duty_cycle_fix*divide, 1);
+
+         // comes from above round_frac
+         high_time   = temp[`FRAC_PRECISION+7:`FRAC_PRECISION+1]; 
+         // If the duty cycle * divide rounded is .5 or greater then this bit
+         //    is set.
+         w_edge      = temp[`FRAC_PRECISION]; // comes from round_frac
+         
+         // If the high time comes out to 0, it needs to be set to at least 1
+         // and w_edge set to 0
+         if(high_time == 7'h00) begin
+            high_time   = 7'h01;
+            w_edge      = 1'b0;
+         end
+
+         if(high_time == divide) begin
+            high_time   = divide - 1;
+            w_edge      = 1'b1;
+         end
+         
+         // Calculate low_time based on the divide setting and set no_count to
+         //    0 as it is only used when divide is 1.
+         low_time    = divide - high_time; 
+         no_count    = 1'b0;
+      end
+
+      // Set the return value.
+      mmcm_pll_divider = {w_edge,no_count,high_time[5:0],low_time[5:0]};
+   end
+endfunction
+
+// This function calculates mx, delay_time, and phase_mux 
+//  of a non-fractional counter based on the divide and phase
+//
+// NOTE: The only valid value for the MX bits is 2'b00 to ensure the coarse mux
+//    is used.
+function [10:0] mmcm_pll_phase
+   (
+      // divide must be an integer (use fractional if not)
+      //  assumed that divide already checked to be valid
+      input [7:0] divide, // Max divide is 128
+
+      // Phase is given in degrees (-360,000 to 360,000)
+      input signed [31:0] phase
+   );
+
+   reg [`FIXED_WIDTH:1] phase_in_cycles;
+   reg [`FIXED_WIDTH:1] phase_fixed;
+   reg [1:0]            mx;
+   reg [5:0]            delay_time;
+   reg [2:0]            phase_mux;
+
+   reg [`FIXED_WIDTH:1] temp;
+
+   begin
+`ifdef DEBUG
+      $display("mmcm_pll_phase-divide:%d,phase:%d",
+         divide, phase);
+`endif
+   
+      if ((phase < -360000) || (phase > 360000)) begin
+`ifndef SYNTHESIS
+      $display("ERROR: phase of $phase is not between -360000 and 360000");
+	`endif
+         $finish;
+      end
+
+      // If phase is less than 0, convert it to a positive phase shift
+      // Convert to (FIXED_WIDTH-FRAC_PRECISION).FRAC_PRECISION fixed point
+      if(phase < 0) begin
+         phase_fixed = ( (phase + 360000) << `FRAC_PRECISION ) / 1000;
+      end else begin
+         phase_fixed = ( phase << `FRAC_PRECISION ) / 1000;
+      end
+
+      // Put phase in terms of decimal number of vco clock cycles
+      phase_in_cycles = ( phase_fixed * divide ) / 360;
+
+`ifdef DEBUG
+      $display("phase_in_cycles: %h", phase_in_cycles);
+`endif  
+      
+
+	 temp  =  round_frac(phase_in_cycles, 3);
+
+	 // set mx to 2'b00 that the phase mux from the VCO is enabled
+	 mx    			=  2'b00; 
+	 phase_mux      =  temp[`FRAC_PRECISION:`FRAC_PRECISION-2];
+	 delay_time     =  temp[`FRAC_PRECISION+6:`FRAC_PRECISION+1];
+      
+`ifdef DEBUG
+      $display("temp: %h", temp);
+`endif
+
+      // Setup the return value
+      mmcm_pll_phase={mx, phase_mux, delay_time};
+   end
+endfunction
+
+// This function takes the divide value and outputs the necessary lock values
+function [39:0] mmcm_pll_lock_lookup
+   (
+      input [6:0] divide // Max divide is 64
+   );
+   
+   reg [2559:0]   lookup;
+   
+   begin
+      lookup = {
+         // This table is composed of:
+         // LockRefDly_LockFBDly_LockCnt_LockSatHigh_UnlockCnt
+         40'b00110_00110_1111101000_1111101001_0000000001,
+         40'b00110_00110_1111101000_1111101001_0000000001,
+         40'b01000_01000_1111101000_1111101001_0000000001,
+         40'b01011_01011_1111101000_1111101001_0000000001,
+         40'b01110_01110_1111101000_1111101001_0000000001,
+         40'b10001_10001_1111101000_1111101001_0000000001,
+         40'b10011_10011_1111101000_1111101001_0000000001,
+         40'b10110_10110_1111101000_1111101001_0000000001,
+         40'b11001_11001_1111101000_1111101001_0000000001,
+         40'b11100_11100_1111101000_1111101001_0000000001,
+         40'b11111_11111_1110000100_1111101001_0000000001,
+         40'b11111_11111_1100111001_1111101001_0000000001,
+         40'b11111_11111_1011101110_1111101001_0000000001,
+         40'b11111_11111_1010111100_1111101001_0000000001,
+         40'b11111_11111_1010001010_1111101001_0000000001,
+         40'b11111_11111_1001110001_1111101001_0000000001,
+         40'b11111_11111_1000111111_1111101001_0000000001,
+         40'b11111_11111_1000100110_1111101001_0000000001,
+         40'b11111_11111_1000001101_1111101001_0000000001,
+         40'b11111_11111_0111110100_1111101001_0000000001,
+         40'b11111_11111_0111011011_1111101001_0000000001,
+         40'b11111_11111_0111000010_1111101001_0000000001,
+         40'b11111_11111_0110101001_1111101001_0000000001,
+         40'b11111_11111_0110010000_1111101001_0000000001,
+         40'b11111_11111_0110010000_1111101001_0000000001,
+         40'b11111_11111_0101110111_1111101001_0000000001,
+         40'b11111_11111_0101011110_1111101001_0000000001,
+         40'b11111_11111_0101011110_1111101001_0000000001,
+         40'b11111_11111_0101000101_1111101001_0000000001,
+         40'b11111_11111_0101000101_1111101001_0000000001,
+         40'b11111_11111_0100101100_1111101001_0000000001,
+         40'b11111_11111_0100101100_1111101001_0000000001,
+         40'b11111_11111_0100101100_1111101001_0000000001,
+         40'b11111_11111_0100010011_1111101001_0000000001,
+         40'b11111_11111_0100010011_1111101001_0000000001,
+         40'b11111_11111_0100010011_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001
+      };
+      
+      // Set lookup_entry with the explicit bits from lookup with a part select
+      mmcm_pll_lock_lookup = lookup[ ((64-divide)*40) +: 40];
+   `ifdef DEBUG
+      $display("lock_lookup: %b", mmcm_pll_lock_lookup);
+   `endif
+   end
+endfunction
+
+// This function takes the divide value and the bandwidth setting of the PLL
+//  and outputs the digital filter settings necessary.
+function [9:0] mmcm_pll_filter_lookup
+   (
+      input [6:0] divide, // Max divide is 64
+      input [8*9:0] BANDWIDTH
+   );
+   
+   reg [639:0] lookup_low;
+   reg [639:0] lookup_high;
+   
+   reg [9:0] lookup_entry;
+   
+   begin
+      lookup_low = {
+         // CP_RES_LFHF
+         10'b0010_1111_00,
+         10'b0010_1111_00,
+         10'b0010_0111_00,
+         10'b0010_1101_00,
+         10'b0010_0101_00,
+         10'b0010_0101_00,
+         10'b0010_1001_00,
+         10'b0010_1110_00,
+         10'b0010_1110_00,
+         10'b0010_0001_00,
+         10'b0010_0001_00,
+         10'b0010_0110_00,
+         10'b0010_0110_00,
+         10'b0010_0110_00,
+         10'b0010_0110_00,
+         10'b0010_1010_00,
+         10'b0010_1010_00,
+         10'b0010_1010_00,
+         10'b0010_1010_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_1100_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0010_0010_00,
+         10'b0011_1100_00,
+         10'b0011_1100_00,
+         10'b0011_1100_00,
+         10'b0011_1100_00,
+         10'b0011_1100_00,
+         10'b0011_1100_00,
+         10'b0011_1100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00
+      };
+      
+      lookup_high = {
+         // CP_RES_LFHF
+         10'b0011_0111_00,
+         10'b0011_0111_00,
+         10'b0101_1111_00,
+         10'b0111_1111_00,
+         10'b0111_1011_00,
+         10'b1101_0111_00,
+         10'b1110_1011_00,
+         10'b1110_1101_00,
+         10'b1111_1101_00,
+         10'b1111_0111_00,
+         10'b1111_1011_00,
+         10'b1111_1101_00,
+         10'b1111_0011_00,
+         10'b1110_0101_00,
+         10'b1111_0101_00,
+         10'b1111_0101_00,
+         10'b1111_0101_00,
+         10'b1111_0101_00,
+         10'b0111_0110_00,
+         10'b0111_0110_00,
+         10'b0111_0110_00,
+         10'b0111_0110_00,
+         10'b0101_1100_00,
+         10'b0101_1100_00,
+         10'b0101_1100_00,
+         10'b1100_0001_00,
+         10'b1100_0001_00,
+         10'b1100_0001_00,
+         10'b1100_0001_00,
+         10'b1100_0001_00,
+         10'b1100_0001_00,
+         10'b1100_0001_00,
+         10'b1100_0001_00,
+         10'b0100_0010_00,
+         10'b0100_0010_00,
+         10'b0100_0010_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0011_0100_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0010_1000_00,
+         10'b0100_1100_00,
+         10'b0100_1100_00,
+         10'b0100_1100_00,
+         10'b0100_1100_00,
+         10'b0100_1100_00,
+         10'b0100_1100_00,
+         10'b0100_1100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00,
+         10'b0010_0100_00
+      };
+      
+      // Set lookup_entry with the explicit bits from lookup with a part select
+      if(BANDWIDTH == "LOW") begin
+         // Low Bandwidth
+         mmcm_pll_filter_lookup = lookup_low[ ((64-divide)*10) +: 10];
+      end else begin
+         // High or optimized bandwidth
+         mmcm_pll_filter_lookup = lookup_high[ ((64-divide)*10) +: 10];
+      end
+      
+   `ifdef DEBUG
+      $display("filter_lookup: %b", mmcm_pll_filter_lookup);
+   `endif
+   end
+endfunction
+
+// This function takes in the divide, phase, and duty cycle
+// setting to calculate the upper and lower counter registers.
+function [37:0] mmcm_pll_count_calc
+   (
+      input [7:0] divide, // Max divide is 128
+      input signed [31:0] phase,
+      input [31:0] duty_cycle // Multiplied by 100,000
+   );
+   
+   reg [13:0] div_calc;
+   reg [16:0] phase_calc;
+   
+   begin
+   `ifdef DEBUG
+      $display("mmcm_pll_count_calc- divide:%h, phase:%d, duty_cycle:%d",
+         divide, phase, duty_cycle);
+`endif
+   
+      // w_edge[13], no_count[12], high_time[11:6], low_time[5:0]
+      div_calc = mmcm_pll_divider(divide, duty_cycle);
+      // mx[10:9], pm[8:6], dt[5:0]
+      phase_calc = mmcm_pll_phase(divide, phase);
+
+      // Return value is the upper and lower address of counter
+      //    Upper address is:
+      //       RESERVED    [31:26]
+      //       MX          [25:24]
+      //       EDGE        [23]
+      //       NOCOUNT     [22]
+      //       DELAY_TIME  [21:16]
+      //    Lower Address is:
+      //       PHASE_MUX   [15:13]
+      //       RESERVED    [12]
+      //       HIGH_TIME   [11:6]
+      //       LOW_TIME    [5:0]
+      
+`ifdef DEBUG
+      $display("div:%d dc:%d phase:%d ht:%d lt:%d ed:%d nc:%d mx:%d dt:%d pm:%d",
+         divide, duty_cycle, phase, div_calc[11:6], div_calc[5:0], 
+         div_calc[13], div_calc[12], 
+         phase_calc[16:15], phase_calc[5:0], phase_calc[14:12]);
+`endif
+      
+      mmcm_pll_count_calc =
+         {
+            // Upper Address
+            6'h00, phase_calc[10:9], div_calc[13:12], phase_calc[5:0], 
+            // Lower Address
+            phase_calc[8:6], 1'b0, div_calc[11:0]
+         };
+   end
+endfunction
diff --git a/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_us_mmcm.vh b/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_us_mmcm.vh
new file mode 100755
index 000000000..2cffa9a76
--- /dev/null
+++ b/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_us_mmcm.vh
@@ -0,0 +1,671 @@
+///////////////////////////////////////////////////////////////////////////////
+//    
+//    Company:          Xilinx
+//    Engineer:         Jim Tatsukawa
+//    Date:             7/30/2014
+//    Design Name:      MMCME2 DRP
+//    Module Name:      mmcme2_drp_func.h
+//    Version:          1.04
+//    Target Devices:   UltraScale Architecture || MMCM 
+//    Tool versions:    2014.3
+//    Description:      This header provides the functions necessary to  
+//                      calculate the DRP register values for the V6 MMCM.
+//                      
+//	Revision Notes:	3/22 - Updating lookup_low/lookup_high (CR)
+//				4/13 - Fractional divide function in mmcm_frac_count_calc function. CRS610807
+// 
+//    Disclaimer:  XILINX IS PROVIDING THIS DESIGN, CODE, OR
+//                 INFORMATION "AS IS" SOLELY FOR USE IN DEVELOPING
+//                 PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY
+//                 PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+//                 ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+//                 APPLICATION OR STANDARD, XILINX IS MAKING NO
+//                 REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+//                 FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE
+//                 RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY
+//                 REQUIRE FOR YOUR IMPLEMENTATION.  XILINX
+//                 EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH
+//                 RESPECT TO THE ADEQUACY OF THE IMPLEMENTATION,
+//                 INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+//                 REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE
+//                 FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES
+//                 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+//                 PURPOSE.
+// 
+//                 (c) Copyright 2009-2010 Xilinx, Inc.
+//                 All rights reserved.
+// 
+///////////////////////////////////////////////////////////////////////////////
+
+// These are user functions that should not be modified.  Changes to the defines
+// or code within the functions may alter the accuracy of the calculations.
+
+// Define debug to provide extra messages durring elaboration
+//`define DEBUG 1
+
+// FRAC_PRECISION describes the width of the fractional portion of the fixed
+//    point numbers.  These should not be modified, they are for development 
+//    only
+`define FRAC_PRECISION  10
+// FIXED_WIDTH describes the total size for fixed point calculations(int+frac).
+// Warning: L.50 and below will not calculate properly with FIXED_WIDTHs 
+//    greater than 32
+`define FIXED_WIDTH     32 
+
+// This function takes a fixed point number and rounds it to the nearest
+//    fractional precision bit.
+function [`FIXED_WIDTH:1] round_frac
+   (
+      // Input is (FIXED_WIDTH-FRAC_PRECISION).FRAC_PRECISION fixed point number
+      input [`FIXED_WIDTH:1] decimal,  
+
+      // This describes the precision of the fraction, for example a value
+      //    of 1 would modify the fractional so that instead of being a .16
+      //    fractional, it would be a .1 (rounded to the nearest 0.5 in turn)
+      input [`FIXED_WIDTH:1] precision 
+   );
+
+   begin
+   
+   `ifdef DEBUG
+      $display("round_frac - decimal: %h, precision: %h", decimal, precision);
+   `endif
+      // If the fractional precision bit is high then round up
+      if( decimal[(`FRAC_PRECISION-precision)] == 1'b1) begin
+         round_frac = decimal + (1'b1 << (`FRAC_PRECISION-precision));
+      end else begin
+         round_frac = decimal;
+      end
+   `ifdef DEBUG
+      $display("round_frac: %h", round_frac);
+   `endif
+   end
+endfunction
+
+// This function calculates high_time, low_time, w_edge, and no_count
+//    of a non-fractional counter based on the divide and duty cycle
+//
+// NOTE: high_time and low_time are returned as integers between 0 and 63 
+//    inclusive.  64 should equal 6'b000000 (in other words it is okay to 
+//    ignore the overflow)
+function [13:0] mmcm_pll_divider
+   (
+      input [7:0] divide,        // Max divide is 128
+      input [31:0] duty_cycle    // Duty cycle is multiplied by 100,000
+   );
+
+   reg [`FIXED_WIDTH:1]    duty_cycle_fix;
+   
+   // High/Low time is initially calculated with a wider integer to prevent a
+   // calculation error when it overflows to 64.
+   reg [6:0]               high_time;
+   reg [6:0]               low_time;
+   reg                     w_edge;
+   reg                     no_count;
+
+   reg [`FIXED_WIDTH:1]    temp;
+
+   begin
+      // Duty Cycle must be between 0 and 1,000
+      if(duty_cycle <=0 || duty_cycle >= 100000) begin
+`ifndef SYNTHESIS
+         $display("ERROR: duty_cycle: %d is invalid", duty_cycle);
+   `endif
+         $finish;
+      end
+
+      // Convert to FIXED_WIDTH-FRAC_PRECISION.FRAC_PRECISION fixed point
+      duty_cycle_fix = (duty_cycle << `FRAC_PRECISION) / 100_000;
+      
+   `ifdef DEBUG
+      $display("duty_cycle_fix: %h", duty_cycle_fix);
+   `endif
+
+      // If the divide is 1 nothing needs to be set except the no_count bit.
+      //    Other values are dummies
+      if(divide == 7'h01) begin
+         high_time   = 7'h01;
+         w_edge      = 1'b0;
+         low_time    = 7'h01;
+         no_count    = 1'b1;
+      end else begin
+         temp = round_frac(duty_cycle_fix*divide, 1);
+
+         // comes from above round_frac
+         high_time   = temp[`FRAC_PRECISION+7:`FRAC_PRECISION+1]; 
+         // If the duty cycle * divide rounded is .5 or greater then this bit
+         //    is set.
+         w_edge      = temp[`FRAC_PRECISION]; // comes from round_frac
+         
+         // If the high time comes out to 0, it needs to be set to at least 1
+         // and w_edge set to 0
+         if(high_time == 7'h00) begin
+            high_time   = 7'h01;
+            w_edge      = 1'b0;
+         end
+
+         if(high_time == divide) begin
+            high_time   = divide - 1;
+            w_edge      = 1'b1;
+         end
+         
+         // Calculate low_time based on the divide setting and set no_count to
+         //    0 as it is only used when divide is 1.
+         low_time    = divide - high_time; 
+         no_count    = 1'b0;
+      end
+
+      // Set the return value.
+      mmcm_pll_divider = {w_edge,no_count,high_time[5:0],low_time[5:0]};
+   end
+endfunction
+
+// This function calculates mx, delay_time, and phase_mux 
+//  of a non-fractional counter based on the divide and phase
+//
+// NOTE: The only valid value for the MX bits is 2'b00 to ensure the coarse mux
+//    is used.
+function [10:0] mmcm_pll_phase
+   (
+      // divide must be an integer (use fractional if not)
+      //  assumed that divide already checked to be valid
+      input [7:0] divide, // Max divide is 128
+
+      // Phase is given in degrees (-360,000 to 360,000)
+      input signed [31:0] phase
+   );
+
+   reg [`FIXED_WIDTH:1] phase_in_cycles;
+   reg [`FIXED_WIDTH:1] phase_fixed;
+   reg [1:0]            mx;
+   reg [5:0]            delay_time;
+   reg [2:0]            phase_mux;
+
+   reg [`FIXED_WIDTH:1] temp;
+
+   begin
+`ifdef DEBUG
+      $display("mmcm_pll_phase-divide:%d,phase:%d",
+         divide, phase);
+`endif
+   
+      if ((phase < -360000) || (phase > 360000)) begin
+`ifndef SYNTHESIS
+      $display("ERROR: phase of $phase is not between -360000 and 360000");
+	`endif
+         $finish;
+      end
+
+      // If phase is less than 0, convert it to a positive phase shift
+      // Convert to (FIXED_WIDTH-FRAC_PRECISION).FRAC_PRECISION fixed point
+      if(phase < 0) begin
+         phase_fixed = ( (phase + 360000) << `FRAC_PRECISION ) / 1000;
+      end else begin
+         phase_fixed = ( phase << `FRAC_PRECISION ) / 1000;
+      end
+
+      // Put phase in terms of decimal number of vco clock cycles
+      phase_in_cycles = ( phase_fixed * divide ) / 360;
+
+`ifdef DEBUG
+      $display("phase_in_cycles: %h", phase_in_cycles);
+`endif  
+      
+
+	 temp  =  round_frac(phase_in_cycles, 3);
+
+	 // set mx to 2'b00 that the phase mux from the VCO is enabled
+	 mx    			=  2'b00; 
+	 phase_mux      =  temp[`FRAC_PRECISION:`FRAC_PRECISION-2];
+	 delay_time     =  temp[`FRAC_PRECISION+6:`FRAC_PRECISION+1];
+      
+   `ifdef DEBUG
+      $display("temp: %h", temp);
+   `endif
+
+      // Setup the return value
+      mmcm_pll_phase={mx, phase_mux, delay_time};
+   end
+endfunction
+
+// This function takes the divide value and outputs the necessary lock values
+function [39:0] mmcm_pll_lock_lookup
+   (
+      input [6:0] divide // Max divide is 64
+   );
+   
+   reg [2559:0]   lookup;
+   
+   begin
+      lookup = {
+         // This table is composed of:
+         // LockRefDly_LockFBDly_LockCnt_LockSatHigh_UnlockCnt
+         40'b00110_00110_1111101000_1111101001_0000000001,
+         40'b00110_00110_1111101000_1111101001_0000000001,
+         40'b01000_01000_1111101000_1111101001_0000000001,
+         40'b01011_01011_1111101000_1111101001_0000000001,
+         40'b01110_01110_1111101000_1111101001_0000000001,
+         40'b10001_10001_1111101000_1111101001_0000000001,
+         40'b10011_10011_1111101000_1111101001_0000000001,
+         40'b10110_10110_1111101000_1111101001_0000000001,
+         40'b11001_11001_1111101000_1111101001_0000000001,
+         40'b11100_11100_1111101000_1111101001_0000000001,
+         40'b11111_11111_1110000100_1111101001_0000000001,
+         40'b11111_11111_1100111001_1111101001_0000000001,
+         40'b11111_11111_1011101110_1111101001_0000000001,
+         40'b11111_11111_1010111100_1111101001_0000000001,
+         40'b11111_11111_1010001010_1111101001_0000000001,
+         40'b11111_11111_1001110001_1111101001_0000000001,
+         40'b11111_11111_1000111111_1111101001_0000000001,
+         40'b11111_11111_1000100110_1111101001_0000000001,
+         40'b11111_11111_1000001101_1111101001_0000000001,
+         40'b11111_11111_0111110100_1111101001_0000000001,
+         40'b11111_11111_0111011011_1111101001_0000000001,
+         40'b11111_11111_0111000010_1111101001_0000000001,
+         40'b11111_11111_0110101001_1111101001_0000000001,
+         40'b11111_11111_0110010000_1111101001_0000000001,
+         40'b11111_11111_0110010000_1111101001_0000000001,
+         40'b11111_11111_0101110111_1111101001_0000000001,
+         40'b11111_11111_0101011110_1111101001_0000000001,
+         40'b11111_11111_0101011110_1111101001_0000000001,
+         40'b11111_11111_0101000101_1111101001_0000000001,
+         40'b11111_11111_0101000101_1111101001_0000000001,
+         40'b11111_11111_0100101100_1111101001_0000000001,
+         40'b11111_11111_0100101100_1111101001_0000000001,
+         40'b11111_11111_0100101100_1111101001_0000000001,
+         40'b11111_11111_0100010011_1111101001_0000000001,
+         40'b11111_11111_0100010011_1111101001_0000000001,
+         40'b11111_11111_0100010011_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001
+      };
+      
+      // Set lookup_entry with the explicit bits from lookup with a part select
+      mmcm_pll_lock_lookup = lookup[ ((64-divide)*40) +: 40];
+   `ifdef DEBUG
+      $display("lock_lookup: %b", mmcm_pll_lock_lookup);
+   `endif
+   end
+endfunction
+
+// This function takes the divide value and the bandwidth setting of the MMCM
+//  and outputs the digital filter settings necessary.
+function [9:0] mmcm_pll_filter_lookup
+   (
+      input [6:0] divide, // Max divide is 64
+      input [8*9:0] BANDWIDTH
+   );
+   
+   reg [639:0] lookup_low;
+   reg [639:0] lookup_high;
+   
+   reg [9:0] lookup_entry;
+   
+   begin
+      lookup_low = {
+         // CP_RES_LFHF
+         10'b0010_1111_11,
+         10'b0010_1111_11,
+         10'b0010_1111_11,
+         10'b0010_1111_11,
+         10'b0010_1111_11,
+         10'b0010_1111_11,
+         10'b0010_0111_11,
+         10'b0010_0111_11,
+         10'b0010_0111_11,
+         10'b0010_1101_11,
+         10'b0010_1101_11,
+         10'b0010_1101_11,
+         10'b0010_0011_11,
+         10'b0010_0101_11,
+         10'b0010_0101_11,
+         10'b0010_0101_11,
+         10'b0010_1001_11,
+         10'b0010_1001_11,
+         10'b0010_1110_11,
+         10'b0010_1110_11,
+         10'b0010_1110_11,
+         10'b0010_1110_11,
+         10'b0010_1110_11,
+         10'b0010_1110_11,
+         10'b0010_0001_11,
+         10'b0010_0001_11,
+         10'b0010_0001_11,
+         10'b0010_0001_11,
+         10'b0010_0001_11,
+         10'b0010_0110_11,
+         10'b0010_0110_11,
+         10'b0010_0110_11,
+         10'b0010_0110_11,
+         10'b0010_0110_11,
+         10'b0010_0110_11,
+         10'b0010_0110_11,
+         10'b0010_0110_11,
+         10'b0010_0110_11,
+         10'b0010_0110_11,
+         10'b0010_1010_11,
+         10'b0010_1010_11,
+         10'b0010_1010_11,
+         10'b0010_1010_11,
+         10'b0010_1010_11,
+         10'b0010_1010_11,
+         10'b0010_1010_11,
+         10'b0010_1010_11,
+         10'b0010_1100_11,
+         10'b0010_1100_11,
+         10'b0010_1100_11,
+         10'b0010_1100_11,
+         10'b0010_1100_11,
+         10'b0010_1100_11,
+         10'b0010_1100_11,
+         10'b0010_1100_11,
+         10'b0010_1100_11,
+         10'b0010_1100_11,
+         10'b0010_1100_11,
+         10'b0010_1100_11,
+         10'b0010_1100_11,
+         10'b0010_1100_11,
+         10'b0010_1100_11,
+         10'b0010_1100_11,
+         10'b0010_1100_11
+      };
+      
+      lookup_high = {
+         // CP_RES_LFHF
+         10'b0010_1111_11,
+         10'b0010_1111_11,
+         10'b0010_1011_11,
+         10'b0011_1111_11,
+         10'b0100_1111_11,
+         10'b0100_1111_11,
+         10'b0101_1111_11,
+         10'b0110_1111_11,
+         10'b0111_1111_11,
+         10'b0111_1111_11,
+         10'b1100_1111_11,
+         10'b1101_1111_11,
+         10'b1110_1111_11,
+         10'b1111_1111_11,
+         10'b1111_1111_11,
+         10'b1110_0111_11,
+         10'b1110_1011_11,
+         10'b1111_0111_11,
+         10'b1111_1011_11,
+         10'b1111_1011_11,
+         10'b1110_1101_11,
+         10'b1111_1101_11,
+         10'b1111_1101_11,
+         10'b1111_0011_11,
+         10'b1111_0011_11,
+         10'b1111_0011_11,
+         10'b1110_0101_11,
+         10'b1110_0101_11,
+         10'b1110_0101_11,
+         10'b1111_0101_11,
+         10'b1111_0101_11,
+         10'b1111_0101_11,
+         10'b1111_1001_11,
+         10'b1111_1001_11,
+         10'b1111_1001_11,
+         10'b1111_1001_11,
+         10'b1111_1001_11,
+         10'b1110_1110_11,
+         10'b1110_1110_11,
+         10'b1110_1110_11,
+         10'b1110_1110_11,
+         10'b1111_1110_11,
+         10'b1111_1110_11,
+         10'b1111_1110_11,
+         10'b1111_1110_11,
+         10'b1111_1110_11,
+         10'b1111_1110_11,
+         10'b1111_1110_11,
+         10'b1110_0001_11,
+         10'b1110_0001_11,
+         10'b1110_0001_11,
+         10'b1110_0001_11,
+         10'b1110_0001_11,
+         10'b1100_0110_11,
+         10'b1100_0110_11,
+         10'b1100_0110_11,
+         10'b1100_0110_11,
+         10'b1100_0110_11,
+         10'b1100_0110_11,
+         10'b1100_0110_11,
+         10'b1100_1010_11,
+         10'b1100_1010_11,
+         10'b1100_1010_11,
+         10'b1100_1010_11
+      };
+      
+      // Set lookup_entry with the explicit bits from lookup with a part select
+      if(BANDWIDTH == "LOW") begin
+         // Low Bandwidth
+         mmcm_pll_filter_lookup = lookup_low[ ((64-divide)*10) +: 10];
+      end else begin
+         // High or optimized bandwidth
+         mmcm_pll_filter_lookup = lookup_high[ ((64-divide)*10) +: 10];
+      end
+      
+   `ifdef DEBUG
+      $display("filter_lookup: %b", mmcm_pll_filter_lookup);
+   `endif
+   end
+endfunction
+
+// This function takes in the divide, phase, and duty cycle
+// setting to calculate the upper and lower counter registers.
+function [37:0] mmcm_pll_count_calc
+   (
+      input [7:0] divide, // Max divide is 128
+      input signed [31:0] phase,
+      input [31:0] duty_cycle // Multiplied by 100,000
+   );
+   
+   reg [13:0] div_calc;
+   reg [16:0] phase_calc;
+   
+   begin
+   `ifdef DEBUG
+      $display("mmcm_pll_count_calc- divide:%h, phase:%d, duty_cycle:%d",
+         divide, phase, duty_cycle);
+   `endif
+   
+      // w_edge[13], no_count[12], high_time[11:6], low_time[5:0]
+      div_calc = mmcm_pll_divider(divide, duty_cycle);
+      // mx[10:9], pm[8:6], dt[5:0]
+      phase_calc = mmcm_pll_phase(divide, phase);
+
+      // Return value is the upper and lower address of counter
+      //    Upper address is:
+      //       RESERVED    [31:26]
+      //       MX          [25:24]
+      //       EDGE        [23]
+      //       NOCOUNT     [22]
+      //       DELAY_TIME  [21:16]
+      //    Lower Address is:
+      //       PHASE_MUX   [15:13]
+      //       RESERVED    [12]
+      //       HIGH_TIME   [11:6]
+      //       LOW_TIME    [5:0]
+      
+   `ifdef DEBUG
+      $display("div:%d dc:%d phase:%d ht:%d lt:%d ed:%d nc:%d mx:%d dt:%d pm:%d",
+         divide, duty_cycle, phase, div_calc[11:6], div_calc[5:0], 
+         div_calc[13], div_calc[12], 
+         phase_calc[16:15], phase_calc[5:0], phase_calc[14:12]);
+   `endif
+      
+      mmcm_pll_count_calc =
+         {
+            // Upper Address
+            6'h00, phase_calc[10:9], div_calc[13:12], phase_calc[5:0], 
+            // Lower Address
+            phase_calc[8:6], 1'b0, div_calc[11:0]
+         };
+   end
+endfunction
+
+
+// This function takes in the divide, phase, and duty cycle
+// setting to calculate the upper and lower counter registers.
+// for fractional multiply/divide functions.
+//
+// 
+function [37:0] mmcm_frac_count_calc
+   (
+      input [7:0] divide, // Max divide is 128
+      input signed [31:0] phase,
+      input [31:0] duty_cycle, // Multiplied by 1,000
+      input [9:0] frac // Multiplied by 1000
+   );
+   
+	//Required for fractional divide calculations
+			  reg	[7:0]			lt_frac;
+			  reg	[7:0]			ht_frac;
+			
+			  reg	/*[7:0]*/			wf_fall_frac;
+			  reg	/*[7:0]*/			wf_rise_frac;
+
+			  reg [31:0] a;
+			  reg	[7:0]			pm_rise_frac_filtered ;
+			  reg	[7:0]			pm_fall_frac_filtered ;	
+			  reg [7:0]			clkout0_divide_int;
+			  reg [2:0]			clkout0_divide_frac;
+			  reg	[7:0]			even_part_high;
+			  reg	[7:0]			even_part_low;
+
+			  reg	[7:0]			odd;
+			  reg	[7:0]			odd_and_frac;
+
+			  reg	[7:0]			pm_fall;
+			  reg	[7:0]			pm_rise;
+			  reg	[7:0]			dt;
+			  reg	[7:0]			dt_int; 
+			  reg [63:0]		dt_calc;
+
+			  reg	[7:0]			pm_rise_frac; 
+			  reg	[7:0]			pm_fall_frac;
+	 
+			  reg [31:0] a_per_in_octets;
+			  reg [31:0] a_phase_in_cycles;
+
+				parameter precision = 0.125;
+
+			  reg [31:0] phase_fixed; // changed to 31:0 from 32:1 jt 5/2/11
+			  reg [31: 0] phase_pos;
+			  reg [31: 0] phase_vco;
+			  reg [31:0] temp;// changed to 31:0 from 32:1 jt 5/2/11
+			  reg [13:0] div_calc;
+			  reg [16:0] phase_calc;
+
+   begin
+	`ifdef DEBUG
+			$display("mmcm_frac_count_calc- divide:%h, phase:%d, duty_cycle:%d",
+				divide, phase, duty_cycle);
+	`endif
+   
+   //convert phase to fixed
+   if ((phase < -360000) || (phase > 360000)) begin
+`ifndef SYNTHESIS
+      $display("ERROR: phase of $phase is not between -360000 and 360000");
+	`endif
+      $finish;
+   end
+
+
+      // Return value is
+      //    Transfer data
+      //       RESERVED     [37:36]
+      //       FRAC_TIME    [35:33]
+      //       FRAC_WF_FALL [32]
+      //    Upper address is:
+      //       RESERVED     [31:26]
+      //       MX           [25:24]
+      //       EDGE         [23]
+      //       NOCOUNT      [22]
+      //       DELAY_TIME   [21:16]
+      //    Lower Address is:
+      //       PHASE_MUX    [15:13]
+      //       RESERVED     [12]
+      //       HIGH_TIME    [11:6]
+      //       LOW_TIME     [5:0]
+      
+      
+
+	clkout0_divide_frac = frac / 125;
+	clkout0_divide_int = divide;
+
+	even_part_high = clkout0_divide_int >> 1;//$rtoi(clkout0_divide_int / 2);
+	even_part_low = even_part_high;
+									
+	odd = clkout0_divide_int - even_part_high - even_part_low;
+	odd_and_frac = (8*odd) + clkout0_divide_frac;
+
+	lt_frac = even_part_high - (odd_and_frac <= 9);//IF(odd_and_frac>9,even_part_high, even_part_high - 1)
+	ht_frac = even_part_low  - (odd_and_frac <= 8);//IF(odd_and_frac>8,even_part_low, even_part_low- 1)
+
+	pm_fall =  {odd[6:0],2'b00} + {6'h00, clkout0_divide_frac[2:1]}; // using >> instead of clkout0_divide_frac / 2 
+	pm_rise = 0; //0
+    
+	wf_fall_frac = ((odd_and_frac >=2) && (odd_and_frac <=9)) || ((clkout0_divide_frac == 1) && (clkout0_divide_int == 2));//CRS610807
+	wf_rise_frac = (odd_and_frac >=1) && (odd_and_frac <=8);//IF(odd_and_frac>=1,IF(odd_and_frac <= 8,1,0),0)
+
+
+
+	//Calculate phase in fractional cycles
+	a_per_in_octets		= (8 * divide) + (frac / 125) ;
+	a_phase_in_cycles	= (phase+10) * a_per_in_octets / 360000 ;//Adding 1 due to rounding errors
+	pm_rise_frac		= (a_phase_in_cycles[7:0] ==8'h00)?8'h00:a_phase_in_cycles[7:0] - {a_phase_in_cycles[7:3],3'b000};
+
+	dt_calc 	= ((phase+10) * a_per_in_octets / 8 )/360000 ;//TRUNC(phase* divide / 360); //or_simply (a_per_in_octets / 8)
+	dt 	= dt_calc[7:0];
+
+	pm_rise_frac_filtered = (pm_rise_frac >=8) ? (pm_rise_frac ) - 8: pm_rise_frac ;				//((phase_fixed * (divide + frac / 1000)) / 360) - {pm_rise_frac[7:3],3'b000};//$rtoi(clkout0_phase * clkout0_divide / 45);//a;
+
+	dt_int			= dt + (& pm_rise_frac[7:4]); //IF(pm_rise_overwriting>7,dt+1,dt)
+	pm_fall_frac		= pm_fall + pm_rise_frac;
+	pm_fall_frac_filtered	= pm_fall + pm_rise_frac - {pm_fall_frac[7:3], 3'b000};
+
+	div_calc	= mmcm_pll_divider(divide, duty_cycle); //Use to determine edge[7], no count[6]
+	phase_calc	= mmcm_pll_phase(divide, phase);// returns{mx[1:0], phase_mux[2:0], delay_time[5:0]}
+		
+      mmcm_frac_count_calc[37:0] =
+         {		2'b00, pm_fall_frac_filtered[2:0], wf_fall_frac,
+			1'b0, clkout0_divide_frac[2:0], 1'b1, wf_rise_frac, phase_calc[10:9], div_calc[13:12], dt[5:0], 
+			pm_rise_frac_filtered[2], pm_rise_frac_filtered[1], pm_rise_frac_filtered[0], 1'b0, ht_frac[5:0], lt_frac[5:0]
+		} ;
+
+   `ifdef DEBUG
+      $display("-%d.%d p%d>>  :DADDR_9_15 frac30to28.frac_en.wf_r_frac.dt:%b%d%d_%b:DADDR_7_13 pm_f_frac_filtered_29to27.wf_f_frac_26:%b%d:DADDR_8_14.pm_r_frac_filt_15to13.ht_frac.lt_frac:%b%b%b:", divide, frac, phase, clkout0_divide_frac, 1, wf_rise_frac, dt, pm_fall_frac_filtered, wf_fall_frac, pm_rise_frac_filtered, ht_frac, lt_frac);
+   `endif
+
+   end
+endfunction
+
diff --git a/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_us_pll.vh b/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_us_pll.vh
new file mode 100755
index 000000000..9439f2359
--- /dev/null
+++ b/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_us_pll.vh
@@ -0,0 +1,530 @@
+///////////////////////////////////////////////////////////////////////////////
+//    
+//    Company:          Xilinx
+//    Engineer:         Jim Tatsukawa
+//    Date:             6/15/2015
+//    Design Name:      PLLE3 DRP
+//    Module Name:      plle3_drp_func.h
+//    Version:          1.10
+//    Target Devices:   UltraScale Architecture
+//    Tool versions:    2015.1
+//    Description:      This header provides the functions necessary to  
+//                      calculate the DRP register values for the V6 PLL.
+//                      
+//	Revision Notes:	8/11 - PLLE3 updated for PLLE3 file 4564419
+//	Revision Notes:	6/15 - pll_filter_lookup fixed for max M of 19
+//                         PM_Rise bits have been removed for PLLE3
+// 
+//    Disclaimer:  XILINX IS PROVIDING THIS DESIGN, CODE, OR
+//                 INFORMATION "AS IS" SOLELY FOR USE IN DEVELOPING
+//                 PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY
+//                 PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+//                 ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+//                 APPLICATION OR STANDARD, XILINX IS MAKING NO
+//                 REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+//                 FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE
+//                 RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY
+//                 REQUIRE FOR YOUR IMPLEMENTATION.  XILINX
+//                 EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH
+//                 RESPECT TO THE ADEQUACY OF THE IMPLEMENTATION,
+//                 INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+//                 REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE
+//                 FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES
+//                 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+//                 PURPOSE.
+// 
+//                 (c) Copyright 2009-2010 Xilinx, Inc.
+//                 All rights reserved.
+// 
+///////////////////////////////////////////////////////////////////////////////
+
+// These are user functions that should not be modified.  Changes to the defines
+// or code within the functions may alter the accuracy of the calculations.
+
+// Define debug to provide extra messages durring elaboration
+//`define DEBUG 1
+
+// FRAC_PRECISION describes the width of the fractional portion of the fixed
+//    point numbers.  These should not be modified, they are for development 
+//    only
+`define FRAC_PRECISION  10
+// FIXED_WIDTH describes the total size for fixed point calculations(int+frac).
+// Warning: L.50 and below will not calculate properly with FIXED_WIDTHs 
+//    greater than 32
+`define FIXED_WIDTH     32 
+
+// This function takes a fixed point number and rounds it to the nearest
+//    fractional precision bit.
+function [`FIXED_WIDTH:1] round_frac
+   (
+      // Input is (FIXED_WIDTH-FRAC_PRECISION).FRAC_PRECISION fixed point number
+      input [`FIXED_WIDTH:1] decimal,  
+
+      // This describes the precision of the fraction, for example a value
+      //    of 1 would modify the fractional so that instead of being a .16
+      //    fractional, it would be a .1 (rounded to the nearest 0.5 in turn)
+      input [`FIXED_WIDTH:1] precision 
+   );
+
+   begin
+   
+   `ifdef DEBUG
+      $display("round_frac - decimal: %h, precision: %h", decimal, precision);
+   `endif
+      // If the fractional precision bit is high then round up
+      if( decimal[(`FRAC_PRECISION-precision)] == 1'b1) begin
+         round_frac = decimal + (1'b1 << (`FRAC_PRECISION-precision));
+      end else begin
+         round_frac = decimal;
+      end
+   `ifdef DEBUG
+      $display("round_frac: %h", round_frac);
+   `endif
+   end
+endfunction
+
+// This function calculates high_time, low_time, w_edge, and no_count
+//    of a non-fractional counter based on the divide and duty cycle
+//
+// NOTE: high_time and low_time are returned as integers between 0 and 63 
+//    inclusive.  64 should equal 6'b000000 (in other words it is okay to 
+//    ignore the overflow)
+function [13:0] mmcm_pll_divider
+   (
+      input [7:0] divide,        // Max divide is 128
+      input [31:0] duty_cycle    // Duty cycle is multiplied by 100,000
+   );
+
+   reg [`FIXED_WIDTH:1]    duty_cycle_fix;
+   
+   // High/Low time is initially calculated with a wider integer to prevent a
+   // calculation error when it overflows to 64.
+   reg [6:0]               high_time;
+   reg [6:0]               low_time;
+   reg                     w_edge;
+   reg                     no_count;
+
+   reg [`FIXED_WIDTH:1]    temp;
+
+   begin
+      // Duty Cycle must be between 0 and 1,000
+      if(duty_cycle <=0 || duty_cycle >= 100000) begin
+`ifndef SYNTHESIS
+         $display("ERROR: duty_cycle: %d is invalid", duty_cycle);
+   `endif
+         $finish;
+      end
+
+      // Convert to FIXED_WIDTH-FRAC_PRECISION.FRAC_PRECISION fixed point
+      duty_cycle_fix = (duty_cycle << `FRAC_PRECISION) / 100_000;
+      
+   `ifdef DEBUG
+      $display("duty_cycle_fix: %h", duty_cycle_fix);
+   `endif
+
+      // If the divide is 1 nothing needs to be set except the no_count bit.
+      //    Other values are dummies
+      if(divide == 7'h01) begin
+         high_time   = 7'h01;
+         w_edge      = 1'b0;
+         low_time    = 7'h01;
+         no_count    = 1'b1;
+      end else begin
+         temp = round_frac(duty_cycle_fix*divide, 1);
+
+         // comes from above round_frac
+         high_time   = temp[`FRAC_PRECISION+7:`FRAC_PRECISION+1]; 
+         // If the duty cycle * divide rounded is .5 or greater then this bit
+         //    is set.
+         w_edge      = temp[`FRAC_PRECISION]; // comes from round_frac
+         
+         // If the high time comes out to 0, it needs to be set to at least 1
+         // and w_edge set to 0
+         if(high_time == 7'h00) begin
+            high_time   = 7'h01;
+            w_edge      = 1'b0;
+         end
+
+         if(high_time == divide) begin
+            high_time   = divide - 1;
+            w_edge      = 1'b1;
+         end
+         
+         // Calculate low_time based on the divide setting and set no_count to
+         //    0 as it is only used when divide is 1.
+         low_time    = divide - high_time; 
+         no_count    = 1'b0;
+      end
+
+      // Set the return value.
+      mmcm_pll_divider = {w_edge,no_count,high_time[5:0],low_time[5:0]};
+   end
+endfunction
+
+// This function calculates mx, delay_time, and phase_mux 
+//  of a non-fractional counter based on the divide and phase
+//
+// NOTE: The only valid value for the MX bits is 2'b00 to ensure the coarse mux
+//    is used.
+function [10:0] mmcm_pll_phase
+   (
+      // divide must be an integer (use fractional if not)
+      //  assumed that divide already checked to be valid
+      input [7:0] divide, // Max divide is 128
+
+      // Phase is given in degrees (-360,000 to 360,000)
+      input signed [31:0] phase
+   );
+
+   reg [`FIXED_WIDTH:1] phase_in_cycles;
+   reg [`FIXED_WIDTH:1] phase_fixed;
+   reg [1:0]            mx;
+   reg [5:0]            delay_time;
+   reg [2:0]            phase_mux;
+
+   reg [`FIXED_WIDTH:1] temp;
+
+   begin
+`ifdef DEBUG
+      $display("mmcm_pll_phase-divide:%d,phase:%d",
+         divide, phase);
+`endif
+   
+      if ((phase < -360000) || (phase > 360000)) begin
+`ifndef SYNTHESIS
+      $display("ERROR: phase of $phase is not between -360000 and 360000");
+	`endif
+         $finish;
+      end
+
+      // If phase is less than 0, convert it to a positive phase shift
+      // Convert to (FIXED_WIDTH-FRAC_PRECISION).FRAC_PRECISION fixed point
+      if(phase < 0) begin
+         phase_fixed = ( (phase + 360000) << `FRAC_PRECISION ) / 1000;
+      end else begin
+         phase_fixed = ( phase << `FRAC_PRECISION ) / 1000;
+      end
+
+      // Put phase in terms of decimal number of vco clock cycles
+      phase_in_cycles = ( phase_fixed * divide ) / 360;
+
+`ifdef DEBUG
+      $display("phase_in_cycles: %h", phase_in_cycles);
+`endif  
+      
+
+	 temp  =  round_frac(phase_in_cycles, 3);
+
+	 // set mx to 2'b00 that the phase mux from the VCO is enabled
+	 mx    			=  2'b00; 
+	 phase_mux      =  temp[`FRAC_PRECISION:`FRAC_PRECISION-2];
+	 delay_time     =  temp[`FRAC_PRECISION+6:`FRAC_PRECISION+1];
+      
+   `ifdef DEBUG
+      $display("temp: %h", temp);
+   `endif
+
+      // Setup the return value
+      mmcm_pll_phase={mx, phase_mux, delay_time};
+   end
+endfunction
+
+// This function takes the divide value and outputs the necessary lock values
+function [39:0] mmcm_pll_lock_lookup
+   (
+      input [6:0] divide // Max divide is 64
+   );
+   
+   reg [759:0]   lookup;
+   
+   begin
+      lookup = {
+         // This table is composed of:
+         // LockRefDly_LockFBDly_LockCnt_LockSatHigh_UnlockCnt
+         40'b00110_00110_1111101000_1111101001_0000000001, //1  
+         40'b00110_00110_1111101000_1111101001_0000000001, //2
+         40'b01000_01000_1111101000_1111101001_0000000001, //3
+         40'b01011_01011_1111101000_1111101001_0000000001, //4
+         40'b01110_01110_1111101000_1111101001_0000000001, //5
+         40'b10001_10001_1111101000_1111101001_0000000001, //6
+         40'b10011_10011_1111101000_1111101001_0000000001, //7
+         40'b10110_10110_1111101000_1111101001_0000000001, //8
+         40'b11001_11001_1111101000_1111101001_0000000001, //9
+         40'b11100_11100_1111101000_1111101001_0000000001, //10
+         40'b11111_11111_1110000100_1111101001_0000000001, //11
+         40'b11111_11111_1100111001_1111101001_0000000001, //12
+         40'b11111_11111_1011101110_1111101001_0000000001, //13
+         40'b11111_11111_1010111100_1111101001_0000000001, //14
+         40'b11111_11111_1010001010_1111101001_0000000001, //15
+         40'b11111_11111_1001110001_1111101001_0000000001, //16
+         40'b11111_11111_1000111111_1111101001_0000000001, //17
+         40'b11111_11111_1000100110_1111101001_0000000001, //18
+         40'b11111_11111_1000001101_1111101001_0000000001 //19
+         
+      };
+      
+      // Set lookup_entry with the explicit bits from lookup with a part select
+      mmcm_pll_lock_lookup = lookup[ ((19-divide)*40) +: 40];
+   `ifdef DEBUG
+      $display("lock_lookup: %b", mmcm_pll_lock_lookup);
+   `endif
+   end
+endfunction
+
+// This function takes the divide value and the bandwidth setting of the PLL
+//  and outputs the digital filter settings necessary. Removing bandwidth setting for PLLE3.
+function [9:0] mmcm_pll_filter_lookup
+   (
+      input [6:0] divide // Max divide is 19
+   );
+   
+   reg [639:0] lookup;
+   reg [9:0] lookup_entry;
+   
+   begin
+
+      lookup = {
+         // CP_RES_LFHF
+         10'b0010_1111_01, //1
+         10'b0010_0011_11, //2
+         10'b0011_0011_11, //3
+         10'b0010_0001_11, //4
+         10'b0010_0110_11, //5
+         10'b0010_1010_11, //6
+         10'b0010_1010_11, //7
+         10'b0011_0110_11, //8
+         10'b0010_1100_11, //9
+         10'b0010_1100_11, //10
+         10'b0010_1100_11, //11
+         10'b0010_0010_11, //12
+         10'b0011_1100_11, //13
+         10'b0011_1100_11, //14
+         10'b0011_1100_11, //15
+         10'b0011_1100_11, //16
+         10'b0011_0010_11, //17
+         10'b0011_0010_11, //18
+         10'b0011_0010_11 //19
+      };
+      
+         mmcm_pll_filter_lookup = lookup [ ((19-divide)*10) +: 10];
+      
+   `ifdef DEBUG
+      $display("filter_lookup: %b", mmcm_pll_filter_lookup);
+   `endif
+   end
+endfunction
+
+// This function set the CLKOUTPHY divide settings to match
+// the desired CLKOUTPHY_MODE setting. To create VCO_X2, then
+// the CLKOUTPHY will be set to 2'b00 since the VCO is internally
+// doubled and 2'b00 will represent divide by 1. Similarly "VCO" // will need to divide the doubled clock VCO clock frequency by // 2 therefore 2'b01 will match a divide by 2.And VCO_HALF will // need to divide the doubled VCO by 4, therefore 2'b10
+function [9:0] mmcm_pll_clkoutphy_calc
+   (
+      input [8*9:0] CLKOUTPHY_MODE
+   );
+
+      if(CLKOUTPHY_MODE == "VCO_X2") begin
+         mmcm_pll_clkoutphy_calc= 2'b00;
+      end else if(CLKOUTPHY_MODE == "VCO") begin
+         mmcm_pll_clkoutphy_calc= 2'b01;
+      end else if(CLKOUTPHY_MODE == "CLKIN") begin
+         mmcm_pll_clkoutphy_calc= 2'b11;
+      end else begin // Assume "VCO_HALF"
+         mmcm_pll_clkoutphy_calc= 2'b10;
+      end
+      
+endfunction
+
+
+// This function takes in the divide, phase, and duty cycle
+// setting to calculate the upper and lower counter registers.
+function [37:0] mmcm_pll_count_calc
+   (
+      input [7:0] divide, // Max divide is 128
+      input signed [31:0] phase,
+      input [31:0] duty_cycle // Multiplied by 100,000
+   );
+   
+   reg [13:0] div_calc;
+   reg [16:0] phase_calc;
+   
+   begin
+   `ifdef DEBUG
+      $display("mmcm_pll_count_calc- divide:%h, phase:%d, duty_cycle:%d",
+         divide, phase, duty_cycle);
+   `endif
+   
+      // w_edge[13], no_count[12], high_time[11:6], low_time[5:0]
+      div_calc = mmcm_pll_divider(divide, duty_cycle);
+      // mx[10:9], pm[8:6], dt[5:0]
+      phase_calc = mmcm_pll_phase(divide, phase);
+
+      // Return value is the upper and lower address of counter
+      //    Upper address is:
+      //       RESERVED    [31:26]
+      //       MX          [25:24]
+      //       EDGE        [23]
+      //       NOCOUNT     [22]
+      //       DELAY_TIME  [21:16]
+      //    Lower Address is:
+      //       PHASE_MUX   [15:13]
+      //       RESERVED    [12]
+      //       HIGH_TIME   [11:6]
+      //       LOW_TIME    [5:0]
+      
+   `ifdef DEBUG
+      $display("div:%d dc:%d phase:%d ht:%d lt:%d ed:%d nc:%d mx:%d dt:%d pm:%d",
+         divide, duty_cycle, phase, div_calc[11:6], div_calc[5:0], 
+         div_calc[13], div_calc[12], 
+         phase_calc[16:15], phase_calc[5:0], 3'b000);//Removed PM_Rise bits
+   `endif
+      
+      mmcm_pll_count_calc =
+         {
+            // Upper Address
+            6'h00, phase_calc[10:9], div_calc[13:12], phase_calc[5:0], 
+            // Lower Address
+            phase_calc[8:6], 1'b0, div_calc[11:0]
+         };
+   end
+endfunction
+
+
+// This function takes in the divide, phase, and duty cycle
+// setting to calculate the upper and lower counter registers.
+// for fractional multiply/divide functions.
+//
+// 
+function [37:0] mmcm_pll_frac_count_calc
+   (
+      input [7:0] divide, // Max divide is 128
+      input signed [31:0] phase,
+      input [31:0] duty_cycle, // Multiplied by 1,000
+      input [9:0] frac // Multiplied by 1000
+   );
+   
+	//Required for fractional divide calculations
+			  reg	[7:0]			lt_frac;
+			  reg	[7:0]			ht_frac;
+			
+			  reg	/*[7:0]*/			wf_fall_frac;
+			  reg	/*[7:0]*/			wf_rise_frac;
+
+			  reg [31:0] a;
+			  reg	[7:0]			pm_rise_frac_filtered ;
+			  reg	[7:0]			pm_fall_frac_filtered ;	
+			  reg [7:0]			clkout0_divide_int;
+			  reg [2:0]			clkout0_divide_frac;
+			  reg	[7:0]			even_part_high;
+			  reg	[7:0]			even_part_low;
+
+			  reg	[7:0]			odd;
+			  reg	[7:0]			odd_and_frac;
+
+			  reg	[7:0]			pm_fall;
+			  reg	[7:0]			pm_rise;
+			  reg	[7:0]			dt;
+			  reg	[7:0]			dt_int; 
+			  reg [63:0]		dt_calc;
+
+			  reg	[7:0]			pm_rise_frac; 
+			  reg	[7:0]			pm_fall_frac;
+	 
+			  reg [31:0] a_per_in_octets;
+			  reg [31:0] a_phase_in_cycles;
+
+				parameter precision = 0.125;
+
+			  reg [31:0] phase_fixed; // changed to 31:0 from 32:1 jt 5/2/11
+			  reg [31: 0] phase_pos;
+			  reg [31: 0] phase_vco;
+			  reg [31:0] temp;// changed to 31:0 from 32:1 jt 5/2/11
+			  reg [13:0] div_calc;
+			  reg [16:0] phase_calc;
+
+   begin
+	`ifdef DEBUG
+			$display("mmcm_pll_frac_count_calc- divide:%h, phase:%d, duty_cycle:%d",
+				divide, phase, duty_cycle);
+	`endif
+   
+   //convert phase to fixed
+   if ((phase < -360000) || (phase > 360000)) begin
+`ifndef SYNTHESIS
+      $display("ERROR: phase of $phase is not between -360000 and 360000");
+	`endif
+      $finish;
+   end
+
+
+      // Return value is
+      //    Transfer data
+      //       RESERVED     [37:36]
+      //       FRAC_TIME    [35:33]
+      //       FRAC_WF_FALL [32]
+      //    Upper address is:
+      //       RESERVED     [31:26]
+      //       MX           [25:24]
+      //       EDGE         [23]
+      //       NOCOUNT      [22]
+      //       DELAY_TIME   [21:16]
+      //    Lower Address is:
+      //       PHASE_MUX    [15:13]
+      //       RESERVED     [12]
+      //       HIGH_TIME    [11:6]
+      //       LOW_TIME     [5:0]
+      
+      
+
+	clkout0_divide_frac = frac / 125;
+	clkout0_divide_int = divide;
+
+	even_part_high = clkout0_divide_int >> 1;//$rtoi(clkout0_divide_int / 2);
+	even_part_low = even_part_high;
+									
+	odd = clkout0_divide_int - even_part_high - even_part_low;
+	odd_and_frac = (8*odd) + clkout0_divide_frac;
+
+	lt_frac = even_part_high - (odd_and_frac <= 9);//IF(odd_and_frac>9,even_part_high, even_part_high - 1)
+	ht_frac = even_part_low  - (odd_and_frac <= 8);//IF(odd_and_frac>8,even_part_low, even_part_low- 1)
+
+	pm_fall =  {odd[6:0],2'b00} + {6'h00, clkout0_divide_frac[2:1]}; // using >> instead of clkout0_divide_frac / 2 
+	pm_rise = 0; //0
+    
+	wf_fall_frac = (odd_and_frac >=2) && (odd_and_frac <=9);//IF(odd_and_frac>=2,IF(odd_and_frac <= 9,1,0),0)
+	wf_rise_frac = (odd_and_frac >=1) && (odd_and_frac <=8);//IF(odd_and_frac>=1,IF(odd_and_frac <= 8,1,0),0)
+
+
+
+	//Calculate phase in fractional cycles
+	a_per_in_octets		= (8 * divide) + (frac / 125) ;
+	a_phase_in_cycles	= (phase+10) * a_per_in_octets / 360000 ;//Adding 1 due to rounding errors
+	pm_rise_frac		= (a_phase_in_cycles[7:0] ==8'h00)?8'h00:a_phase_in_cycles[7:0] - {a_phase_in_cycles[7:3],3'b000};
+
+	dt_calc 	= ((phase+10) * a_per_in_octets / 8 )/360000 ;//TRUNC(phase* divide / 360); //or_simply (a_per_in_octets / 8)
+	dt 	= dt_calc[7:0];
+
+	pm_rise_frac_filtered = (pm_rise_frac >=8) ? (pm_rise_frac ) - 8: pm_rise_frac ;				//((phase_fixed * (divide + frac / 1000)) / 360) - {pm_rise_frac[7:3],3'b000};//$rtoi(clkout0_phase * clkout0_divide / 45);//a;
+
+	dt_int			= dt + (& pm_rise_frac[7:4]); //IF(pm_rise_overwriting>7,dt+1,dt)
+	pm_fall_frac		= pm_fall + pm_rise_frac;
+	pm_fall_frac_filtered	= pm_fall + pm_rise_frac - {pm_fall_frac[7:3], 3'b000};
+
+	div_calc	= mmcm_pll_divider(divide, duty_cycle); //Use to determine edge[7], no count[6]
+	phase_calc	= mmcm_pll_phase(divide, phase);// returns{mx[1:0], phase_mux[2:0], delay_time[5:0]}
+		
+      mmcm_pll_frac_count_calc[37:0] =
+         {		2'b00, pm_fall_frac_filtered[2:0], wf_fall_frac,
+			1'b0, clkout0_divide_frac[2:0], 1'b1, wf_rise_frac, phase_calc[10:9], div_calc[13:12], dt[5:0], 
+			3'b000, 1'b0, ht_frac[5:0], lt_frac[5:0] //Removed PM_Rise bits
+//			pm_rise_frac_filtered[2], pm_rise_frac_filtered[1], pm_rise_frac_filtered[0], 1'b0, ht_frac[5:0], lt_frac[5:0]
+		} ;
+
+   `ifdef DEBUG
+      $display("-%d.%d p%d>>  :DADDR_9_15 frac30to28.frac_en.wf_r_frac.dt:%b%d%d_%b:DADDR_7_13 pm_f_frac_filtered_29to27.wf_f_frac_26:%b%d:DADDR_8_14.pm_r_frac_filt_15to13.ht_frac.lt_frac:%b%b%b:", divide, frac, phase, clkout0_divide_frac, 1, wf_rise_frac, dt, pm_fall_frac_filtered, wf_fall_frac, 3'b000, ht_frac, lt_frac);
+   `endif
+
+   end
+endfunction
+
+
diff --git a/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_us_plus_mmcm.vh b/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_us_plus_mmcm.vh
new file mode 100755
index 000000000..61edf85cc
--- /dev/null
+++ b/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_us_plus_mmcm.vh
@@ -0,0 +1,861 @@
+///////////////////////////////////////////////////////////////////////////////
+//    
+//    Company:          Xilinx
+//    Engineer:         Jim Tatsukawa. Updated by Ralf Krueger
+//    Date:             7/30/2014
+//    Design Name:      MMCME4 DRP
+//    Module Name:      mmcme4_drp_func.h
+//    Version:          1.31
+//    Target Devices:   UltraScale Plus Architecture
+//    Tool versions:    2017.1
+//    Description:      This header provides the functions necessary to  
+//                      calculate the DRP register values for UltraScal+ MMCM.
+//                      
+//	Revision Notes:	3/22 - Updating lookup_low/lookup_high (CR)
+//				4/13 - Fractional divide function in mmcm_frac_count_calc function
+//              2/28/17 - Updated for Ultrascale Plus
+// 
+//    Disclaimer:  XILINX IS PROVIDING THIS DESIGN, CODE, OR
+//                 INFORMATION "AS IS" SOLELY FOR USE IN DEVELOPING
+//                 PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY
+//                 PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+//                 ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+//                 APPLICATION OR STANDARD, XILINX IS MAKING NO
+//                 REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+//                 FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE
+//                 RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY
+//                 REQUIRE FOR YOUR IMPLEMENTATION.  XILINX
+//                 EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH
+//                 RESPECT TO THE ADEQUACY OF THE IMPLEMENTATION,
+//                 INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+//                 REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE
+//                 FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES
+//                 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+//                 PURPOSE.
+// 
+//                 (c) Copyright 2009-2017 Xilinx, Inc.
+//                 All rights reserved.
+// 
+///////////////////////////////////////////////////////////////////////////////
+
+// These are user functions that should not be modified.  Changes to the defines
+// or code within the functions may alter the accuracy of the calculations.
+
+// Define debug to provide extra messages during elaboration
+//`define DEBUG 1
+
+// FRAC_PRECISION describes the width of the fractional portion of the fixed
+// point numbers.  These should not be modified, they are for development only
+`define FRAC_PRECISION  10
+// FIXED_WIDTH describes the total size for fixed point calculations(int+frac).
+// Warning: L.50 and below will not calculate properly with FIXED_WIDTHs 
+// greater than 32
+`define FIXED_WIDTH     32 
+
+// This function takes a fixed point number and rounds it to the nearest
+// fractional precision bit.
+function [`FIXED_WIDTH:1] round_frac
+   (
+      // Input is (FIXED_WIDTH-FRAC_PRECISION).FRAC_PRECISION fixed point number
+      input [`FIXED_WIDTH:1] decimal,  
+
+      // This describes the precision of the fraction, for example a value
+      // of 1 would modify the fractional so that instead of being a .16
+      // fractional, it would be a .1 (rounded to the nearest 0.5 in turn)
+      input [`FIXED_WIDTH:1] precision 
+   );
+
+   begin
+   
+   `ifdef DEBUG
+      $display("round_frac - decimal: %h, precision: %h", decimal, precision);
+   `endif
+      // If the fractional precision bit is high then round up
+      if( decimal[(`FRAC_PRECISION-precision)] == 1'b1) begin
+         round_frac = decimal + (1'b1 << (`FRAC_PRECISION-precision));
+      end else begin
+         round_frac = decimal;
+      end
+   `ifdef DEBUG
+      $display("round_frac: %h", round_frac);
+   `endif
+   end
+endfunction
+
+// This function calculates high_time, low_time, w_edge, and no_count
+//    of a non-fractional counter based on the divide and duty cycle
+//
+// NOTE: high_time and low_time are returned as integers between 0 and 63 
+//    inclusive.  64 should equal 6'b000000 (in other words it is okay to 
+//    ignore the overflow)
+function [13:0] mmcm_pll_divider
+   (
+      input [7:0] divide,        // Max divide is 128
+      input [31:0] duty_cycle    // Duty cycle is multiplied by 100,000
+   );
+
+   reg [`FIXED_WIDTH:1]    duty_cycle_fix;
+   
+   // High/Low time is initially calculated with a wider integer to prevent a
+   // calculation error when it overflows to 64.
+   reg [6:0]               high_time;
+   reg [6:0]               low_time;
+   reg                     w_edge;
+   reg                     no_count;
+
+   reg [`FIXED_WIDTH:1]    temp;
+
+   begin
+      // Duty Cycle must be between 0 and 1,000
+      if(duty_cycle <=0 || duty_cycle >= 100000) begin
+`ifndef SYNTHESIS
+         $display("ERROR: duty_cycle: %d is invalid", duty_cycle);
+   `endif
+         $finish;
+      end
+
+      // Convert to FIXED_WIDTH-FRAC_PRECISION.FRAC_PRECISION fixed point
+      duty_cycle_fix = (duty_cycle << `FRAC_PRECISION) / 100_000;
+      
+   `ifdef DEBUG
+      $display("duty_cycle_fix: %h", duty_cycle_fix);
+   `endif
+
+      // If the divide is 1 nothing needs to be set except the no_count bit.
+      //    Other values are dummies
+      if(divide == 7'h01) begin
+         high_time   = 7'h01;
+         w_edge      = 1'b0;
+         low_time    = 7'h01;
+         no_count    = 1'b1;
+      end else begin
+         temp = round_frac(duty_cycle_fix*divide, 1);
+
+         // comes from above round_frac
+         high_time   = temp[`FRAC_PRECISION+7:`FRAC_PRECISION+1]; 
+         // If the duty cycle * divide rounded is .5 or greater then this bit
+         //    is set.
+         w_edge      = temp[`FRAC_PRECISION]; // comes from round_frac
+         
+         // If the high time comes out to 0, it needs to be set to at least 1
+         // and w_edge set to 0
+         if(high_time == 7'h00) begin
+            high_time   = 7'h01;
+            w_edge      = 1'b0;
+         end
+
+         if(high_time == divide) begin
+            high_time   = divide - 1;
+            w_edge      = 1'b1;
+         end
+         
+         // Calculate low_time based on the divide setting and set no_count to
+         //    0 as it is only used when divide is 1.
+         low_time    = divide - high_time; 
+         no_count    = 1'b0;
+      end
+
+      // Set the return value.
+      mmcm_pll_divider = {w_edge,no_count,high_time[5:0],low_time[5:0]};
+   end
+endfunction
+
+// This function calculates mx, delay_time, and phase_mux 
+// of a non-fractional counter based on the divide and phase
+//
+// NOTE: The only valid value for the MX bits is 2'b00 to ensure the coarse mux
+//       is used.
+function [10:0] mmcm_pll_phase
+   (
+      // divide must be an integer (use fractional if not)
+      // assumed that divide already checked to be valid
+      input [7:0] divide, // Max divide is 128
+
+      // Phase is given in degrees (-360,000 to 360,000)
+      input signed [31:0] phase
+   );
+
+   reg [`FIXED_WIDTH:1] phase_in_cycles;
+   reg [`FIXED_WIDTH:1] phase_fixed;
+   reg [1:0]            mx;
+   reg [5:0]            delay_time;
+   reg [2:0]            phase_mux;
+
+   reg [`FIXED_WIDTH:1] temp;
+
+   begin
+`ifdef DEBUG
+      $display("mmcm_phase-divide:%d,phase:%d", divide, phase);
+`endif
+   
+      if ((phase < -360000) || (phase > 360000)) begin
+`ifndef SYNTHESIS
+      $display("ERROR: phase of $phase is not between -360000 and 360000");
+	`endif
+         $finish;
+      end
+
+      // If phase is less than 0, convert it to a positive phase shift
+      // Convert to (FIXED_WIDTH-FRAC_PRECISION).FRAC_PRECISION fixed point
+      if(phase < 0) begin
+         phase_fixed = ( (phase + 360000) << `FRAC_PRECISION ) / 1000;
+      end else begin
+         phase_fixed = ( phase << `FRAC_PRECISION ) / 1000;
+      end
+
+      // Put phase in terms of decimal number of vco clock cycles
+      phase_in_cycles = ( phase_fixed * divide ) / 360;
+
+`ifdef DEBUG
+      $display("phase_in_cycles: %h", phase_in_cycles);
+`endif  
+      
+	 temp  =  round_frac(phase_in_cycles, 3);
+
+	 // set mx to 2'b00 that the phase mux from the VCO is enabled
+	 mx    			=  2'b00; 
+	 phase_mux      =  temp[`FRAC_PRECISION:`FRAC_PRECISION-2];
+	 delay_time     =  temp[`FRAC_PRECISION+6:`FRAC_PRECISION+1];
+      
+   `ifdef DEBUG
+      $display("temp: %h", temp);
+   `endif
+
+      // Setup the return value
+      mmcm_pll_phase={mx, phase_mux, delay_time};
+   end
+endfunction
+
+// This function takes the divide value and outputs the necessary lock values
+function [39:0] mmcm_pll_lock_lookup
+   (
+      input [7:0] divide // Max M divide is 128 in UltrascalePlus
+   );
+   
+   reg [5119:0]   lookup;
+   
+   begin
+      lookup = {
+         // This table is composed of:
+         // LockRefDly_LockFBDly_LockCnt_LockSatHigh_UnlockCnt
+         40'b00110_00110_1111101000_1111101001_0000000001,      // M=1 (not allowed)
+         40'b00110_00110_1111101000_1111101001_0000000001,      // M=2
+         40'b01000_01000_1111101000_1111101001_0000000001,      // M=3
+         40'b01011_01011_1111101000_1111101001_0000000001,      // M=4
+         40'b01110_01110_1111101000_1111101001_0000000001,      // M=5
+         40'b10001_10001_1111101000_1111101001_0000000001,      // M=6
+         40'b10011_10011_1111101000_1111101001_0000000001,      // M=7
+         40'b10110_10110_1111101000_1111101001_0000000001,
+         40'b11001_11001_1111101000_1111101001_0000000001,
+         40'b11100_11100_1111101000_1111101001_0000000001,
+         40'b11111_11111_1110000100_1111101001_0000000001,
+         40'b11111_11111_1100111001_1111101001_0000000001,
+         40'b11111_11111_1011101110_1111101001_0000000001,
+         40'b11111_11111_1010111100_1111101001_0000000001,
+         40'b11111_11111_1010001010_1111101001_0000000001,
+         40'b11111_11111_1001110001_1111101001_0000000001,
+         40'b11111_11111_1000111111_1111101001_0000000001,
+         40'b11111_11111_1000100110_1111101001_0000000001,
+         40'b11111_11111_1000001101_1111101001_0000000001,
+         40'b11111_11111_0111110100_1111101001_0000000001,
+         40'b11111_11111_0111011011_1111101001_0000000001,
+         40'b11111_11111_0111000010_1111101001_0000000001,
+         40'b11111_11111_0110101001_1111101001_0000000001,
+         40'b11111_11111_0110010000_1111101001_0000000001,
+         40'b11111_11111_0110010000_1111101001_0000000001,
+         40'b11111_11111_0101110111_1111101001_0000000001,
+         40'b11111_11111_0101011110_1111101001_0000000001,
+         40'b11111_11111_0101011110_1111101001_0000000001,
+         40'b11111_11111_0101000101_1111101001_0000000001,
+         40'b11111_11111_0101000101_1111101001_0000000001,
+         40'b11111_11111_0100101100_1111101001_0000000001,
+         40'b11111_11111_0100101100_1111101001_0000000001,
+         40'b11111_11111_0100101100_1111101001_0000000001,
+         40'b11111_11111_0100010011_1111101001_0000000001,
+         40'b11111_11111_0100010011_1111101001_0000000001,
+         40'b11111_11111_0100010011_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,                                                                    
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,                                                                    
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,
+         40'b11111_11111_0011111010_1111101001_0000000001,      // M=127
+         40'b11111_11111_0011111010_1111101001_0000000001       // M=128
+      };
+      
+      // Set lookup_entry with the explicit bits from lookup with a part select
+      mmcm_pll_lock_lookup = lookup[ ((128-divide)*40) +: 40];
+   `ifdef DEBUG
+      $display("lock_lookup: %b", mmcm_pll_lock_lookup);
+   `endif
+   end
+endfunction
+
+// This function takes the divide value and the bandwidth setting of the MMCM
+//  and outputs the digital filter settings necessary.
+function [9:0] mmcm_pll_filter_lookup
+   (
+      input [7:0] divide, //  input [7:0] divide // Max M divide is 128 in UltraScalePlus
+      input [8*9:0] BANDWIDTH
+   );
+   
+   reg [1279:0] lookup_low;
+   reg [1279:0] lookup_high;
+   
+   reg [9:0] lookup_entry;
+   
+   begin
+      lookup_low = {
+         // CP_RES_LFHF
+       	10'b0011_1111_11,    // M=1 - not legal
+       	10'b0011_1111_11,    // M=2
+       	10'b0011_1101_11,    // M=3
+       	10'b0011_0101_11,    // M=4
+       	10'b0011_1001_11,    // M=5
+       	10'b0011_1110_11,    // M=6
+       	10'b0011_1110_11,    // M=7
+       	10'b0011_0001_11,
+       	10'b0011_0110_11,
+       	10'b0011_0110_11,
+       	10'b0011_0110_11,
+       	10'b0011_1010_11,
+       	10'b0011_1010_11,
+       	10'b0011_1010_11,
+       	10'b0100_0110_11,
+       	10'b0011_1100_11,
+       	10'b1110_0110_11,
+       	10'b1111_0110_11,
+       	10'b1110_1010_11,
+       	10'b1110_1010_11,
+       	10'b1111_1010_11,
+       	10'b1111_1010_11,
+       	10'b1111_1010_11,
+       	10'b1111_1010_11,
+       	10'b1111_1010_11,
+       	10'b1101_1100_11,
+       	10'b1101_1100_11,
+       	10'b1101_1100_11,
+       	10'b1110_1100_11,
+       	10'b1110_1100_11,
+       	10'b1110_1100_11,
+       	10'b1111_1100_11,
+       	10'b1111_1100_11,
+       	10'b1111_1100_11,
+       	10'b1111_1100_11,
+       	10'b1111_1100_11,
+       	10'b1111_1100_11,
+       	10'b1110_0010_11,
+       	10'b1110_0010_11,
+       	10'b1110_0010_11,
+       	10'b1110_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1111_0010_11,
+       	10'b1100_0100_11,
+       	10'b1100_0100_11,
+       	10'b1100_0100_11,
+       	10'b1100_0100_11,
+       	10'b1100_0100_11,
+       	10'b1100_0100_11,
+       	10'b1100_0100_11,
+       	10'b1100_0100_11,
+       	10'b1101_0100_11,
+       	10'b1101_0100_11,
+       	10'b1101_0100_11,
+       	10'b1101_0100_11,
+       	10'b1101_0100_11,
+       	10'b1101_0100_11,
+       	10'b1101_0100_11,
+       	10'b1110_0100_11,
+       	10'b1110_0100_11,
+       	10'b1110_0100_11,
+       	10'b1110_0100_11,
+       	10'b1110_0100_11,
+       	10'b1110_0100_11,
+       	10'b1110_0100_11,
+       	10'b1110_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1111_0100_11,
+       	10'b1101_1000_11,
+       	10'b1101_1000_11,
+       	10'b1101_1000_11,
+       	10'b1101_1000_11,
+       	10'b1101_1000_11,
+       	10'b1101_1000_11,
+       	10'b1101_1000_11,
+       	10'b1101_1000_11, // M=127
+       	10'b1101_1000_11  // M=128
+};										
+      
+      lookup_high = {
+         // CP_RES_LFHF
+       10'b0111_1111_11,    // M=1 - not legal
+       10'b0111_1111_11,    // M=2
+       10'b1110_1111_11,    // M=3
+       10'b1111_1111_11,    // M=4
+       10'b1111_1011_11,    // M=5
+       10'b1111_1101_11,    // M=6
+       10'b1111_0011_11,    // M=7
+       10'b1110_0101_11,
+       10'b1111_1001_11,
+       10'b1111_1001_11,
+       10'b1110_1110_11,
+       10'b1111_1110_11,
+       10'b1111_0001_11,
+       10'b1111_0001_11,
+       10'b1111_0001_11,
+       10'b1110_0110_11,
+       10'b1110_0110_11,
+       10'b1111_0110_11,
+       10'b1110_1010_11,
+       10'b1110_1010_11,
+       10'b1111_1010_11,
+       10'b1111_1010_11,
+       10'b1111_1010_11,
+       10'b1111_1010_11,
+       10'b1111_1010_11,
+       10'b1101_1100_11,
+       10'b1101_1100_11,
+       10'b1101_1100_11,
+       10'b1110_1100_11,
+       10'b1110_1100_11,
+       10'b1110_1100_11,
+       10'b1111_1100_11,
+       10'b1111_1100_11,
+       10'b1111_1100_11,
+       10'b1111_1100_11,
+       10'b1111_1100_11,
+       10'b1111_1100_11,
+       10'b1110_0010_11,
+       10'b1110_0010_11,
+       10'b1110_0010_11,
+       10'b1110_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1111_0010_11,
+       10'b1100_0100_11,
+       10'b1100_0100_11,
+       10'b1100_0100_11,
+       10'b1100_0100_11,
+       10'b1100_0100_11,
+       10'b1100_0100_11,
+       10'b1100_0100_11,
+       10'b1100_0100_11,
+       10'b1101_0100_11,
+       10'b1101_0100_11,
+       10'b1101_0100_11,
+       10'b1101_0100_11,
+       10'b1101_0100_11,
+       10'b1101_0100_11,
+       10'b1101_0100_11,
+       10'b1110_0100_11,
+       10'b1110_0100_11,
+       10'b1110_0100_11,
+       10'b1110_0100_11,
+       10'b1110_0100_11,
+       10'b1110_0100_11,
+       10'b1110_0100_11,
+       10'b1110_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1111_0100_11,
+       10'b1101_1000_11,
+       10'b1101_1000_11,
+       10'b1101_1000_11,
+       10'b1101_1000_11,
+       10'b1101_1000_11,
+       10'b1101_1000_11,
+       10'b1101_1000_11,
+       10'b1101_1000_11,
+       10'b1101_1000_11     // M=128
+};
+      
+      // Set lookup_entry with the explicit bits from lookup with a part select
+      if(BANDWIDTH == "LOW") begin
+         // Low Bandwidth
+         mmcm_pll_filter_lookup = lookup_low[ ((128-divide)*10) +: 10];
+      end else begin
+         // High or optimized bandwidth
+         mmcm_pll_filter_lookup = lookup_high[ ((128-divide)*10) +: 10];
+      end
+      
+   `ifdef DEBUG
+      $display("filter_lookup: %b", mmcm_pll_filter_lookup);
+   `endif
+   end
+endfunction
+
+// This function takes in the divide, phase, and duty cycle
+// setting to calculate the upper and lower counter registers.
+function [37:0] mmcm_pll_count_calc
+   (
+      input [7:0] divide, // Max divide is 128
+      input signed [31:0] phase,
+      input [31:0] duty_cycle // Multiplied by 100,000
+   );
+   
+   reg [13:0] div_calc;
+   reg [16:0] phase_calc;
+   
+   begin
+   `ifdef DEBUG
+      $display("mmcm_pll_count_calc- divide:%h, phase:%d, duty_cycle:%d",
+         divide, phase, duty_cycle);
+   `endif
+   
+      // w_edge[13], no_count[12], high_time[11:6], low_time[5:0]
+      div_calc = mmcm_pll_divider(divide, duty_cycle);
+      // mx[10:9], pm[8:6], dt[5:0]
+      phase_calc = mmcm_pll_phase(divide, phase);
+
+      // Return value is the upper and lower address of counter
+      //    Upper address is:
+      //       RESERVED    [31:26]
+      //       MX          [25:24]
+      //       EDGE        [23]
+      //       NOCOUNT     [22]
+      //       DELAY_TIME  [21:16]
+      //    Lower Address is:
+      //       PHASE_MUX   [15:13]
+      //       RESERVED    [12]
+      //       HIGH_TIME   [11:6]
+      //       LOW_TIME    [5:0]
+      
+   `ifdef DEBUG
+      $display("div:%d dc:%d phase:%d ht:%d lt:%d ed:%d nc:%d mx:%d dt:%d pm:%d",
+         divide, duty_cycle, phase, div_calc[11:6], div_calc[5:0], 
+         div_calc[13], div_calc[12], 
+         phase_calc[16:15], phase_calc[5:0], phase_calc[14:12]);
+   `endif
+      
+      mmcm_pll_count_calc =
+         {
+            // Upper Address
+            6'h00, phase_calc[10:9], div_calc[13:12], phase_calc[5:0], 
+            // Lower Address
+            phase_calc[8:6], 1'b0, div_calc[11:0]
+         };
+   end
+endfunction
+
+
+// This function takes in the divide, phase, and duty cycle
+// setting to calculate the upper and lower counter registers.
+// for fractional multiply/divide functions.
+//
+// 
+function [37:0] mmcm_frac_count_calc
+   (
+      input [7:0] divide, // Max divide is 128
+      input signed [31:0] phase,
+      input [31:0] duty_cycle, // Multiplied by 100,000. Not programmable in fractional
+      input [9:0] frac // Multiplied by 1000
+   );
+   
+	//Required for fractional divide calculations
+			  reg	[7:0]			lt_frac;
+			  reg	[7:0]			ht_frac;
+			
+			  reg	/*[7:0]*/			wf_fall_frac;
+			  reg	/*[7:0]*/			wf_rise_frac;
+
+			  reg [31:0] a;
+			  reg	[7:0]			pm_rise_frac_filtered ;
+			  reg	[7:0]			pm_fall_frac_filtered ;	
+			  reg [7:0]			clkout0_divide_int;
+			  reg [2:0]			clkout0_divide_frac;
+			  reg	[7:0]			even_part_high;
+			  reg	[7:0]			even_part_low;
+
+			  reg	[7:0]			odd;
+			  reg	[7:0]			odd_and_frac;
+
+			  reg	[7:0]			pm_fall;
+			  reg	[7:0]			pm_rise;
+			  reg	[7:0]			dt;
+			  reg	[7:0]			dt_int; 
+			  reg [63:0]		dt_calc;
+
+			  reg	[7:0]			pm_rise_frac; 
+			  reg	[7:0]			pm_fall_frac;
+	 
+			  reg [31:0] a_per_in_octets;
+			  reg [31:0] a_phase_in_cycles;
+
+				parameter precision = 0.125;
+
+			  reg [31:0] phase_fixed; // changed to 31:0 from 32:1 jt 5/2/11
+			  reg [31: 0] phase_pos;
+			  reg [31: 0] phase_vco;
+			  reg [31:0] temp;// changed to 31:0 from 32:1 jt 5/2/11
+			  reg [13:0] div_calc;
+			  reg [16:0] phase_calc;
+
+   begin
+	`ifdef DEBUG
+			$display("mmcm_frac_count_calc- divide:%h, phase:%d, duty_cycle:%d",
+				divide, phase, duty_cycle);
+	`endif
+   
+   //convert phase to fixed
+   if ((phase < -360000) || (phase > 360000)) begin
+`ifndef SYNTHESIS
+      $display("ERROR: phase of $phase is not between -360000 and 360000");
+	`endif
+      $finish;
+   end
+
+
+      // Return value is
+      //    Transfer data
+      //       RESERVED     [37:36]
+      //       FRAC_TIME    [35:33]
+      //       FRAC_WF_FALL [32]
+      //    Upper address is:
+      //       RESERVED     [31:26]
+      //       MX           [25:24]
+      //       EDGE         [23]
+      //       NOCOUNT      [22]
+      //       DELAY_TIME   [21:16]
+      //    Lower Address is:
+      //       PHASE_MUX    [15:13]
+      //       RESERVED     [12]
+      //       HIGH_TIME    [11:6]
+      //       LOW_TIME     [5:0]
+      
+      
+
+	clkout0_divide_frac = frac / 125;
+	clkout0_divide_int = divide;
+
+	even_part_high = clkout0_divide_int >> 1;//$rtoi(clkout0_divide_int / 2);
+	even_part_low = even_part_high;
+									
+	odd = clkout0_divide_int - even_part_high - even_part_low;
+	odd_and_frac = (8*odd) + clkout0_divide_frac;
+
+	lt_frac = even_part_high - (odd_and_frac <= 9);//IF(odd_and_frac>9,even_part_high, even_part_high - 1)
+	ht_frac = even_part_low  - (odd_and_frac <= 8);//IF(odd_and_frac>8,even_part_low, even_part_low- 1)
+
+	pm_fall =  {odd[6:0],2'b00} + {6'h00, clkout0_divide_frac[2:1]}; // using >> instead of clkout0_divide_frac / 2 
+	pm_rise = 0; //0
+    
+	wf_fall_frac = ((odd_and_frac >=2) && (odd_and_frac <=9)) || (clkout0_divide_int == 2 && clkout0_divide_frac == 1);   //IF(odd_and_frac>=2,IF(odd_and_frac <= 9,1,0),0)
+	wf_rise_frac = (odd_and_frac >=1) && (odd_and_frac <=8);    //IF(odd_and_frac>=1,IF(odd_and_frac <= 8,1,0),0)
+
+
+
+	//Calculate phase in fractional cycles
+	a_per_in_octets		= (8 * divide) + (frac / 125) ;
+	a_phase_in_cycles	= (phase+10) * a_per_in_octets / 360000 ;//Adding 1 due to rounding errors
+	pm_rise_frac		= (a_phase_in_cycles[7:0] ==8'h00)?8'h00:a_phase_in_cycles[7:0] - {a_phase_in_cycles[7:3],3'b000};
+
+	dt_calc 	= ((phase+10) * a_per_in_octets / 8 )/360000 ;//TRUNC(phase* divide / 360); //or_simply (a_per_in_octets / 8)
+	dt 	= dt_calc[7:0];
+
+	pm_rise_frac_filtered = (pm_rise_frac >=8) ? (pm_rise_frac ) - 8: pm_rise_frac ;				//((phase_fixed * (divide + frac / 1000)) / 360) - {pm_rise_frac[7:3],3'b000};//$rtoi(clkout0_phase * clkout0_divide / 45);//a;
+
+	dt_int			= dt + (& pm_rise_frac[7:4]); //IF(pm_rise_overwriting>7,dt+1,dt)
+	pm_fall_frac		= pm_fall + pm_rise_frac;
+	pm_fall_frac_filtered	= pm_fall + pm_rise_frac - {pm_fall_frac[7:3], 3'b000};
+
+	div_calc	= mmcm_pll_divider(divide, duty_cycle); //Use to determine edge[7], no count[6]
+	phase_calc	= mmcm_pll_phase(divide, phase);// returns{mx[1:0], phase_mux[2:0], delay_time[5:0]}
+		
+      mmcm_frac_count_calc[37:0] =
+         {		2'b00, pm_fall_frac_filtered[2:0], wf_fall_frac,
+			1'b0, clkout0_divide_frac[2:0], 1'b1, wf_rise_frac, phase_calc[10:9], 2'b00, dt[5:0], 
+			pm_rise_frac_filtered[2], pm_rise_frac_filtered[1], pm_rise_frac_filtered[0], 1'b0, ht_frac[5:0], lt_frac[5:0]
+		} ;
+
+   `ifdef DEBUG
+      $display("-%d.%d p%d>>  :DADDR_9_15 frac30to28.frac_en.wf_r_frac.dt:%b%d%d_%b:DADDR_7_13 pm_f_frac_filtered_29to27.wf_f_frac_26:%b%d:DADDR_8_14.pm_r_frac_filt_15to13.ht_frac.lt_frac:%b%b%b:", divide, frac, phase, clkout0_divide_frac, 1, wf_rise_frac, dt, pm_fall_frac_filtered, wf_fall_frac, pm_rise_frac_filtered, ht_frac, lt_frac);
+   `endif
+
+   end
+endfunction
+
diff --git a/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_us_plus_pll.vh b/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_us_plus_pll.vh
new file mode 100755
index 000000000..1d2dc6909
--- /dev/null
+++ b/projects/antsdre200/ip/gen_clks/mmcm_pll_drp_func_us_plus_pll.vh
@@ -0,0 +1,536 @@
+///////////////////////////////////////////////////////////////////////////////
+//    
+//    Company:          Xilinx
+//    Engineer:         Jim Tatsukawa, Ralf Krueger, updated for Ultrascale+ 
+//    Date:             6/15/2015
+//    Design Name:      PLLE4 DRP
+//    Module Name:      plle4_drp_func.h
+//    Version:          2.0
+//    Target Devices:   UltraScale+ Architecture
+//    Tool versions:    2017.1
+//    Description:      This header provides the functions necessary to  
+//                      calculate the DRP register values for the V6 PLL.
+//                      
+//	Revision Notes:	8/11 - PLLE3 updated for PLLE3 file 4564419
+//	Revision Notes:	6/15 - pll_filter_lookup fixed for max M of 19
+//                           M_Rise bits have been removed for PLLE3
+//	Revision Notes:	2/28/17 - pll_filter_lookup and CPRES updated for 
+//                           Ultrascale+ and for max M of 21
+// 
+//    Disclaimer:  XILINX IS PROVIDING THIS DESIGN, CODE, OR
+//                 INFORMATION "AS IS" SOLELY FOR USE IN DEVELOPING
+//                 PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY
+//                 PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+//                 ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+//                 APPLICATION OR STANDARD, XILINX IS MAKING NO
+//                 REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+//                 FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE
+//                 RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY
+//                 REQUIRE FOR YOUR IMPLEMENTATION.  XILINX
+//                 EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH
+//                 RESPECT TO THE ADEQUACY OF THE IMPLEMENTATION,
+//                 INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+//                 REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE
+//                 FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES
+//                 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+//                 PURPOSE.
+// 
+//                 (c) Copyright 2009-2017 Xilinx, Inc.
+//                 All rights reserved.
+// 
+///////////////////////////////////////////////////////////////////////////////
+
+// These are user functions that should not be modified.  Changes to the defines
+// or code within the functions may alter the accuracy of the calculations.
+
+// Define debug to provide extra messages durring elaboration
+//`define DEBUG 1
+
+// FRAC_PRECISION describes the width of the fractional portion of the fixed
+//    point numbers.  These should not be modified, they are for development 
+//    only
+`define FRAC_PRECISION  10
+// FIXED_WIDTH describes the total size for fixed point calculations(int+frac).
+// Warning: L.50 and below will not calculate properly with FIXED_WIDTHs 
+//    greater than 32
+`define FIXED_WIDTH     32 
+
+// This function takes a fixed point number and rounds it to the nearest
+//    fractional precision bit.
+function [`FIXED_WIDTH:1] round_frac
+   (
+      // Input is (FIXED_WIDTH-FRAC_PRECISION).FRAC_PRECISION fixed point number
+      input [`FIXED_WIDTH:1] decimal,  
+
+      // This describes the precision of the fraction, for example a value
+      //    of 1 would modify the fractional so that instead of being a .16
+      //    fractional, it would be a .1 (rounded to the nearest 0.5 in turn)
+      input [`FIXED_WIDTH:1] precision 
+   );
+
+   begin
+   
+   `ifdef DEBUG
+      $display("round_frac - decimal: %h, precision: %h", decimal, precision);
+   `endif
+      // If the fractional precision bit is high then round up
+      if( decimal[(`FRAC_PRECISION-precision)] == 1'b1) begin
+         round_frac = decimal + (1'b1 << (`FRAC_PRECISION-precision));
+      end else begin
+         round_frac = decimal;
+      end
+   `ifdef DEBUG
+      $display("round_frac: %h", round_frac);
+   `endif
+   end
+endfunction
+
+// This function calculates high_time, low_time, w_edge, and no_count
+//    of a non-fractional counter based on the divide and duty cycle
+//
+// NOTE: high_time and low_time are returned as integers between 0 and 63 
+//    inclusive.  64 should equal 6'b000000 (in other words it is okay to 
+//    ignore the overflow)
+function [13:0] mmcm_pll_divider
+   (
+      input [7:0] divide,        // Max divide is 128
+      input [31:0] duty_cycle    // Duty cycle is multiplied by 100,000
+   );
+
+   reg [`FIXED_WIDTH:1]    duty_cycle_fix;
+   
+   // High/Low time is initially calculated with a wider integer to prevent a
+   // calculation error when it overflows to 64.
+   reg [6:0]               high_time;
+   reg [6:0]               low_time;
+   reg                     w_edge;
+   reg                     no_count;
+
+   reg [`FIXED_WIDTH:1]    temp;
+
+   begin
+      // Duty Cycle must be between 0 and 1,000
+      if(duty_cycle <=0 || duty_cycle >= 100000) begin
+`ifndef SYNTHESIS
+         $display("ERROR: duty_cycle: %d is invalid", duty_cycle);
+   `endif
+         $finish;
+      end
+
+      // Convert to FIXED_WIDTH-FRAC_PRECISION.FRAC_PRECISION fixed point
+      duty_cycle_fix = (duty_cycle << `FRAC_PRECISION) / 100_000;
+      
+   `ifdef DEBUG
+      $display("duty_cycle_fix: %h", duty_cycle_fix);
+   `endif
+
+      // If the divide is 1 nothing needs to be set except the no_count bit.
+      //    Other values are dummies
+      if(divide == 7'h01) begin
+         high_time   = 7'h01;
+         w_edge      = 1'b0;
+         low_time    = 7'h01;
+         no_count    = 1'b1;
+      end else begin
+         temp = round_frac(duty_cycle_fix*divide, 1);
+
+         // comes from above round_frac
+         high_time   = temp[`FRAC_PRECISION+7:`FRAC_PRECISION+1]; 
+         // If the duty cycle * divide rounded is .5 or greater then this bit
+         //    is set.
+         w_edge      = temp[`FRAC_PRECISION]; // comes from round_frac
+         
+         // If the high time comes out to 0, it needs to be set to at least 1
+         // and w_edge set to 0
+         if(high_time == 7'h00) begin
+            high_time   = 7'h01;
+            w_edge      = 1'b0;
+         end
+
+         if(high_time == divide) begin
+            high_time   = divide - 1;
+            w_edge      = 1'b1;
+         end
+         
+         // Calculate low_time based on the divide setting and set no_count to
+         //    0 as it is only used when divide is 1.
+         low_time    = divide - high_time; 
+         no_count    = 1'b0;
+      end
+
+      // Set the return value.
+      mmcm_pll_divider = {w_edge,no_count,high_time[5:0],low_time[5:0]};
+   end
+endfunction
+
+// This function calculates mx, delay_time, and phase_mux 
+//  of a non-fractional counter based on the divide and phase
+//
+// NOTE: The only valid value for the MX bits is 2'b00 to ensure the coarse mux
+//    is used.
+function [10:0] mmcm_pll_phase
+   (
+      // divide must be an integer (use fractional if not)
+      //  assumed that divide already checked to be valid
+      input [7:0] divide, // Max divide is 128
+
+      // Phase is given in degrees (-360,000 to 360,000)
+      input signed [31:0] phase
+   );
+
+   reg [`FIXED_WIDTH:1] phase_in_cycles;
+   reg [`FIXED_WIDTH:1] phase_fixed;
+   reg [1:0]            mx;
+   reg [5:0]            delay_time;
+   reg [2:0]            phase_mux;
+
+   reg [`FIXED_WIDTH:1] temp;
+
+   begin
+`ifdef DEBUG
+      $display("pll_phase-divide:%d,phase:%d",
+         divide, phase);
+`endif
+   
+      if ((phase < -360000) || (phase > 360000)) begin
+`ifndef SYNTHESIS
+         $display("ERROR: phase of $phase is not between -360000 and 360000");
+`endif
+         $finish;
+      end
+
+      // If phase is less than 0, convert it to a positive phase shift
+      // Convert to (FIXED_WIDTH-FRAC_PRECISION).FRAC_PRECISION fixed point
+      if(phase < 0) begin
+         phase_fixed = ( (phase + 360000) << `FRAC_PRECISION ) / 1000;
+      end else begin
+         phase_fixed = ( phase << `FRAC_PRECISION ) / 1000;
+      end
+
+      // Put phase in terms of decimal number of vco clock cycles
+      phase_in_cycles = ( phase_fixed * divide ) / 360;
+
+`ifdef DEBUG
+      $display("phase_in_cycles: %h", phase_in_cycles);
+`endif  
+      
+
+	 temp  =  round_frac(phase_in_cycles, 3);
+
+	 // set mx to 2'b00 that the phase mux from the VCO is enabled
+	 mx    			=  2'b00; 
+	 phase_mux      =  temp[`FRAC_PRECISION:`FRAC_PRECISION-2];
+	 delay_time     =  temp[`FRAC_PRECISION+6:`FRAC_PRECISION+1];
+      
+   `ifdef DEBUG
+      $display("temp: %h", temp);
+   `endif
+
+      // Setup the return value
+      mmcm_pll_phase={mx, phase_mux, delay_time};
+   end
+endfunction
+
+// This function takes the divide value and outputs the necessary lock values
+function [39:0] mmcm_pll_lock_lookup
+   (
+      input [6:0] divide // Max divide is 21
+   );
+   
+   reg [839:0]   lookup;
+   
+   begin
+      lookup = {
+         // This table is composed of:
+         // LockRefDly_LockFBDly_LockCnt_LockSatHigh_UnlockCnt
+         40'b00110_00110_1111101000_1111101001_0000000001, //1 illegal in Ultrascale+
+         40'b00110_00110_1111101000_1111101001_0000000001, //2
+         40'b01000_01000_1111101000_1111101001_0000000001, //3
+         40'b01011_01011_1111101000_1111101001_0000000001, //4
+         40'b01110_01110_1111101000_1111101001_0000000001, //5
+         40'b10001_10001_1111101000_1111101001_0000000001, //6
+         40'b10011_10011_1111101000_1111101001_0000000001, //7
+         40'b10110_10110_1111101000_1111101001_0000000001, //8
+         40'b11001_11001_1111101000_1111101001_0000000001, //9
+         40'b11100_11100_1111101000_1111101001_0000000001, //10
+         40'b11111_11111_1110000100_1111101001_0000000001, //11
+         40'b11111_11111_1100111001_1111101001_0000000001, //12
+         40'b11111_11111_1011101110_1111101001_0000000001, //13
+         40'b11111_11111_1010111100_1111101001_0000000001, //14
+         40'b11111_11111_1010001010_1111101001_0000000001, //15
+         40'b11111_11111_1001110001_1111101001_0000000001, //16
+         40'b11111_11111_1000111111_1111101001_0000000001, //17
+         40'b11111_11111_1000100110_1111101001_0000000001, //18
+         40'b11111_11111_1000001101_1111101001_0000000001, //19
+         40'b11111_11111_0111110100_1111101001_0000000001, //20
+         40'b11111_11111_0111011011_1111101001_0000000001  //21
+      };
+      
+      // Set lookup_entry with the explicit bits from lookup with a part select
+      mmcm_pll_lock_lookup = lookup[ ((21-divide)*40) +: 40];
+   `ifdef DEBUG
+      $display("lock_lookup: %b", pll_lock_lookup);
+   `endif
+   end
+endfunction
+
+// This function takes the divide value and the bandwidth setting of the PLL
+//  and outputs the digital filter settings necessary. Removing bandwidth setting for PLLE3.
+function [9:0] mmcm_pll_filter_lookup
+   (
+      input [6:0] divide // Max divide is 21
+   );
+   
+   reg [209:0] lookup;
+   reg [9:0] lookup_entry;
+   
+   begin
+
+      lookup = {
+         // CP_RES_LFHF
+         10'b0011_0111_11, //1  not legal in Ultrascale+
+         10'b0011_0111_11, //2
+         10'b0011_0011_11, //3
+         10'b0011_1001_11, //4
+         10'b0011_0001_11, //5
+         10'b0100_1110_11, //6
+         10'b0011_0110_11, //7
+         10'b0011_1010_11, //8
+         10'b0111_1001_11, //9
+         10'b0111_1001_11, //10
+         10'b0101_0110_11, //11
+         10'b1100_0101_11, //12
+         10'b0101_1010_11, //13
+         10'b0110_0110_11, //14
+         10'b0110_1010_11, //15
+         10'b0111_0110_11, //16
+         10'b1111_0101_11, //17
+         10'b1100_0110_11, //18
+         10'b1110_0001_11, //19
+         10'b1101_0110_11, //20
+         10'b1111_0001_11  //21
+      };
+      
+         mmcm_pll_filter_lookup = lookup [ ((21-divide)*10) +: 10];
+      
+   `ifdef DEBUG
+      $display("filter_lookup: %b", pll_filter_lookup);
+   `endif
+   end
+endfunction
+
+// This function set the CLKOUTPHY divide settings to match
+// the desired CLKOUTPHY_MODE setting. To create VCO_X2, then
+// the CLKOUTPHY will be set to 2'b00 since the VCO is internally
+// doubled and 2'b00 will represent divide by 1. Similarly "VCO" 
+// will need to divide the doubled clock VCO clock frequency by 
+// 2 therefore 2'b01 will match a divide by 2.And VCO_HALF will 
+// need to divide the doubled VCO by 4, therefore 2'b10
+function [9:0] mmcm_pll_clkoutphy_calc
+   (
+      input [8*9:0] CLKOUTPHY_MODE
+   );
+
+      if(CLKOUTPHY_MODE == "VCO_X2") begin
+         mmcm_pll_clkoutphy_calc= 2'b00;
+      end else if(CLKOUTPHY_MODE == "VCO") begin
+         mmcm_pll_clkoutphy_calc= 2'b01;
+      end else if(CLKOUTPHY_MODE == "CLKIN") begin
+         mmcm_pll_clkoutphy_calc= 2'b11;
+      end else begin // Assume "VCO_HALF"
+         mmcm_pll_clkoutphy_calc= 2'b10;
+      end
+      
+endfunction
+
+
+// This function takes in the divide, phase, and duty cycle
+// setting to calculate the upper and lower counter registers.
+function [37:0] mmcm_pll_count_calc
+   (
+      input [7:0] divide, // Max divide is 128
+      input signed [31:0] phase,
+      input [31:0] duty_cycle // Multiplied by 100,000
+   );
+   
+   reg [13:0] div_calc;
+   reg [16:0] phase_calc;
+   
+   begin
+   `ifdef DEBUG
+      $display("pll_count_calc- divide:%h, phase:%d, duty_cycle:%d",
+         divide, phase, duty_cycle);
+   `endif
+   
+      // w_edge[13], no_count[12], high_time[11:6], low_time[5:0]
+      div_calc = mmcm_pll_divider(divide, duty_cycle);
+      // mx[10:9], pm[8:6], dt[5:0]
+      phase_calc = mmcm_pll_phase(divide, phase);
+
+      // Return value is the upper and lower address of counter
+      //    Upper address is:
+      //       RESERVED    [31:26]
+      //       MX          [25:24]
+      //       EDGE        [23]
+      //       NOCOUNT     [22]
+      //       DELAY_TIME  [21:16]
+      //    Lower Address is:
+      //       PHASE_MUX   [15:13]
+      //       RESERVED    [12]
+      //       HIGH_TIME   [11:6]
+      //       LOW_TIME    [5:0]
+      
+   `ifdef DEBUG
+      $display("div:%d dc:%d phase:%d ht:%d lt:%d ed:%d nc:%d mx:%d dt:%d pm:%d",
+         divide, duty_cycle, phase, div_calc[11:6], div_calc[5:0], 
+         div_calc[13], div_calc[12], 
+         phase_calc[16:15], phase_calc[5:0], 3'b000); //Removed PM_Rise bits
+   `endif
+      
+      mmcm_pll_count_calc =
+         {
+            // Upper Address
+            6'h00, phase_calc[10:9], div_calc[13:12], phase_calc[5:0], 
+            // Lower Address
+            phase_calc[8:6], 1'b0, div_calc[11:0]
+         };
+   end
+endfunction
+
+
+// This function takes in the divide, phase, and duty cycle
+// setting to calculate the upper and lower counter registers.
+// for fractional multiply/divide functions.
+//
+// 
+function [37:0] mmcm_pll_frac_count_calc
+   (
+      input [7:0] divide, // Max divide is 128
+      input signed [31:0] phase,
+      input [31:0] duty_cycle, // Multiplied by 1,000
+      input [9:0] frac // Multiplied by 1000
+   );
+   
+	//Required for fractional divide calculations
+			  reg	[7:0]			lt_frac;
+			  reg	[7:0]			ht_frac;
+			
+			  reg	/*[7:0]*/			wf_fall_frac;
+			  reg	/*[7:0]*/			wf_rise_frac;
+
+			  reg [31:0] a;
+			  reg	[7:0]			pm_rise_frac_filtered ;
+			  reg	[7:0]			pm_fall_frac_filtered ;	
+			  reg [7:0]			clkout0_divide_int;
+			  reg [2:0]			clkout0_divide_frac;
+			  reg	[7:0]			even_part_high;
+			  reg	[7:0]			even_part_low;
+
+			  reg	[7:0]			odd;
+			  reg	[7:0]			odd_and_frac;
+
+			  reg	[7:0]			pm_fall;
+			  reg	[7:0]			pm_rise;
+			  reg	[7:0]			dt;
+			  reg	[7:0]			dt_int; 
+			  reg [63:0]		dt_calc;
+
+			  reg	[7:0]			pm_rise_frac; 
+			  reg	[7:0]			pm_fall_frac;
+	 
+			  reg [31:0] a_per_in_octets;
+			  reg [31:0] a_phase_in_cycles;
+
+				parameter precision = 0.125;
+
+			  reg [31:0] phase_fixed; // changed to 31:0 from 32:1 jt 5/2/11
+			  reg [31: 0] phase_pos;
+			  reg [31: 0] phase_vco;
+			  reg [31:0] temp;// changed to 31:0 from 32:1 jt 5/2/11
+			  reg [13:0] div_calc;
+			  reg [16:0] phase_calc;
+
+   begin
+	`ifdef DEBUG
+			$display("pll_frac_count_calc- divide:%h, phase:%d, duty_cycle:%d",
+				divide, phase, duty_cycle);
+	`endif
+   
+   //convert phase to fixed
+   if ((phase < -360000) || (phase > 360000)) begin
+`ifndef SYNTHESIS
+      $display("ERROR: phase of $phase is not between -360000 and 360000");
+	`endif
+      $finish;
+   end
+
+
+      // Return value is
+      //    Transfer data
+      //       RESERVED     [37:36]
+      //       FRAC_TIME    [35:33]
+      //       FRAC_WF_FALL [32]
+      //    Upper address is:
+      //       RESERVED     [31:26]
+      //       MX           [25:24]
+      //       EDGE         [23]
+      //       NOCOUNT      [22]
+      //       DELAY_TIME   [21:16]
+      //    Lower Address is:
+      //       PHASE_MUX    [15:13]
+      //       RESERVED     [12]
+      //       HIGH_TIME    [11:6]
+      //       LOW_TIME     [5:0]
+      
+      
+
+	clkout0_divide_frac = frac / 125;
+	clkout0_divide_int = divide;
+
+	even_part_high = clkout0_divide_int >> 1;//$rtoi(clkout0_divide_int / 2);
+	even_part_low = even_part_high;
+									
+	odd = clkout0_divide_int - even_part_high - even_part_low;
+	odd_and_frac = (8*odd) + clkout0_divide_frac;
+
+	lt_frac = even_part_high - (odd_and_frac <= 9);//IF(odd_and_frac>9,even_part_high, even_part_high - 1)
+	ht_frac = even_part_low  - (odd_and_frac <= 8);//IF(odd_and_frac>8,even_part_low, even_part_low- 1)
+
+	pm_fall =  {odd[6:0],2'b00} + {6'h00, clkout0_divide_frac[2:1]}; // using >> instead of clkout0_divide_frac / 2 
+	pm_rise = 0; //0
+    
+	wf_fall_frac = (odd_and_frac >=2) && (odd_and_frac <=9);//IF(odd_and_frac>=2,IF(odd_and_frac <= 9,1,0),0)
+	wf_rise_frac = (odd_and_frac >=1) && (odd_and_frac <=8);//IF(odd_and_frac>=1,IF(odd_and_frac <= 8,1,0),0)
+
+
+
+	//Calculate phase in fractional cycles
+	a_per_in_octets		= (8 * divide) + (frac / 125) ;
+	a_phase_in_cycles	= (phase+10) * a_per_in_octets / 360000 ;//Adding 1 due to rounding errors
+	pm_rise_frac		= (a_phase_in_cycles[7:0] ==8'h00)?8'h00:a_phase_in_cycles[7:0] - {a_phase_in_cycles[7:3],3'b000};
+
+	dt_calc 	= ((phase+10) * a_per_in_octets / 8 )/360000 ;//TRUNC(phase* divide / 360); //or_simply (a_per_in_octets / 8)
+	dt 	= dt_calc[7:0];
+
+	pm_rise_frac_filtered = (pm_rise_frac >=8) ? (pm_rise_frac ) - 8: pm_rise_frac ;				//((phase_fixed * (divide + frac / 1000)) / 360) - {pm_rise_frac[7:3],3'b000};//$rtoi(clkout0_phase * clkout0_divide / 45);//a;
+
+	dt_int			= dt + (& pm_rise_frac[7:4]); //IF(pm_rise_overwriting>7,dt+1,dt)
+	pm_fall_frac		= pm_fall + pm_rise_frac;
+	pm_fall_frac_filtered	= pm_fall + pm_rise_frac - {pm_fall_frac[7:3], 3'b000};
+
+	div_calc	= mmcm_pll_divider(divide, duty_cycle); //Use to determine edge[7], no count[6]
+	phase_calc	= mmcm_pll_phase(divide, phase);// returns{mx[1:0], phase_mux[2:0], delay_time[5:0]}
+		
+      mmcm_pll_frac_count_calc[37:0] =
+         {		2'b00, pm_fall_frac_filtered[2:0], wf_fall_frac,
+			1'b0, clkout0_divide_frac[2:0], 1'b1, wf_rise_frac, phase_calc[10:9], div_calc[13:12], dt[5:0], 
+			3'b000, 1'b0, ht_frac[5:0], lt_frac[5:0] //Removed PM_Rise bits
+		} ;
+
+   `ifdef DEBUG
+      $display("-%d.%d p%d>>  :DADDR_9_15 frac30to28.frac_en.wf_r_frac.dt:%b%d%d_%b:DADDR_7_13 pm_f_frac_filtered_29to27.wf_f_frac_26:%b%d:DADDR_8_14.pm_r_frac_filt_15to13.ht_frac.lt_frac:%b%b%b:", divide, frac, phase, clkout0_divide_frac, 1, wf_rise_frac, dt, pm_fall_frac_filtered, wf_fall_frac, 3'b000, ht_frac, lt_frac);
+   `endif
+
+   end
+endfunction
+
diff --git a/projects/antsdre200/ltc2630_spi.v b/projects/antsdre200/ltc2630_spi.v
new file mode 100644
index 000000000..43ee8fcc2
--- /dev/null
+++ b/projects/antsdre200/ltc2630_spi.v
@@ -0,0 +1,151 @@
+module ltc2630_spi  (
+    input   wire            clk,
+    input   wire            rst,
+    input   wire  [15:0]    data,
+    output  reg             sclk,
+    output  wire            mosi,
+    output  reg             sync_n
+);
+
+    //====================================================
+    //parameter define
+    //====================================================
+    localparam  IDLE        = 4'b0001;
+    localparam  SYNC_PRE    = 4'b0010;
+    localparam  DATA        = 4'b0100;
+    localparam  SYNC_END    = 4'b1000;
+
+    //====================================================
+    // internal signals and registers
+    //====================================================
+    reg     [3:0]   state;
+    reg     [3:0]   cnt_cycle   ;
+    reg     [5:0]   cnt_bit     ;
+    reg     [15:0]  last_data   ;
+    reg     [23:0]  data_shift  ;
+    wire            rising_edge ;
+    wire            falling_edge;
+
+
+    //----------------state------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            state <= IDLE;
+        end
+        else  begin
+            case (state)
+                IDLE : begin
+                    // detect a new data input, the dac value needs to be updated
+                    if (last_data != data) begin
+                        state <= SYNC_PRE;
+                    end
+                end
+
+                SYNC_PRE : begin
+                    // The SYNC is low, start to update the value
+                    if (falling_edge) begin
+                        state <= DATA;
+                    end
+                end
+
+                DATA : begin
+                    if (cnt_bit == 'd23 && falling_edge) begin
+                        state <= SYNC_END;
+                    end
+                end
+
+                SYNC_END : begin
+                    if (rising_edge == 1'b1) begin
+                        state <= IDLE;
+                    end
+                end
+            endcase
+        end
+    end
+
+    //----------------cnt_cycle------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            cnt_cycle <= 'd0;
+        end
+        else if (state == SYNC_PRE || state == DATA || state == SYNC_END) begin
+            cnt_cycle <= cnt_cycle + 1'b1;
+        end
+        else  begin
+            cnt_cycle <=  'd0;
+        end
+    end
+
+    assign rising_edge = cnt_cycle==4'b1000;
+    assign falling_edge = cnt_cycle==4'b1111;
+
+    //----------------data_shift------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            data_shift <= 'd0;
+        end
+        else if (state == IDLE && (last_data != data)) begin
+            data_shift <= {4'b0011, 4'b0000, data};
+        end
+        else if (state == DATA && falling_edge) begin
+            data_shift <=  {data_shift[22:0], 1'b0};
+        end
+    end
+
+    //----------------cnt_bit------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            cnt_bit <= 'd0;
+        end
+        else if (state == DATA ) begin
+            if (cnt_bit == 'd23 && falling_edge) begin
+                cnt_bit <= 'd0;
+            end
+            else if(falling_edge)begin
+                cnt_bit <= cnt_bit + 1'b1;
+            end
+        end
+        else  begin
+            cnt_bit <=  'd0;
+        end
+    end
+
+    //----------------last_data------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            last_data <= 'd0;
+        end
+        else if (state == IDLE && (last_data != data)) begin
+            last_data <= data;
+        end
+    end
+
+    //-----------------sclk-----------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            sclk <= 1'b0;
+        end
+        else if (state==DATA && rising_edge == 1'b1) begin
+            sclk <= 1'b1;
+        end
+        else if (state==DATA && falling_edge == 1'b1) begin
+            sclk <=  1'b0;
+        end
+    end
+
+    assign mosi = data_shift[23];
+
+    //----------------sync_n------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            sync_n <= 1'b1;
+        end
+        else if (state == SYNC_PRE && falling_edge == 1'b1) begin
+            sync_n <= 1'b0;
+        end
+        else if (state == SYNC_END && rising_edge == 1'b1) begin
+            sync_n <=  1'b1;
+        end
+    end
+    
+endmodule
\ No newline at end of file
diff --git a/projects/antsdre200/system_bd.tcl b/projects/antsdre200/system_bd.tcl
new file mode 100644
index 000000000..c7751d395
--- /dev/null
+++ b/projects/antsdre200/system_bd.tcl
@@ -0,0 +1,333 @@
+# create board design
+
+
+source $ad_hdl_dir/projects/common/xilinx/adi_fir_filter_bd.tcl
+
+# default ports
+
+create_bd_intf_port -mode Master -vlnv xilinx.com:interface:ddrx_rtl:1.0 ddr
+create_bd_intf_port -mode Master -vlnv xilinx.com:display_processing_system7:fixedio_rtl:1.0 fixed_io
+
+create_bd_intf_port -mode Master -vlnv xilinx.com:interface:mdio_rtl:1.0 MDIO_PHY
+create_bd_intf_port -mode Master -vlnv xilinx.com:interface:rgmii_rtl:1.0 RGMII
+
+create_bd_port -dir O eth_rst_n
+
+create_bd_port -dir O spi0_csn_2_o
+create_bd_port -dir O spi0_csn_1_o
+create_bd_port -dir O spi0_csn_0_o
+create_bd_port -dir I spi0_csn_i
+create_bd_port -dir I spi0_clk_i
+create_bd_port -dir O spi0_clk_o
+create_bd_port -dir I spi0_sdo_i
+create_bd_port -dir O spi0_sdo_o
+create_bd_port -dir I spi0_sdi_i
+
+create_bd_port -dir I -from 24 -to 0 gpio_i
+create_bd_port -dir O -from 24 -to 0 gpio_o
+create_bd_port -dir O -from 24 -to 0 gpio_t
+
+
+# instance: sys_ps7
+
+ad_ip_instance processing_system7 sys_ps7
+
+# ps7 settings
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_PRESET_BANK0_VOLTAGE {LVCMOS 3.3V}
+ad_ip_parameter sys_ps7 CONFIG.PCW_PRESET_BANK1_VOLTAGE {LVCMOS 3.3V}
+ad_ip_parameter sys_ps7 CONFIG.PCW_PACKAGE_NAME clg400
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_MIO_GPIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_ENET0_IO "EMIO"
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_GRP_MDIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_GRP_MDIO_IO "EMIO"
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP1 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP2 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_EN_CLK1_PORT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_EN_RST1_PORT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_FPGA0_PERIPHERAL_FREQMHZ 100.0
+ad_ip_parameter sys_ps7 CONFIG.PCW_FPGA1_PERIPHERAL_FREQMHZ 200.0
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_EMIO_GPIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_EMIO_GPIO_IO 25
+ad_ip_parameter sys_ps7 CONFIG.PCW_SPI1_PERIPHERAL_ENABLE 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_I2C0_PERIPHERAL_ENABLE 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_SD0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_SDIO_PERIPHERAL_FREQMHZ 50
+ad_ip_parameter sys_ps7 CONFIG.PCW_UART0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UART0_UART0_IO {MIO 14 .. 15}
+ad_ip_parameter sys_ps7 CONFIG.PCW_I2C1_PERIPHERAL_ENABLE 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_QSPI_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_QSPI_GRP_SINGLE_SS_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_SPI0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_SPI0_SPI0_IO EMIO
+ad_ip_parameter sys_ps7 CONFIG.PCW_TTC0_PERIPHERAL_ENABLE 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_FABRIC_INTERRUPT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_USB0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_MIO_GPIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_MIO_GPIO_IO MIO
+ad_ip_parameter sys_ps7 CONFIG.PCW_USB0_RESET_IO {MIO 47}
+ad_ip_parameter sys_ps7 CONFIG.PCW_USB0_RESET_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_IRQ_F2P_INTR 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_IRQ_F2P_MODE REVERSE
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_0_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_9_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_10_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_11_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_48_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_49_PULLUP {disabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_53_PULLUP {enabled}
+
+# DDR MT41K256M16 HA-125 (32M, 16bit, 8banks)
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_PARTNO {MT41J256M16 RE-125}
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_BUS_WIDTH {16 Bit}
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_USE_INTERNAL_VREF 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_TRAIN_WRITE_LEVEL 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_TRAIN_READ_GATE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_TRAIN_DATA_EYE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_DQS_TO_CLK_DELAY_0 0.048
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_DQS_TO_CLK_DELAY_1 0.050
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_BOARD_DELAY0 0.241
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_BOARD_DELAY1 0.240
+
+ad_ip_instance xlconcat sys_concat_intc
+ad_ip_parameter sys_concat_intc CONFIG.NUM_PORTS 16
+
+ad_ip_instance proc_sys_reset sys_rstgen
+ad_ip_parameter sys_rstgen CONFIG.C_EXT_RST_WIDTH 1
+
+# system reset/clock definitions
+
+# add external ethernet phy
+ad_ip_instance gmii_to_rgmii sys_rgmii
+ad_ip_parameter sys_rgmii CONFIG.SupportLevel Include_Shared_Logic_in_Core
+
+
+ad_connect  sys_cpu_clk sys_ps7/FCLK_CLK0
+ad_connect  sys_200m_clk sys_ps7/FCLK_CLK1
+ad_connect  sys_cpu_reset sys_rstgen/peripheral_reset
+ad_connect  sys_cpu_resetn sys_rstgen/peripheral_aresetn
+ad_connect  eth_rst_n sys_rstgen/peripheral_aresetn
+ad_connect  sys_cpu_clk sys_rstgen/slowest_sync_clk
+ad_connect  sys_rstgen/ext_reset_in sys_ps7/FCLK_RESET0_N
+ad_connect  sys_rgmii/tx_reset sys_rstgen/peripheral_reset
+ad_connect  sys_rgmii/rx_reset sys_rstgen/peripheral_reset
+ad_connect  sys_rgmii/clkin sys_ps7/FCLK_CLK1 
+ad_connect  sys_ps7/MDIO_ETHERNET_0 sys_rgmii/MDIO_GEM
+ad_connect  sys_ps7/GMII_ETHERNET_0 sys_rgmii/GMII
+ad_connect  sys_rgmii/MDIO_PHY MDIO_PHY
+ad_connect  sys_rgmii/RGMII RGMII
+
+# interface connections
+
+ad_connect  ddr sys_ps7/DDR
+ad_connect  gpio_i sys_ps7/GPIO_I
+ad_connect  gpio_o sys_ps7/GPIO_O
+ad_connect  gpio_t sys_ps7/GPIO_T
+ad_connect  fixed_io sys_ps7/FIXED_IO
+
+# ps7 spi connections
+
+ad_connect  spi0_csn_2_o sys_ps7/SPI0_SS2_O
+ad_connect  spi0_csn_1_o sys_ps7/SPI0_SS1_O
+ad_connect  spi0_csn_0_o sys_ps7/SPI0_SS_O
+ad_connect  spi0_csn_i sys_ps7/SPI0_SS_I
+ad_connect  spi0_clk_i sys_ps7/SPI0_SCLK_I
+ad_connect  spi0_clk_o sys_ps7/SPI0_SCLK_O
+ad_connect  spi0_sdo_i sys_ps7/SPI0_MOSI_I
+ad_connect  spi0_sdo_o sys_ps7/SPI0_MOSI_O
+ad_connect  spi0_sdi_i sys_ps7/SPI0_MISO_I
+
+
+# interrupts
+
+ad_connect  sys_concat_intc/dout sys_ps7/IRQ_F2P
+ad_connect  sys_concat_intc/In15 GND
+ad_connect  sys_concat_intc/In14 GND
+ad_connect  sys_concat_intc/In13 GND
+ad_connect  sys_concat_intc/In12 GND
+ad_connect  sys_concat_intc/In11 GND
+ad_connect  sys_concat_intc/In10 GND
+ad_connect  sys_concat_intc/In9 GND
+ad_connect  sys_concat_intc/In8 GND
+ad_connect  sys_concat_intc/In7 GND
+ad_connect  sys_concat_intc/In6 GND
+ad_connect  sys_concat_intc/In5 GND
+ad_connect  sys_concat_intc/In4 GND
+ad_connect  sys_concat_intc/In3 GND
+ad_connect  sys_concat_intc/In2 GND
+ad_connect  sys_concat_intc/In1 GND
+ad_connect  sys_concat_intc/In0 GND
+
+
+# ad9361
+
+create_bd_port -dir I rx_clk_in
+create_bd_port -dir I rx_frame_in
+create_bd_port -dir I -from 11 -to 0 rx_data_in
+
+create_bd_port -dir O tx_clk_out
+create_bd_port -dir O tx_frame_out
+create_bd_port -dir O -from 11 -to 0 tx_data_out
+
+create_bd_port -dir O enable
+create_bd_port -dir O txnrx
+create_bd_port -dir I up_enable
+create_bd_port -dir I up_txnrx
+
+# ad9361 core(s)
+
+ad_ip_instance axi_ad9361 axi_ad9361
+ad_ip_parameter axi_ad9361 CONFIG.ID 0
+ad_ip_parameter axi_ad9361 CONFIG.CMOS_OR_LVDS_N 1
+ad_ip_parameter axi_ad9361 CONFIG.MODE_1R1T 0
+ad_ip_parameter axi_ad9361 CONFIG.ADC_INIT_DELAY 21
+
+ad_ip_instance axi_dmac axi_ad9361_dac_dma
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_TYPE_SRC 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_TYPE_DEST 1
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.CYCLIC 1
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.AXI_SLICE_SRC 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.AXI_SLICE_DEST 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_2D_TRANSFER 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_DATA_WIDTH_DEST 64
+
+ad_add_interpolation_filter "tx_fir_interpolator" 8 2 1 {61.44} {7.68} \
+                             "$ad_hdl_dir/library/util_fir_int/coefile_int.coe"
+ad_ip_instance xlslice interp_slice
+ad_ip_instance util_upack2 tx_upack
+
+ad_ip_instance axi_dmac axi_ad9361_adc_dma
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_TYPE_SRC 2
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_TYPE_DEST 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.CYCLIC 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.SYNC_TRANSFER_START 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.AXI_SLICE_SRC 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.AXI_SLICE_DEST 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_2D_TRANSFER 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_DATA_WIDTH_SRC 64
+
+ad_add_decimation_filter "rx_fir_decimator" 8 2 1 {61.44} {61.44} \
+                         "$ad_hdl_dir/library/util_fir_int/coefile_int.coe"
+ad_ip_instance xlslice decim_slice
+ad_ip_instance util_cpack2 cpack
+
+# connections
+
+ad_connect  rx_clk_in axi_ad9361/rx_clk_in
+ad_connect  rx_frame_in axi_ad9361/rx_frame_in
+ad_connect  rx_data_in axi_ad9361/rx_data_in
+ad_connect  tx_clk_out axi_ad9361/tx_clk_out
+ad_connect  tx_frame_out axi_ad9361/tx_frame_out
+ad_connect  tx_data_out axi_ad9361/tx_data_out
+ad_connect  enable axi_ad9361/enable
+ad_connect  txnrx axi_ad9361/txnrx
+ad_connect  up_enable axi_ad9361/up_enable
+ad_connect  up_txnrx axi_ad9361/up_txnrx
+
+ad_connect  axi_ad9361/tdd_sync GND
+ad_connect  sys_200m_clk axi_ad9361/delay_clk
+ad_connect  axi_ad9361/l_clk axi_ad9361/clk
+
+ad_connect axi_ad9361/l_clk rx_fir_decimator/aclk
+
+ad_connect axi_ad9361/adc_valid_i0 rx_fir_decimator/valid_in_0
+ad_connect axi_ad9361/adc_enable_i0 rx_fir_decimator/enable_in_0
+ad_connect axi_ad9361/adc_data_i0 rx_fir_decimator/data_in_0
+ad_connect axi_ad9361/adc_valid_q0 rx_fir_decimator/valid_in_1
+ad_connect axi_ad9361/adc_enable_q0 rx_fir_decimator/enable_in_1
+ad_connect axi_ad9361/adc_data_q0 rx_fir_decimator/data_in_1
+
+ad_connect axi_ad9361/l_clk cpack/clk
+ad_connect axi_ad9361/rst cpack/reset
+
+ad_connect axi_ad9361/adc_enable_i1 cpack/enable_2
+ad_connect axi_ad9361/adc_data_i1 cpack/fifo_wr_data_2
+ad_connect axi_ad9361/adc_enable_q1 cpack/enable_3
+ad_connect axi_ad9361/adc_data_q1 cpack/fifo_wr_data_3
+
+ad_connect cpack/enable_0 rx_fir_decimator/enable_out_0
+ad_connect cpack/enable_1 rx_fir_decimator/enable_out_1
+ad_connect cpack/fifo_wr_data_0 rx_fir_decimator/data_out_0
+ad_connect cpack/fifo_wr_data_1 rx_fir_decimator/data_out_1
+ad_connect rx_fir_decimator/valid_out_0 cpack/fifo_wr_en
+
+ad_connect axi_ad9361_adc_dma/fifo_wr cpack/packed_fifo_wr
+ad_connect axi_ad9361/up_adc_gpio_out decim_slice/Din
+ad_connect rx_fir_decimator/active decim_slice/Dout
+
+ad_connect axi_ad9361/l_clk tx_fir_interpolator/aclk
+
+ad_connect axi_ad9361/dac_enable_i0 tx_fir_interpolator/dac_enable_0
+ad_connect axi_ad9361/dac_valid_i0 tx_fir_interpolator/dac_valid_0
+ad_connect axi_ad9361/dac_data_i0 tx_fir_interpolator/data_out_0
+ad_connect axi_ad9361/dac_enable_q0 tx_fir_interpolator/dac_enable_1
+ad_connect axi_ad9361/dac_valid_q0 tx_fir_interpolator/dac_valid_1
+ad_connect axi_ad9361/dac_data_q0 tx_fir_interpolator/data_out_1
+
+ad_connect  axi_ad9361/l_clk tx_upack/clk
+ad_connect  axi_ad9361/rst tx_upack/reset
+
+ad_connect  tx_upack/fifo_rd_data_0  tx_fir_interpolator/data_in_0
+ad_connect  tx_upack/enable_0  tx_fir_interpolator/enable_out_0
+ad_connect  tx_upack/fifo_rd_data_1  tx_fir_interpolator/data_in_1
+ad_connect  tx_upack/enable_1  tx_fir_interpolator/enable_out_1
+
+ad_connect axi_ad9361/dac_enable_i1 tx_upack/enable_2
+ad_connect axi_ad9361/dac_data_i1 tx_upack/fifo_rd_data_2
+ad_connect axi_ad9361/dac_enable_q1 tx_upack/enable_3
+ad_connect axi_ad9361/dac_data_q1 tx_upack/fifo_rd_data_3
+
+ad_connect tx_upack/s_axis  axi_ad9361_dac_dma/m_axis
+
+ad_ip_instance util_vector_logic logic_or [list \
+  C_OPERATION {or} \
+  C_SIZE 1]
+
+ad_connect  logic_or/Op1  tx_fir_interpolator/valid_out_0
+ad_connect  logic_or/Op2  axi_ad9361/dac_valid_i1
+ad_connect  logic_or/Res  tx_upack/fifo_rd_en
+
+ad_connect axi_ad9361/up_dac_gpio_out interp_slice/Din
+ad_connect  tx_fir_interpolator/active interp_slice/Dout
+
+ad_connect  axi_ad9361/l_clk axi_ad9361_adc_dma/fifo_wr_clk
+ad_connect  axi_ad9361/l_clk axi_ad9361_dac_dma/m_axis_aclk
+ad_connect  cpack/fifo_wr_overflow axi_ad9361/adc_dovf
+
+# interconnects
+
+ad_cpu_interconnect 0x79020000 axi_ad9361
+ad_cpu_interconnect 0x7C400000 axi_ad9361_adc_dma
+ad_cpu_interconnect 0x7C420000 axi_ad9361_dac_dma
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP1 {1}
+ad_connect sys_cpu_clk sys_ps7/S_AXI_HP1_ACLK
+ad_connect axi_ad9361_adc_dma/m_dest_axi sys_ps7/S_AXI_HP1
+
+create_bd_addr_seg -range 0x20000000 -offset 0x00000000 \
+                    [get_bd_addr_spaces axi_ad9361_adc_dma/m_dest_axi] \
+                    [get_bd_addr_segs sys_ps7/S_AXI_HP1/HP1_DDR_LOWOCM] \
+                    SEG_sys_ps7_HP1_DDR_LOWOCM
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP2 {1}
+ad_connect sys_cpu_clk sys_ps7/S_AXI_HP2_ACLK
+ad_connect axi_ad9361_dac_dma/m_src_axi sys_ps7/S_AXI_HP2
+
+create_bd_addr_seg -range 0x20000000 -offset 0x00000000 \
+                    [get_bd_addr_spaces axi_ad9361_dac_dma/m_src_axi] \
+                    [get_bd_addr_segs sys_ps7/S_AXI_HP2/HP2_DDR_LOWOCM] \
+                    SEG_sys_ps7_HP2_DDR_LOWOCM
+
+ad_connect sys_cpu_clk axi_ad9361_dac_dma/m_src_axi_aclk
+ad_connect sys_cpu_clk axi_ad9361_adc_dma/m_dest_axi_aclk
+ad_connect sys_cpu_resetn axi_ad9361_adc_dma/m_dest_axi_aresetn
+ad_connect sys_cpu_resetn axi_ad9361_dac_dma/m_src_axi_aresetn
+
+# interrupts
+
+ad_cpu_interrupt ps-13 mb-13 axi_ad9361_adc_dma/irq
+ad_cpu_interrupt ps-12 mb-12 axi_ad9361_dac_dma/irq
+
+
diff --git a/projects/antsdre200/system_constr.xdc b/projects/antsdre200/system_constr.xdc
new file mode 100644
index 000000000..72933bc75
--- /dev/null
+++ b/projects/antsdre200/system_constr.xdc
@@ -0,0 +1,121 @@
+set_property -dict {PACKAGE_PIN V6  IOSTANDARD LVCMOS33} [get_ports CLK_40M_DAC_nSYNC]   ;
+set_property -dict {PACKAGE_PIN W6  IOSTANDARD LVCMOS33} [get_ports CLK_40M_DAC_SCLK]    ;
+set_property -dict {PACKAGE_PIN V10 IOSTANDARD LVCMOS33} [get_ports CLK_40M_DAC_DIN]    ;
+set_property -dict {PACKAGE_PIN V11 IOSTANDARD LVCMOS33} [get_ports PPS_IN]             ;
+set_property -dict {PACKAGE_PIN K17 IOSTANDARD LVCMOS18} [get_ports CLK_40MHz_FPGA]     ;
+set_property -dict {PACKAGE_PIN J18 IOSTANDARD LVCMOS18} [get_ports CLKIN_10MHz]        ;
+set_property -dict {PACKAGE_PIN M20 IOSTANDARD LVCMOS18} [get_ports CLKIN_10MHz_REQ]    ;
+
+
+set_property  -dict {PACKAGE_PIN  C20   IOSTANDARD  LVCMOS18} [get_ports  RGMII_td[3]]  ;
+set_property  -dict {PACKAGE_PIN  D19   IOSTANDARD  LVCMOS18} [get_ports  RGMII_td[2]]  ;
+set_property  -dict {PACKAGE_PIN  D20   IOSTANDARD  LVCMOS18} [get_ports  RGMII_td[1]]  ;
+set_property  -dict {PACKAGE_PIN  F19   IOSTANDARD  LVCMOS18} [get_ports  RGMII_td[0]]  ;
+set_property  -dict {PACKAGE_PIN  E18   IOSTANDARD  LVCMOS18} [get_ports  RGMII_rd[3]]  ;
+set_property  -dict {PACKAGE_PIN  E19   IOSTANDARD  LVCMOS18} [get_ports  RGMII_rd[2]]  ;
+set_property  -dict {PACKAGE_PIN  E17   IOSTANDARD  LVCMOS18} [get_ports  RGMII_rd[1]]  ;
+set_property  -dict {PACKAGE_PIN  F16   IOSTANDARD  LVCMOS18} [get_ports  RGMII_rd[0]]  ;
+
+set_property  -dict {PACKAGE_PIN  F20   IOSTANDARD  LVCMOS18} [get_ports  RGMII_tx_ctl] ;
+set_property  -dict {PACKAGE_PIN  D18   IOSTANDARD  LVCMOS18} [get_ports  RGMII_txc]    ;
+set_property  -dict {PACKAGE_PIN  G17   IOSTANDARD  LVCMOS18} [get_ports  RGMII_rx_ctl] ;
+set_property  -dict {PACKAGE_PIN  H16   IOSTANDARD  LVCMOS18} [get_ports  RGMII_rxc]    ;
+set_property  -dict {PACKAGE_PIN  B19   IOSTANDARD  LVCMOS18} [get_ports  eth_rst_n]    ;
+set_property  -dict {PACKAGE_PIN  A20   IOSTANDARD  LVCMOS18} [get_ports  MDIO_PHY_mdio_io]   ;
+set_property  -dict {PACKAGE_PIN  B20   IOSTANDARD  LVCMOS18} [get_ports  MDIO_PHY_mdc]       ;
+
+set_property  -dict {PACKAGE_PIN  G15   IOSTANDARD  LVCMOS18} [get_ports  tx_amp_en]  ;
+
+create_clock -period  8.000          [get_ports RGMII_rxc] 
+
+set_property  -dict {PACKAGE_PIN    T15   IOSTANDARD LVCMOS18} [get_ports gpio_status[7]]                    ; 
+set_property  -dict {PACKAGE_PIN    K16   IOSTANDARD LVCMOS18} [get_ports gpio_status[6]]                    ; 
+set_property  -dict {PACKAGE_PIN    P14   IOSTANDARD LVCMOS18} [get_ports gpio_status[5]]                    ; 
+set_property  -dict {PACKAGE_PIN    P15   IOSTANDARD LVCMOS18} [get_ports gpio_status[4]]                    ; 
+set_property  -dict {PACKAGE_PIN    R14   IOSTANDARD LVCMOS18} [get_ports gpio_status[3]]                    ; 
+set_property  -dict {PACKAGE_PIN    J16   IOSTANDARD LVCMOS18} [get_ports gpio_status[2]]                    ; 
+set_property  -dict {PACKAGE_PIN    J15   IOSTANDARD LVCMOS18} [get_ports gpio_status[1]]                    ; 
+set_property  -dict {PACKAGE_PIN    T10   IOSTANDARD LVCMOS18} [get_ports gpio_status[0]]                    ; 
+set_property  -dict {PACKAGE_PIN    T11   IOSTANDARD LVCMOS18} [get_ports gpio_ctl[3]]                       ; 
+set_property  -dict {PACKAGE_PIN    V13   IOSTANDARD LVCMOS18} [get_ports gpio_ctl[2]]                       ; 
+set_property  -dict {PACKAGE_PIN    T14   IOSTANDARD LVCMOS18} [get_ports gpio_ctl[1]]                       ; 
+set_property  -dict {PACKAGE_PIN    U13   IOSTANDARD LVCMOS18} [get_ports gpio_ctl[0]]                       ; 
+set_property  -dict {PACKAGE_PIN    P16   IOSTANDARD LVCMOS18} [get_ports gpio_en_agc]                       ; 
+set_property  -dict {PACKAGE_PIN    U20   IOSTANDARD LVCMOS18} [get_ports gpio_sync]                         ; 
+set_property  -dict {PACKAGE_PIN    T17   IOSTANDARD LVCMOS18} [get_ports gpio_resetb]                       ; 
+set_property  -dict {PACKAGE_PIN    R18   IOSTANDARD LVCMOS18} [get_ports enable]                            ; 
+set_property  -dict {PACKAGE_PIN    N17   IOSTANDARD LVCMOS18} [get_ports txnrx]                             ; 
+
+set_property  -dict {PACKAGE_PIN    T20   IOSTANDARD LVCMOS18  PULLTYPE PULLUP} [get_ports spi_csn]          ; 
+set_property  -dict {PACKAGE_PIN    R19   IOSTANDARD LVCMOS18} [get_ports spi_clk]                           ; 
+set_property  -dict {PACKAGE_PIN    P18   IOSTANDARD LVCMOS18} [get_ports spi_mosi]                          ; 
+set_property  -dict {PACKAGE_PIN    T19   IOSTANDARD LVCMOS18} [get_ports spi_miso]                          ; 
+
+
+
+
+
+# constraints (pzsdr2.e)
+# ad9361
+
+set_property  -dict {PACKAGE_PIN  N20  IOSTANDARD LVCMOS18 }     [get_ports rx_clk_in]       ; 
+set_property  -dict {PACKAGE_PIN  P20  IOSTANDARD LVCMOS18 }     [get_ports rx_clk_in_n]     ; 
+set_property  -dict {PACKAGE_PIN  Y16  IOSTANDARD LVCMOS18 }     [get_ports rx_frame_in]     ; 
+set_property  -dict {PACKAGE_PIN  W14  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[11]]  ; 
+set_property  -dict {PACKAGE_PIN  Y14  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[10]]  ; 
+set_property  -dict {PACKAGE_PIN  V20  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[9]]   ; 
+set_property  -dict {PACKAGE_PIN  W20  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[8]]   ; 
+set_property  -dict {PACKAGE_PIN  R16  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[7]]   ; 
+set_property  -dict {PACKAGE_PIN  R17  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[6]]   ; 
+set_property  -dict {PACKAGE_PIN  W18  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[5]]   ; 
+set_property  -dict {PACKAGE_PIN  W19  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[4]]   ; 
+set_property  -dict {PACKAGE_PIN  V17  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[3]]   ; 
+set_property  -dict {PACKAGE_PIN  V18  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[2]]   ; 
+set_property  -dict {PACKAGE_PIN  Y18  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[1]]   ; 
+set_property  -dict {PACKAGE_PIN  Y19  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[0]]   ; 
+set_property  -dict {PACKAGE_PIN  N18  IOSTANDARD LVCMOS18 }     [get_ports tx_clk_out]      ; 
+set_property  -dict {PACKAGE_PIN  V16  IOSTANDARD LVCMOS18 }     [get_ports tx_frame_out]    ; 
+set_property  -dict {PACKAGE_PIN  V15  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[11]] ; 
+set_property  -dict {PACKAGE_PIN  W15  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[10]] ; 
+set_property  -dict {PACKAGE_PIN  T12  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[9]]  ; 
+set_property  -dict {PACKAGE_PIN  U12  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[8]]  ; 
+set_property  -dict {PACKAGE_PIN  V12  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[7]]  ; 
+set_property  -dict {PACKAGE_PIN  W13  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[6]]  ; 
+set_property  -dict {PACKAGE_PIN  U14  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[5]]  ; 
+set_property  -dict {PACKAGE_PIN  U15  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[4]]  ; 
+set_property  -dict {PACKAGE_PIN  U18  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[3]]  ; 
+set_property  -dict {PACKAGE_PIN  U19  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[2]]  ; 
+set_property  -dict {PACKAGE_PIN  T16  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[1]]  ; 
+set_property  -dict {PACKAGE_PIN  U17  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[0]]  ; 
+
+
+
+# TX_AMP_EN	    G15
+# FPGA_GCLK1	K17
+# EEPROM_I2C_SDA	C6
+# EEPROM_I2C_SCL	E9
+
+
+
+create_clock -name rx_clk -period  16.27 [get_ports rx_clk_in]
+create_clock -name clk_fpga_0 -period 10 [get_pins "i_system_wrapper/system_i/sys_ps7/inst/PS7_i/FCLKCLK[0]"]
+create_clock -name clk_fpga_1 -period  5 [get_pins "i_system_wrapper/system_i/sys_ps7/inst/PS7_i/FCLKCLK[1]"]
+
+create_clock -name spi0_clk      -period 40   [get_pins -hier */EMIOSPI0SCLKO]
+
+set_input_jitter clk_fpga_0 0.3
+set_input_jitter clk_fpga_1 0.15
+
+
+set_property  -dict {PACKAGE_PIN   Y9    IOSTANDARD LVCMOS33} [get_ports GPIOB[7]]                    ; 
+set_property  -dict {PACKAGE_PIN   Y6    IOSTANDARD LVCMOS33} [get_ports GPIOB[6]]                    ; 
+set_property  -dict {PACKAGE_PIN   Y7    IOSTANDARD LVCMOS33} [get_ports GPIOB[5]]                    ; 
+set_property  -dict {PACKAGE_PIN   U10   IOSTANDARD LVCMOS33} [get_ports GPIOB[4]]                    ; 
+set_property  -dict {PACKAGE_PIN   T9    IOSTANDARD LVCMOS33} [get_ports GPIOB[3]]                    ; 
+set_property  -dict {PACKAGE_PIN   V7    IOSTANDARD LVCMOS33} [get_ports GPIOB[2]]                    ; 
+set_property  -dict {PACKAGE_PIN   U7    IOSTANDARD LVCMOS33} [get_ports GPIOB[1]]                    ; 
+set_property  -dict {PACKAGE_PIN   V5    IOSTANDARD LVCMOS33} [get_ports GPIOB[0]]                    ;
+
+
+
+                                        
\ No newline at end of file
diff --git a/projects/antsdre200/system_project.tcl b/projects/antsdre200/system_project.tcl
new file mode 100644
index 000000000..dc1622654
--- /dev/null
+++ b/projects/antsdre200/system_project.tcl
@@ -0,0 +1,20 @@
+
+source ../scripts/adi_env.tcl
+source $ad_hdl_dir/projects/scripts/adi_project_xilinx.tcl
+source $ad_hdl_dir/projects/scripts/adi_board.tcl
+
+set p_device "xc7z020clg400-2"
+adi_project antsdre200
+
+adi_project_files antsdre200 [list \
+  "system_top.v" \
+  "b205_ref_pll.v" \
+  "ltc2630_spi.v" \
+  "system_constr.xdc" \
+  "./ip/gen_clks/gen_clks.xci" \
+  "$ad_hdl_dir/library/common/ad_iobuf.v"]
+
+set_property is_enabled false [get_files  *system_sys_ps7_0.xdc]
+adi_project_run antsdre200
+source $ad_hdl_dir/library/axi_ad9361/axi_ad9361_delay.tcl
+
diff --git a/projects/antsdre200/system_top.v b/projects/antsdre200/system_top.v
new file mode 100644
index 000000000..c6610a430
--- /dev/null
+++ b/projects/antsdre200/system_top.v
@@ -0,0 +1,246 @@
+// ***************************************************************************
+// ***************************************************************************
+// Copyright 2014 - 2017 (c) Analog Devices, Inc. All rights reserved.
+//
+// In this HDL repository, there are many different and unique modules, consisting
+// of various HDL (Verilog or VHDL) components. The individual modules are
+// developed independently, and may be accompanied by separate and unique license
+// terms.
+//
+// The user should read each of these license terms, and understand the
+// freedoms and responsibilities that he or she has by using this source/core.
+//
+// This core is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+// A PARTICULAR PURPOSE.
+//
+// Redistribution and use of source or resulting binaries, with or without modification
+// of this file, are permitted under one of the following two license terms:
+//
+//   1. The GNU General Public License version 2 as published by the
+//      Free Software Foundation, which can be found in the top level directory
+//      of this repository (LICENSE_GPL2), and also online at:
+//      <https://www.gnu.org/licenses/old-licenses/gpl-2.0.html>
+//
+// OR
+//
+//   2. An ADI specific BSD license, which can be found in the top level directory
+//      of this repository (LICENSE_ADIBSD), and also on-line at:
+//      https://github.com/analogdevicesinc/hdl/blob/master/LICENSE_ADIBSD
+//      This will allow to generate bit files and not release the source code,
+//      as long as it attaches to an ADI device.
+//
+// ***************************************************************************
+// ***************************************************************************
+
+`timescale 1ns/100ps
+
+module system_top (
+  output          MDIO_PHY_mdc,
+  inout           MDIO_PHY_mdio_io,
+  input [3:0]     RGMII_rd,
+  input           RGMII_rx_ctl,
+  input           RGMII_rxc,
+  output [3:0]    RGMII_td,
+  output          RGMII_tx_ctl,
+  output          RGMII_txc,
+  output          eth_rst_n ,
+
+  inout   [14:0]  ddr_addr,
+  inout   [ 2:0]  ddr_ba,
+  inout           ddr_cas_n,
+  inout           ddr_ck_n,
+  inout           ddr_ck_p,
+  inout           ddr_cke,
+  inout           ddr_cs_n,
+  inout   [ 1:0]  ddr_dm,
+  inout   [31:0]  ddr_dq,
+  inout   [ 1:0]  ddr_dqs_n,
+  inout   [ 1:0]  ddr_dqs_p,
+  inout           ddr_odt,
+  inout           ddr_ras_n,
+  inout           ddr_reset_n,
+  inout           ddr_we_n,
+
+  inout           fixed_io_ddr_vrn,
+  inout           fixed_io_ddr_vrp,
+  inout   [31:0]  fixed_io_mio,
+  inout           fixed_io_ps_clk,
+  inout           fixed_io_ps_porb,
+  inout           fixed_io_ps_srstb,
+
+  inout           iic_scl,
+  inout           iic_sda,
+
+  input           rx_clk_in,
+  input           rx_frame_in,
+  input   [11:0]  rx_data_in,
+  output          tx_clk_out,
+  output          tx_frame_out,
+  output  [11:0]  tx_data_out,
+
+  output          enable,
+  output          txnrx,
+
+  inout           gpio_resetb,
+  inout           gpio_en_agc,
+  inout   [ 3:0]  gpio_ctl,
+  inout   [ 7:0]  gpio_status,
+
+  output          spi_csn,
+  output          spi_clk,
+  output          spi_mosi,
+  input           spi_miso,
+
+
+  // clock form vctcxo
+  input  wire	 			      CLK_40MHz_FPGA  ,
+  // PPS or 10 MHz (need to choose from SW)
+  input  wire             PPS_IN          ,
+  input  wire             CLKIN_10MHz     ,
+  output wire             CLKIN_10MHz_REQ ,
+
+  // Clock disciplining / AD5662 controls
+  output wire             CLK_40M_DAC_nSYNC,
+  output wire             CLK_40M_DAC_SCLK ,
+  output wire             CLK_40M_DAC_DIN ,
+
+  output                  tx_amp_en,
+
+  inout   [7:0]           GPIOB
+  );
+
+  // internal signals
+
+  wire    [63:0]  gpio_i;
+  wire    [63:0]  gpio_o;
+  wire    [63:0]  gpio_t;
+  wire            int_40mhz   ;
+  wire            ref_pll_clk ;
+  wire            locked      ;
+  wire            ref_sel;
+  wire            ext_ref;
+  wire            ext_ref_is_pps;
+  wire            ext_ref_locked;
+
+  // instantiations
+
+  ad_iobuf #(.DATA_WIDTH(14)) i_iobuf (
+    .dio_t (gpio_t[13:0]),
+    .dio_i (gpio_o[13:0]),
+    .dio_o (gpio_i[13:0]),
+    .dio_p ({ gpio_resetb,        // 13:13
+              gpio_en_agc,        // 12:12
+              gpio_ctl,           // 11: 8
+              gpio_status}));     //  7: 0
+
+  ad_iobuf #(.DATA_WIDTH(8)) gpio_io_buf (
+    .dio_t (gpio_t[42:35]),
+    .dio_i (gpio_o[42:35]),
+    .dio_o (gpio_i[42:35]),
+    .dio_p (GPIOB       )
+    );
+
+  assign gpio_i[31:17] = gpio_o[31:17];
+
+  assign gpio_i[32] = ext_ref_locked;
+  assign ext_ref_is_pps = gpio_o[33];
+  assign ref_sel = gpio_o[34];
+
+
+  assign tx_amp_en = 1'b1;
+  assign eth_rst_n = 1'b1;
+
+  gen_clks gen_clks(
+      .clk_out1(int_40mhz),       // output clk_out1
+      .clk_out2(),                // output clk_out2
+      .clk_out3(ref_pll_clk),     // output clk_out3
+      .locked(locked),            // output locked
+
+      .clk_in1(CLK_40MHz_FPGA)
+  );
+
+
+  // vio_0 u_vio (
+  //   .clk(ref_pll_clk),                // input wire clk
+  //   .probe_in0(ext_ref_locked),    // input wire [0 : 0] probe_in0
+  //   .probe_out0(ext_ref_is_pps),  // output wire [0 : 0] probe_out0
+  //   .probe_out1(ref_sel)  // output wire [0 : 0] probe_out1
+  // );
+
+  assign ext_ref = ext_ref_is_pps ? PPS_IN : ref_sel ? CLKIN_10MHz : 1'b0;
+  b205_ref_pll ref_pll(
+      .reset(~locked),
+      .clk(ref_pll_clk),
+      .refclk(int_40mhz),
+      .ref_x(ext_ref),
+      .locked(ext_ref_locked),
+      .sclk(CLK_40M_DAC_SCLK),
+      .mosi(CLK_40M_DAC_DIN),
+      .sync_n(CLK_40M_DAC_nSYNC)
+  );
+  assign CLKIN_10MHz_REQ = ref_sel;
+
+
+  system_wrapper i_system_wrapper (
+    .MDIO_PHY_mdc(MDIO_PHY_mdc),
+    .MDIO_PHY_mdio_io(MDIO_PHY_mdio_io),
+    .RGMII_rd(RGMII_rd),
+    .RGMII_rx_ctl(RGMII_rx_ctl),
+    .RGMII_rxc(RGMII_rxc),
+    .RGMII_td(RGMII_td),
+    .RGMII_tx_ctl(RGMII_tx_ctl),
+    .RGMII_txc(RGMII_txc),
+    .eth_rst_n(),
+    .ddr_addr (ddr_addr),
+    .ddr_ba (ddr_ba),
+    .ddr_cas_n (ddr_cas_n),
+    .ddr_ck_n (ddr_ck_n),
+    .ddr_ck_p (ddr_ck_p),
+    .ddr_cke (ddr_cke),
+    .ddr_cs_n (ddr_cs_n),
+    .ddr_dm (ddr_dm),
+    .ddr_dq (ddr_dq),
+    .ddr_dqs_n (ddr_dqs_n),
+    .ddr_dqs_p (ddr_dqs_p),
+    .ddr_odt (ddr_odt),
+    .ddr_ras_n (ddr_ras_n),
+    .ddr_reset_n (ddr_reset_n),
+    .ddr_we_n (ddr_we_n),
+    .enable (enable),
+    .fixed_io_ddr_vrn (fixed_io_ddr_vrn),
+    .fixed_io_ddr_vrp (fixed_io_ddr_vrp),
+    .fixed_io_mio (fixed_io_mio),
+    .fixed_io_ps_clk (fixed_io_ps_clk),
+    .fixed_io_ps_porb (fixed_io_ps_porb),
+    .fixed_io_ps_srstb (fixed_io_ps_srstb),
+    .gpio_i (gpio_i),
+    .gpio_o (gpio_o),
+    .gpio_t (gpio_t),
+    .rx_clk_in (rx_clk_in),
+    .rx_data_in (rx_data_in),
+    .rx_frame_in (rx_frame_in),
+
+    .spi0_clk_i (1'b0),
+    .spi0_clk_o (spi_clk),
+    .spi0_csn_0_o (spi_csn),
+    .spi0_csn_1_o (),
+    .spi0_csn_2_o (),
+    .spi0_csn_i (1'b1),
+    .spi0_sdi_i (spi_miso),
+    .spi0_sdo_i (1'b0),
+    .spi0_sdo_o (spi_mosi),
+
+
+    .tx_clk_out (tx_clk_out),
+    .tx_data_out (tx_data_out),
+    .tx_frame_out (tx_frame_out),
+    .txnrx (txnrx),
+    .up_enable (gpio_o[15]),
+    .up_txnrx (gpio_o[16]));
+
+endmodule
+
+// ***************************************************************************
+// ***************************************************************************
+
-- 
2.17.1

