From ba260f68fe8c8afaac62d8b17d6daca78877766b Mon Sep 17 00:00:00 2001
From: Wei Chaochen <1530604142@qq.com>
Date: Thu, 8 Jun 2023 09:53:08 +0800
Subject: [PATCH] change antsdre200 ppsloop function

---
 projects/antsdre200/Makefile           |  21 ++
 projects/antsdre200/ltc2630_spi.v      | 151 ++++++++
 projects/antsdre200/ppsloop.v          | 480 +++++++++++++++++++++++++
 projects/antsdre200/system_bd.tcl      | 333 +++++++++++++++++
 projects/antsdre200/system_constr.xdc  | 121 +++++++
 projects/antsdre200/system_project.tcl |  19 +
 projects/antsdre200/system_top.v       | 234 ++++++++++++
 7 files changed, 1359 insertions(+)
 create mode 100644 projects/antsdre200/Makefile
 create mode 100644 projects/antsdre200/ltc2630_spi.v
 create mode 100644 projects/antsdre200/ppsloop.v
 create mode 100644 projects/antsdre200/system_bd.tcl
 create mode 100644 projects/antsdre200/system_constr.xdc
 create mode 100644 projects/antsdre200/system_project.tcl
 create mode 100644 projects/antsdre200/system_top.v

diff --git a/projects/antsdre200/Makefile b/projects/antsdre200/Makefile
new file mode 100644
index 000000000..cb65082c8
--- /dev/null
+++ b/projects/antsdre200/Makefile
@@ -0,0 +1,21 @@
+####################################################################################
+## Copyright 2018(c) Analog Devices, Inc.
+## Auto-generated, do not modify!
+####################################################################################
+
+PROJECT_NAME := antsdre200
+
+M_DEPS += ../common/xilinx/adi_fir_filter_constr.xdc
+M_DEPS += ../common/xilinx/adi_fir_filter_bd.tcl
+M_DEPS += ../../library/common/ad_iobuf.v
+M_DEPS += ../../library/util_cdc/sync_bits.v
+M_DEPS += ../../library/common/util_pulse_gen.v
+M_DEPS += ../../library/common/ad_bus_mux.v
+M_DEPS += ../../library/axi_ad9361/axi_ad9361_delay.tcl
+
+LIB_DEPS += axi_ad9361
+LIB_DEPS += axi_dmac
+LIB_DEPS += util_pack/util_cpack2
+LIB_DEPS += util_pack/util_upack2
+
+include ../scripts/project-xilinx.mk
diff --git a/projects/antsdre200/ltc2630_spi.v b/projects/antsdre200/ltc2630_spi.v
new file mode 100644
index 000000000..43ee8fcc2
--- /dev/null
+++ b/projects/antsdre200/ltc2630_spi.v
@@ -0,0 +1,151 @@
+module ltc2630_spi  (
+    input   wire            clk,
+    input   wire            rst,
+    input   wire  [15:0]    data,
+    output  reg             sclk,
+    output  wire            mosi,
+    output  reg             sync_n
+);
+
+    //====================================================
+    //parameter define
+    //====================================================
+    localparam  IDLE        = 4'b0001;
+    localparam  SYNC_PRE    = 4'b0010;
+    localparam  DATA        = 4'b0100;
+    localparam  SYNC_END    = 4'b1000;
+
+    //====================================================
+    // internal signals and registers
+    //====================================================
+    reg     [3:0]   state;
+    reg     [3:0]   cnt_cycle   ;
+    reg     [5:0]   cnt_bit     ;
+    reg     [15:0]  last_data   ;
+    reg     [23:0]  data_shift  ;
+    wire            rising_edge ;
+    wire            falling_edge;
+
+
+    //----------------state------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            state <= IDLE;
+        end
+        else  begin
+            case (state)
+                IDLE : begin
+                    // detect a new data input, the dac value needs to be updated
+                    if (last_data != data) begin
+                        state <= SYNC_PRE;
+                    end
+                end
+
+                SYNC_PRE : begin
+                    // The SYNC is low, start to update the value
+                    if (falling_edge) begin
+                        state <= DATA;
+                    end
+                end
+
+                DATA : begin
+                    if (cnt_bit == 'd23 && falling_edge) begin
+                        state <= SYNC_END;
+                    end
+                end
+
+                SYNC_END : begin
+                    if (rising_edge == 1'b1) begin
+                        state <= IDLE;
+                    end
+                end
+            endcase
+        end
+    end
+
+    //----------------cnt_cycle------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            cnt_cycle <= 'd0;
+        end
+        else if (state == SYNC_PRE || state == DATA || state == SYNC_END) begin
+            cnt_cycle <= cnt_cycle + 1'b1;
+        end
+        else  begin
+            cnt_cycle <=  'd0;
+        end
+    end
+
+    assign rising_edge = cnt_cycle==4'b1000;
+    assign falling_edge = cnt_cycle==4'b1111;
+
+    //----------------data_shift------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            data_shift <= 'd0;
+        end
+        else if (state == IDLE && (last_data != data)) begin
+            data_shift <= {4'b0011, 4'b0000, data};
+        end
+        else if (state == DATA && falling_edge) begin
+            data_shift <=  {data_shift[22:0], 1'b0};
+        end
+    end
+
+    //----------------cnt_bit------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            cnt_bit <= 'd0;
+        end
+        else if (state == DATA ) begin
+            if (cnt_bit == 'd23 && falling_edge) begin
+                cnt_bit <= 'd0;
+            end
+            else if(falling_edge)begin
+                cnt_bit <= cnt_bit + 1'b1;
+            end
+        end
+        else  begin
+            cnt_bit <=  'd0;
+        end
+    end
+
+    //----------------last_data------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            last_data <= 'd0;
+        end
+        else if (state == IDLE && (last_data != data)) begin
+            last_data <= data;
+        end
+    end
+
+    //-----------------sclk-----------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            sclk <= 1'b0;
+        end
+        else if (state==DATA && rising_edge == 1'b1) begin
+            sclk <= 1'b1;
+        end
+        else if (state==DATA && falling_edge == 1'b1) begin
+            sclk <=  1'b0;
+        end
+    end
+
+    assign mosi = data_shift[23];
+
+    //----------------sync_n------------------
+    always @(posedge clk ) begin
+        if (rst==1'b1) begin
+            sync_n <= 1'b1;
+        end
+        else if (state == SYNC_PRE && falling_edge == 1'b1) begin
+            sync_n <= 1'b0;
+        end
+        else if (state == SYNC_END && rising_edge == 1'b1) begin
+            sync_n <=  1'b1;
+        end
+    end
+    
+endmodule
\ No newline at end of file
diff --git a/projects/antsdre200/ppsloop.v b/projects/antsdre200/ppsloop.v
new file mode 100644
index 000000000..2892ec4c4
--- /dev/null
+++ b/projects/antsdre200/ppsloop.v
@@ -0,0 +1,480 @@
+//
+// Copyright 2015 Ettus Research
+//
+
+`timescale 1ns / 1ps
+
+
+module ppsloop#(
+  parameter DEVICE = "AD5640" //valid parameter LTC2640, AD5640, AD5660/2
+)(
+    input reset,
+    input xoclk, // 40 MHz from VCTCXO
+    input ppsgps,
+    input ppsext,
+    input [1:0] refsel,
+    output reg lpps,
+    output reg is10meg,
+    output reg ispps,
+    output reg reflck,
+    output plllck,// status of things
+    output clk_int40,
+    output sclk,
+    output mosi,
+    output sync_n,
+    input [15:0] dac_dflt
+   );
+  wire ppsref = (refsel==2'b00)?ppsgps:
+                (refsel==2'b11)?ppsext:
+                                ppsgps;
+  // reference pps to discilpline the VCTX|CXO to, from GPS or EXT in
+
+  wire clk_200M_o, clk;
+  BUFG x_clk_gen ( .I(clk_200M_o), .O(clk));
+  wire clk_40M;
+  wire pps_loop_rst;
+
+  assign clk_int40 = clk_40M;
+  assign pps_loop_rst = ~plllck;
+
+  wire n_pps = (refsel==2'b01) | (refsel==2'b10);
+  reg _npps, no_pps;
+  always @(posedge clk) { no_pps, _npps } <= { _npps, n_pps };
+
+  PLLE2_ADV #(.BANDWIDTH("OPTIMIZED"), .COMPENSATION("INTERNAL"),
+     .DIVCLK_DIVIDE(1),
+     .CLKFBOUT_MULT(30),
+     .CLKOUT0_DIVIDE(6),
+     .CLKOUT1_DIVIDE(30),
+     .CLKIN1_PERIOD(25.0)
+   )
+   clkgen (
+      .PWRDWN(1'b0), .RST(1'b0),
+      .CLKIN1(xoclk),
+      .CLKOUT0(clk_200M_o),
+      .CLKOUT1(clk_40M),
+      .LOCKED(plllck)
+   );
+
+    // state machine to manage reference detection and xo adjustment steps
+  reg [2:0] sstate, nxt_sstate;
+  localparam REFDET=3'b000;
+  localparam CFADJ=3'b001;
+  localparam SLEDGEA=3'b010;
+  localparam SLEDGEB=3'b011;
+  localparam FINEADJ=3'b100;
+
+  // state machine to manage lead-lag count
+  reg [1:0] llstate, nxt_llstate;
+  localparam READY=2'b00;
+  localparam COUNT=2'b01;
+  localparam DONE=2'b11;
+  localparam WAIT=2'b10;
+
+  /* Counter generating a local pps for the xo derived clock domains.
+     nxt_lcnt is manipulated by a state machine (sstate) to allow
+     quick re-alignment of the local pps rising edge with that of
+     the reference.
+  */
+  reg [27:0] lcnt, nxt_lcnt;
+  wire recycle = (28'd199_999_999==lcnt); // sets the period, 1 sec
+
+  always @(posedge clk) begin
+    if (pps_loop_rst) begin
+      sstate <= REFDET;
+      lcnt <= 'd0;
+      lpps <= 1'b0; 
+    end else begin
+      sstate <= nxt_sstate;
+      lcnt <= nxt_lcnt;
+      lpps <= lcnt > 28'd150_000_000; // ~25% duty cycle
+    end
+  end
+
+  /* Reference signal detection:
+   * Count the time interval between rising edges on the reference
+   * signal. The interval counter "rcnt" is restarted at rising edges
+   * of ppsref. "ppsref" could be either a pps signal, or a 10 MHz clock.
+   * Register "rlst" captures the value of rcnt at each rising edge.
+   * From this count value, we know the reference frequency.
+   */
+  reg [27:0] rcnt, rlst;
+  reg signed [28:0] rdiff;
+  wire signed [28:0] srlst = { 1'b0, rlst }; // sign extended version of rlst
+  wire [27:0] nxt_rcnt;
+  reg rcnt_ovfl;
+  reg [3:0] ple; // pipeline from reference rising edge det.
+  wire valid_ref = is10meg | ispps;
+
+
+  /* If the reference is at 10 MHz, derive a reference pps using a counter
+   * to feed the frequency control logic. To detect a 0.5 ppm deviation
+   * on a 10 MHz signal using counters requires the better part of a second
+   * anyway, so samples at a 1 Hz rate are appropriate. This allows much of
+   * the same logic to be used for pps or 10 Mhz references.
+  */
+  reg [23:0] tcnt;
+  reg tpps;
+  wire [23:0] nxt_tcnt = (~is10meg | tcnt==24'd9999999) ? 24'b0 : tcnt+1'b1;
+  always @(posedge ppsref) begin
+    if (pps_loop_rst) begin
+      tcnt <= 'd0;
+      tpps <= 1'b0;
+    end  else  begin
+      /* note this is clocked by the reference signal and is not useful when
+      * the reference is a pps.
+      */
+      tcnt <= nxt_tcnt;
+      tpps <= (tcnt>24'd7499999);
+    end
+  end
+
+  /* The reference needs to be synchronized into the local clock domain,
+   * and while the local 'pps' is generated synchronously within this
+   * domain, it gets passed through identical stages to maintain
+   * the time relationship between detected rising edges.
+   */
+  reg [2:0] refsmp;
+  reg [2:0] tsmp;
+  reg [2:0] xosmp;
+  always @(posedge clk) begin
+    if (pps_loop_rst) begin
+      refsmp <= { refsmp[1:0], ppsref};
+      tsmp <= { tsmp[1:0], tpps};
+      xosmp <= { xosmp[1:0], lpps };
+    end  else begin
+      // apply same sync delay to all pps flavors
+      refsmp <= { refsmp[1:0], ppsref};
+      tsmp <= { tsmp[1:0], tpps};
+      xosmp <= { xosmp[1:0], lpps };
+    end
+  end
+
+
+  wire rising_r = (refsmp[2:1]==2'b01);
+  wire rising_t = (tsmp[2:1]==2'b01);
+  wire rising_ref = is10meg ? rising_t : rising_r;
+  wire rising_xo  = (xosmp[2:1]==2'b01);
+  wire lead = rising_xo & ~rising_ref;
+  wire lag = ~rising_xo & rising_ref;
+  wire trig = rising_xo ^ rising_ref;
+  wire dtrig = rising_xo & rising_ref;
+  wire untrig = rising_xo | rising_ref;
+  wire llrdy = (is10meg ? ~tsmp[2] : ~refsmp[2]) & ~xosmp[2];
+  wire rhigh = is10meg ? tsmp[1] : refsmp[1];
+
+
+  reg [5:0] pcnt;
+  reg pcnt_ovfl;
+  wire [5:0]  nxt_pcnt = (rising_r | pcnt_ovfl) ? 6'b0 : pcnt+1'b1;
+  always @(posedge clk) begin
+    if (pps_loop_rst) begin
+      pcnt <= 'd0;
+      pcnt_ovfl <= 1'b0;
+      is10meg <= 1'b0;
+    end else begin
+      pcnt <= nxt_pcnt;
+      if (rcnt_ovfl)
+        is10meg <= 1'b0;
+      else if (pcnt == 6'b111111) begin
+        pcnt_ovfl <= 1'b1;
+        is10meg <= 1'b0;
+      end
+      else if (rising_r) begin
+        is10meg <=  (pcnt > 6'd16) & (pcnt < 6'd24);
+        pcnt_ovfl <= 1'b0;
+      end
+    end
+
+  end
+
+  reg rr;
+  assign nxt_rcnt = rr ? 28'b0 : rcnt+1'b1;
+  always @(posedge clk) begin
+    if (pps_loop_rst) begin
+      rr <= 1'b0;
+      ple <= 'd0;
+      rcnt <= 'd0;
+      ispps <= 1'b0;
+      rcnt_ovfl <= 'd0;
+    end else begin
+      rr <= rising_ref;
+      ple[3:0] <= {ple[2:0],rising_ref & valid_ref};
+
+      rcnt <= nxt_rcnt;
+
+      // set the overflow flag if no reference edge is detected and
+      // hold it asserted until an edge does arrive. This allows clearing of
+      // the other flags, even if there is no reference.
+      if (rcnt==28'b1111111111111111111111111111)
+        rcnt_ovfl <= 1'b1;
+      else if (rr)
+        rcnt_ovfl <= 1'b0;
+
+      if (rr) begin
+        // a rising edge arrived, grab the count and compare to bounds
+        rlst <= rcnt;
+      end
+      if (rr | rcnt_ovfl) begin
+        ispps <= ~is10meg & ~rcnt_ovfl & (rcnt > 28'd199997000) & (rcnt < 200003000);
+        /* reference frequency detect limits:
+        * 10M sampled with 200M should be 20 cycles, 16-24 provides xtra margin
+        * to allow for tolerances and possibly sampling at jittery edges
+        * allow +- 15 ppm on a pps signal
+        */
+
+      end
+    end
+  end
+
+
+  reg signed [27:0] coarse;
+  reg [15:0] dacv = 16'd32767; // power-on default mid-scale
+  wire signed [16:0] sdacv = { 1'b0, dacv};
+  /* to exit coarse adjustment, the frequency error shall be small for
+   * several cycles
+   */
+  reg esmall;
+  reg [2:0] es;
+
+  reg pr;
+
+
+  /* The xo can be on-frequency while the rising edges are still
+   * out-of-phase, so a phase detector is also required. The
+   * counter "llcnt" accumulates how many ticks local pps leads
+   * or lags the reference pps . The range of this counter
+   * need not be as large as "rcnt". The count increments
+   * or decrements based upon which signal has a rising edge first,
+   * and the count is halted when the other rising edge occurs.
+   * Both signals are required to transition back to the low state
+   * to re-arm the detection state machine.
+  */
+  reg llcntena;
+  reg lead_lagn;
+  reg signed [11:0] llcnt, nxt_llcnt;
+  wire signed [11:0] incr = lead_lagn ? -12'sd1 : 12'sd1; // -1 lead, +1 lag
+  reg [3:0] llsmall;
+  reg llovfl;
+
+  reg [2:0] refs1, refs0;
+  reg refchanged;
+  reg refinternal;
+  always @(posedge clk) begin
+    refs1 <= { refs1[1:0], refsel[1] };
+    refs0 <= { refs0[1:0], refsel[0] };
+    refchanged <= { refs1[2], refs0[2] } != { refs1[1], refs0[1] };
+    refinternal <=  refs1[2] ^ refs0[2]; // not gps or external
+
+    // compute how far off the expected period we are
+    if (ple[1]) begin
+      rdiff <= srlst-29'd199999999;
+    end
+
+    // compute an adjustment for the dac
+    if (ple[2]) begin
+      // if rdiff is (+), the xo is fast
+      // include a bit of gain for quick adjustment
+      // an approximate gain was initially determined by 'theory' using
+      // the xo tuning sensitivity, and was find-tuned 'by hand'
+      // by observing the loop behaviour (with rdiff instrumented and
+      // pps signals connected out to an oscilloscope).
+      coarse <= sdacv - (rdiff <<< 3);
+    end
+
+    // determine when the period error is small
+    if (ple[2] | rcnt_ovfl) begin
+      es <= { es[1:0], (rdiff<29'sd8 && rdiff>-29'sd8) };
+      esmall <= valid_ref & ~rcnt_ovfl & (es[2:0] == 3'b111);
+    end
+    else if (sstate==REFDET) begin
+      es <= 3'b0;
+      esmall <= 1'b0;
+    end
+
+    // assign the dac value when doing coarse-adjustment
+    // in the fine-adjust phaase, the PI control filtering takes over
+    if (ple[3] & (sstate==CFADJ)) begin
+      dacv <= coarse[15:0];
+    end
+    else if (sstate==REFDET) begin
+      dacv <= 16'd32767; // center the DAC
+    end
+  end
+
+
+  always @(*) begin
+    nxt_sstate=sstate;
+    pr = 1'b0;
+    nxt_lcnt = recycle ? 26'd0 : lcnt + 1'b1;
+    case (sstate)
+    REFDET: begin // determine reference type
+      pr = 1'b0;
+      if (valid_ref) nxt_sstate = CFADJ;
+    end
+    CFADJ: begin // coarse freqency adjustment
+      pr = 1'b1;
+      if (esmall) nxt_sstate = SLEDGEA;
+    end
+    SLEDGEA: begin // ensure local pps is low and wait for a ref edge
+      pr = 1'b1; // preload the integrator
+      if (rhigh) nxt_sstate = SLEDGEB;
+    end
+    SLEDGEB: begin // force local pps rising edge to match reference
+      nxt_lcnt = 26'd0;
+      pr = 1'b1; // preload the integrator
+      if(rhigh) begin
+        nxt_lcnt = 28'd149_999_998; // force rising edge in a couple cycles
+        nxt_sstate = FINEADJ;
+      end
+    end
+    FINEADJ: begin // wide-ish bandwidth PI control
+      if (~valid_ref | llovfl) nxt_sstate = REFDET;
+    end
+    default: begin
+      nxt_sstate = REFDET;
+    end
+    endcase
+    // overriding conditions:
+    if (refinternal | refchanged | rcnt_ovfl ) nxt_sstate = REFDET;
+  end
+
+  reg llsena;
+  always @(posedge clk) begin
+    llstate <= nxt_llstate;
+    if (llcntena) llcnt <= nxt_llcnt;
+    if (llstate==READY) lead_lagn <= lead;
+    if (llsena) llsmall <= { (llsmall[2:0] == 3'b111), llsmall[1:0],
+                                        (llcnt < 12'sd3)&(llcnt > -12'sd3)};
+    if (llcntena)  llovfl <= (llcnt>12'sd1800) | (llcnt< -12'sd1800);
+  end
+
+  reg ppsfltena;
+  always @(*) begin
+    // values to hold by default:
+    nxt_llstate = llstate;
+    llcntena=1'b0;
+    nxt_llcnt=llcnt;
+    ppsfltena = 1'b0;
+    llsena = 1'b0;
+
+    case (llstate)
+    READY: begin
+      nxt_llcnt=12'b0;
+      if (trig | dtrig) begin
+        nxt_llstate = trig ? COUNT : DONE;
+        llcntena=1'b1;
+        // even if dtrig, set llcnt to 0 to feed the filter pipe
+      end
+    end
+    COUNT: begin
+      if (untrig) begin // the second edge arrived
+        nxt_llstate = DONE;
+      end
+      else begin
+        llcntena=1'b1;
+        nxt_llcnt=llcnt+incr;
+      end
+    end
+    DONE: begin
+      nxt_llstate = WAIT;
+      ppsfltena = 1'b1;
+    end
+    WAIT: begin
+      if (llrdy) begin
+        nxt_llstate = READY;
+        llsena = 1'b1;
+      end
+    end
+    endcase
+    if (sstate==REFDET) begin
+      nxt_llstate = READY;
+      llcntena=1'b0;
+      ppsfltena = 1'b0;
+      llsena = 1'b0;
+    end
+  end
+
+
+  reg[15:0] daco;
+
+  reg [1:0] enchain=2'b00;
+  always @(posedge clk) enchain <= { enchain[1:0], ppsfltena & (enchain==2'b00) };
+
+  reg signed [23:0] integ;
+  reg signed [23:0] prop;
+  wire signed [23:0] nxt_integ = integ + (llcnt <<< 6);
+  wire signed [23:0] nxt_prop = (llcnt <<< 7);
+  wire signed [23:0] eff = integ + prop;
+  wire urng = eff[23], orng = eff[23:22]==2'b01;
+  reg erng;
+  /* The values for proportional and integral gain terms were originally
+   * estimated using a model that accounted for the xo tuning sensitivity.
+   * When implemented, the loop dynamics observed differed significantly
+   * from model results, probably as a result of the Xilinx PLL
+   * (which was not modelled) being present in the loop. The gain values
+   * were find-tuned 'by hand' by observing the loop behaviour (with llcnt
+   * instrumented) and pps signals connected out to an oscilloscope).
+   */
+
+  always @(posedge clk) begin
+    if (pps_loop_rst ) begin
+      daco <= dac_dflt;
+    end
+    if (no_pps) begin
+     daco <= dac_dflt;
+    end
+    else if (pr) begin
+      integ <= { 2'b00, dacv, 6'b0 }; // precharge the accumulator
+      daco <= dacv;
+    end
+    else begin
+      if (enchain[0]) begin
+        integ <= nxt_integ;
+        prop <= nxt_prop;
+      end
+      if (enchain[1]) begin
+        daco <= eff[21:6];
+        erng <= urng | orng;
+      end
+    end
+  end
+
+  wire  fadj=   (sstate==FINEADJ);
+  always @(posedge clk) begin
+    reflck <= refinternal | fadj;
+  end
+
+  generate
+      if (DEVICE=="AD5660") begin
+        ad5662_auto_spi dac
+        (
+          .clk(clk),
+          .dat(daco),
+          .sclk(sclk),
+          .mosi(mosi),
+          .sync_n(sync_n)
+        );
+      end  else if (DEVICE=="AD5640") begin
+        ad5640_spi u_ad5640_spi(
+            .clk  ( clk  ),
+            .rst  ( pps_loop_rst  ),
+            .data ( daco[15:2] ),
+            .sclk ( sclk ),
+            .mosi ( mosi ),
+            .sync_n  ( sync_n  )
+        ); 
+      end else begin
+        ltc2630_spi u_ltc2630_spi(
+            .clk  ( clk  ),
+            .rst  ( pps_loop_rst),
+            .data ( daco ),
+            .sclk ( sclk ),
+            .mosi ( mosi ),
+            .sync_n  ( sync_n  )
+        );
+      end
+  endgenerate
+
+
+endmodule
diff --git a/projects/antsdre200/system_bd.tcl b/projects/antsdre200/system_bd.tcl
new file mode 100644
index 000000000..d1fc4ff95
--- /dev/null
+++ b/projects/antsdre200/system_bd.tcl
@@ -0,0 +1,333 @@
+# create board design
+
+
+source $ad_hdl_dir/projects/common/xilinx/adi_fir_filter_bd.tcl
+
+# default ports
+
+create_bd_intf_port -mode Master -vlnv xilinx.com:interface:ddrx_rtl:1.0 ddr
+create_bd_intf_port -mode Master -vlnv xilinx.com:display_processing_system7:fixedio_rtl:1.0 fixed_io
+
+create_bd_intf_port -mode Master -vlnv xilinx.com:interface:mdio_rtl:1.0 MDIO_PHY
+create_bd_intf_port -mode Master -vlnv xilinx.com:interface:rgmii_rtl:1.0 RGMII
+
+create_bd_port -dir O eth_rst_n
+
+create_bd_port -dir O spi0_csn_2_o
+create_bd_port -dir O spi0_csn_1_o
+create_bd_port -dir O spi0_csn_0_o
+create_bd_port -dir I spi0_csn_i
+create_bd_port -dir I spi0_clk_i
+create_bd_port -dir O spi0_clk_o
+create_bd_port -dir I spi0_sdo_i
+create_bd_port -dir O spi0_sdo_o
+create_bd_port -dir I spi0_sdi_i
+
+create_bd_port -dir I -from 63 -to 0 gpio_i
+create_bd_port -dir O -from 63 -to 0 gpio_o
+create_bd_port -dir O -from 63 -to 0 gpio_t
+
+
+# instance: sys_ps7
+
+ad_ip_instance processing_system7 sys_ps7
+
+# ps7 settings
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_PRESET_BANK0_VOLTAGE {LVCMOS 3.3V}
+ad_ip_parameter sys_ps7 CONFIG.PCW_PRESET_BANK1_VOLTAGE {LVCMOS 3.3V}
+ad_ip_parameter sys_ps7 CONFIG.PCW_PACKAGE_NAME clg400
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_MIO_GPIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_ENET0_IO "EMIO"
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_GRP_MDIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_ENET0_GRP_MDIO_IO "EMIO"
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP1 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP2 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_EN_CLK1_PORT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_EN_RST1_PORT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_FPGA0_PERIPHERAL_FREQMHZ 100.0
+ad_ip_parameter sys_ps7 CONFIG.PCW_FPGA1_PERIPHERAL_FREQMHZ 200.0
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_EMIO_GPIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_EMIO_GPIO_IO 64
+ad_ip_parameter sys_ps7 CONFIG.PCW_SPI1_PERIPHERAL_ENABLE 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_I2C0_PERIPHERAL_ENABLE 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_SD0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_SDIO_PERIPHERAL_FREQMHZ 50
+ad_ip_parameter sys_ps7 CONFIG.PCW_UART0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UART0_UART0_IO {MIO 14 .. 15}
+ad_ip_parameter sys_ps7 CONFIG.PCW_I2C1_PERIPHERAL_ENABLE 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_QSPI_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_QSPI_GRP_SINGLE_SS_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_SPI0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_SPI0_SPI0_IO EMIO
+ad_ip_parameter sys_ps7 CONFIG.PCW_TTC0_PERIPHERAL_ENABLE 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_FABRIC_INTERRUPT 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_USB0_PERIPHERAL_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_MIO_GPIO_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_GPIO_MIO_GPIO_IO MIO
+ad_ip_parameter sys_ps7 CONFIG.PCW_USB0_RESET_IO {MIO 47}
+ad_ip_parameter sys_ps7 CONFIG.PCW_USB0_RESET_ENABLE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_IRQ_F2P_INTR 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_IRQ_F2P_MODE REVERSE
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_0_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_9_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_10_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_11_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_48_PULLUP {enabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_49_PULLUP {disabled}
+ad_ip_parameter sys_ps7 CONFIG.PCW_MIO_53_PULLUP {enabled}
+
+# DDR MT41K256M16 HA-125 (32M, 16bit, 8banks)
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_PARTNO {MT41J256M16 RE-125}
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_BUS_WIDTH {16 Bit}
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_USE_INTERNAL_VREF 0
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_TRAIN_WRITE_LEVEL 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_TRAIN_READ_GATE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_TRAIN_DATA_EYE 1
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_DQS_TO_CLK_DELAY_0 0.048
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_DQS_TO_CLK_DELAY_1 0.050
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_BOARD_DELAY0 0.241
+ad_ip_parameter sys_ps7 CONFIG.PCW_UIPARAM_DDR_BOARD_DELAY1 0.240
+
+ad_ip_instance xlconcat sys_concat_intc
+ad_ip_parameter sys_concat_intc CONFIG.NUM_PORTS 16
+
+ad_ip_instance proc_sys_reset sys_rstgen
+ad_ip_parameter sys_rstgen CONFIG.C_EXT_RST_WIDTH 1
+
+# system reset/clock definitions
+
+# add external ethernet phy
+ad_ip_instance gmii_to_rgmii sys_rgmii
+ad_ip_parameter sys_rgmii CONFIG.SupportLevel Include_Shared_Logic_in_Core
+
+
+ad_connect  sys_cpu_clk sys_ps7/FCLK_CLK0
+ad_connect  sys_200m_clk sys_ps7/FCLK_CLK1
+ad_connect  sys_cpu_reset sys_rstgen/peripheral_reset
+ad_connect  sys_cpu_resetn sys_rstgen/peripheral_aresetn
+ad_connect  eth_rst_n sys_rstgen/peripheral_aresetn
+ad_connect  sys_cpu_clk sys_rstgen/slowest_sync_clk
+ad_connect  sys_rstgen/ext_reset_in sys_ps7/FCLK_RESET0_N
+ad_connect  sys_rgmii/tx_reset sys_rstgen/peripheral_reset
+ad_connect  sys_rgmii/rx_reset sys_rstgen/peripheral_reset
+ad_connect  sys_rgmii/clkin sys_ps7/FCLK_CLK1 
+ad_connect  sys_ps7/MDIO_ETHERNET_0 sys_rgmii/MDIO_GEM
+ad_connect  sys_ps7/GMII_ETHERNET_0 sys_rgmii/GMII
+ad_connect  sys_rgmii/MDIO_PHY MDIO_PHY
+ad_connect  sys_rgmii/RGMII RGMII
+
+# interface connections
+
+ad_connect  ddr sys_ps7/DDR
+ad_connect  gpio_i sys_ps7/GPIO_I
+ad_connect  gpio_o sys_ps7/GPIO_O
+ad_connect  gpio_t sys_ps7/GPIO_T
+ad_connect  fixed_io sys_ps7/FIXED_IO
+
+# ps7 spi connections
+
+ad_connect  spi0_csn_2_o sys_ps7/SPI0_SS2_O
+ad_connect  spi0_csn_1_o sys_ps7/SPI0_SS1_O
+ad_connect  spi0_csn_0_o sys_ps7/SPI0_SS_O
+ad_connect  spi0_csn_i sys_ps7/SPI0_SS_I
+ad_connect  spi0_clk_i sys_ps7/SPI0_SCLK_I
+ad_connect  spi0_clk_o sys_ps7/SPI0_SCLK_O
+ad_connect  spi0_sdo_i sys_ps7/SPI0_MOSI_I
+ad_connect  spi0_sdo_o sys_ps7/SPI0_MOSI_O
+ad_connect  spi0_sdi_i sys_ps7/SPI0_MISO_I
+
+
+# interrupts
+
+ad_connect  sys_concat_intc/dout sys_ps7/IRQ_F2P
+ad_connect  sys_concat_intc/In15 GND
+ad_connect  sys_concat_intc/In14 GND
+ad_connect  sys_concat_intc/In13 GND
+ad_connect  sys_concat_intc/In12 GND
+ad_connect  sys_concat_intc/In11 GND
+ad_connect  sys_concat_intc/In10 GND
+ad_connect  sys_concat_intc/In9 GND
+ad_connect  sys_concat_intc/In8 GND
+ad_connect  sys_concat_intc/In7 GND
+ad_connect  sys_concat_intc/In6 GND
+ad_connect  sys_concat_intc/In5 GND
+ad_connect  sys_concat_intc/In4 GND
+ad_connect  sys_concat_intc/In3 GND
+ad_connect  sys_concat_intc/In2 GND
+ad_connect  sys_concat_intc/In1 GND
+ad_connect  sys_concat_intc/In0 GND
+
+
+# ad9361
+
+create_bd_port -dir I rx_clk_in
+create_bd_port -dir I rx_frame_in
+create_bd_port -dir I -from 11 -to 0 rx_data_in
+
+create_bd_port -dir O tx_clk_out
+create_bd_port -dir O tx_frame_out
+create_bd_port -dir O -from 11 -to 0 tx_data_out
+
+create_bd_port -dir O enable
+create_bd_port -dir O txnrx
+create_bd_port -dir I up_enable
+create_bd_port -dir I up_txnrx
+
+# ad9361 core(s)
+
+ad_ip_instance axi_ad9361 axi_ad9361
+ad_ip_parameter axi_ad9361 CONFIG.ID 0
+ad_ip_parameter axi_ad9361 CONFIG.CMOS_OR_LVDS_N 1
+ad_ip_parameter axi_ad9361 CONFIG.MODE_1R1T 0
+ad_ip_parameter axi_ad9361 CONFIG.ADC_INIT_DELAY 21
+
+ad_ip_instance axi_dmac axi_ad9361_dac_dma
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_TYPE_SRC 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_TYPE_DEST 1
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.CYCLIC 1
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.AXI_SLICE_SRC 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.AXI_SLICE_DEST 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_2D_TRANSFER 0
+ad_ip_parameter axi_ad9361_dac_dma CONFIG.DMA_DATA_WIDTH_DEST 64
+
+ad_add_interpolation_filter "tx_fir_interpolator" 8 2 1 {61.44} {7.68} \
+                             "$ad_hdl_dir/library/util_fir_int/coefile_int.coe"
+ad_ip_instance xlslice interp_slice
+ad_ip_instance util_upack2 tx_upack
+
+ad_ip_instance axi_dmac axi_ad9361_adc_dma
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_TYPE_SRC 2
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_TYPE_DEST 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.CYCLIC 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.SYNC_TRANSFER_START 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.AXI_SLICE_SRC 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.AXI_SLICE_DEST 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_2D_TRANSFER 0
+ad_ip_parameter axi_ad9361_adc_dma CONFIG.DMA_DATA_WIDTH_SRC 64
+
+ad_add_decimation_filter "rx_fir_decimator" 8 2 1 {61.44} {61.44} \
+                         "$ad_hdl_dir/library/util_fir_int/coefile_int.coe"
+ad_ip_instance xlslice decim_slice
+ad_ip_instance util_cpack2 cpack
+
+# connections
+
+ad_connect  rx_clk_in axi_ad9361/rx_clk_in
+ad_connect  rx_frame_in axi_ad9361/rx_frame_in
+ad_connect  rx_data_in axi_ad9361/rx_data_in
+ad_connect  tx_clk_out axi_ad9361/tx_clk_out
+ad_connect  tx_frame_out axi_ad9361/tx_frame_out
+ad_connect  tx_data_out axi_ad9361/tx_data_out
+ad_connect  enable axi_ad9361/enable
+ad_connect  txnrx axi_ad9361/txnrx
+ad_connect  up_enable axi_ad9361/up_enable
+ad_connect  up_txnrx axi_ad9361/up_txnrx
+
+ad_connect  axi_ad9361/tdd_sync GND
+ad_connect  sys_200m_clk axi_ad9361/delay_clk
+ad_connect  axi_ad9361/l_clk axi_ad9361/clk
+
+ad_connect axi_ad9361/l_clk rx_fir_decimator/aclk
+
+ad_connect axi_ad9361/adc_valid_i0 rx_fir_decimator/valid_in_0
+ad_connect axi_ad9361/adc_enable_i0 rx_fir_decimator/enable_in_0
+ad_connect axi_ad9361/adc_data_i0 rx_fir_decimator/data_in_0
+ad_connect axi_ad9361/adc_valid_q0 rx_fir_decimator/valid_in_1
+ad_connect axi_ad9361/adc_enable_q0 rx_fir_decimator/enable_in_1
+ad_connect axi_ad9361/adc_data_q0 rx_fir_decimator/data_in_1
+
+ad_connect axi_ad9361/l_clk cpack/clk
+ad_connect axi_ad9361/rst cpack/reset
+
+ad_connect axi_ad9361/adc_enable_i1 cpack/enable_2
+ad_connect axi_ad9361/adc_data_i1 cpack/fifo_wr_data_2
+ad_connect axi_ad9361/adc_enable_q1 cpack/enable_3
+ad_connect axi_ad9361/adc_data_q1 cpack/fifo_wr_data_3
+
+ad_connect cpack/enable_0 rx_fir_decimator/enable_out_0
+ad_connect cpack/enable_1 rx_fir_decimator/enable_out_1
+ad_connect cpack/fifo_wr_data_0 rx_fir_decimator/data_out_0
+ad_connect cpack/fifo_wr_data_1 rx_fir_decimator/data_out_1
+ad_connect rx_fir_decimator/valid_out_0 cpack/fifo_wr_en
+
+ad_connect axi_ad9361_adc_dma/fifo_wr cpack/packed_fifo_wr
+ad_connect axi_ad9361/up_adc_gpio_out decim_slice/Din
+ad_connect rx_fir_decimator/active decim_slice/Dout
+
+ad_connect axi_ad9361/l_clk tx_fir_interpolator/aclk
+
+ad_connect axi_ad9361/dac_enable_i0 tx_fir_interpolator/dac_enable_0
+ad_connect axi_ad9361/dac_valid_i0 tx_fir_interpolator/dac_valid_0
+ad_connect axi_ad9361/dac_data_i0 tx_fir_interpolator/data_out_0
+ad_connect axi_ad9361/dac_enable_q0 tx_fir_interpolator/dac_enable_1
+ad_connect axi_ad9361/dac_valid_q0 tx_fir_interpolator/dac_valid_1
+ad_connect axi_ad9361/dac_data_q0 tx_fir_interpolator/data_out_1
+
+ad_connect  axi_ad9361/l_clk tx_upack/clk
+ad_connect  axi_ad9361/rst tx_upack/reset
+
+ad_connect  tx_upack/fifo_rd_data_0  tx_fir_interpolator/data_in_0
+ad_connect  tx_upack/enable_0  tx_fir_interpolator/enable_out_0
+ad_connect  tx_upack/fifo_rd_data_1  tx_fir_interpolator/data_in_1
+ad_connect  tx_upack/enable_1  tx_fir_interpolator/enable_out_1
+
+ad_connect axi_ad9361/dac_enable_i1 tx_upack/enable_2
+ad_connect axi_ad9361/dac_data_i1 tx_upack/fifo_rd_data_2
+ad_connect axi_ad9361/dac_enable_q1 tx_upack/enable_3
+ad_connect axi_ad9361/dac_data_q1 tx_upack/fifo_rd_data_3
+
+ad_connect tx_upack/s_axis  axi_ad9361_dac_dma/m_axis
+
+ad_ip_instance util_vector_logic logic_or [list \
+  C_OPERATION {or} \
+  C_SIZE 1]
+
+ad_connect  logic_or/Op1  tx_fir_interpolator/valid_out_0
+ad_connect  logic_or/Op2  axi_ad9361/dac_valid_i1
+ad_connect  logic_or/Res  tx_upack/fifo_rd_en
+
+ad_connect axi_ad9361/up_dac_gpio_out interp_slice/Din
+ad_connect  tx_fir_interpolator/active interp_slice/Dout
+
+ad_connect  axi_ad9361/l_clk axi_ad9361_adc_dma/fifo_wr_clk
+ad_connect  axi_ad9361/l_clk axi_ad9361_dac_dma/m_axis_aclk
+ad_connect  cpack/fifo_wr_overflow axi_ad9361/adc_dovf
+
+# interconnects
+
+ad_cpu_interconnect 0x79020000 axi_ad9361
+ad_cpu_interconnect 0x7C400000 axi_ad9361_adc_dma
+ad_cpu_interconnect 0x7C420000 axi_ad9361_dac_dma
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP1 {1}
+ad_connect sys_cpu_clk sys_ps7/S_AXI_HP1_ACLK
+ad_connect axi_ad9361_adc_dma/m_dest_axi sys_ps7/S_AXI_HP1
+
+create_bd_addr_seg -range 0x20000000 -offset 0x00000000 \
+                    [get_bd_addr_spaces axi_ad9361_adc_dma/m_dest_axi] \
+                    [get_bd_addr_segs sys_ps7/S_AXI_HP1/HP1_DDR_LOWOCM] \
+                    SEG_sys_ps7_HP1_DDR_LOWOCM
+
+ad_ip_parameter sys_ps7 CONFIG.PCW_USE_S_AXI_HP2 {1}
+ad_connect sys_cpu_clk sys_ps7/S_AXI_HP2_ACLK
+ad_connect axi_ad9361_dac_dma/m_src_axi sys_ps7/S_AXI_HP2
+
+create_bd_addr_seg -range 0x20000000 -offset 0x00000000 \
+                    [get_bd_addr_spaces axi_ad9361_dac_dma/m_src_axi] \
+                    [get_bd_addr_segs sys_ps7/S_AXI_HP2/HP2_DDR_LOWOCM] \
+                    SEG_sys_ps7_HP2_DDR_LOWOCM
+
+ad_connect sys_cpu_clk axi_ad9361_dac_dma/m_src_axi_aclk
+ad_connect sys_cpu_clk axi_ad9361_adc_dma/m_dest_axi_aclk
+ad_connect sys_cpu_resetn axi_ad9361_adc_dma/m_dest_axi_aresetn
+ad_connect sys_cpu_resetn axi_ad9361_dac_dma/m_src_axi_aresetn
+
+# interrupts
+
+ad_cpu_interrupt ps-13 mb-13 axi_ad9361_adc_dma/irq
+ad_cpu_interrupt ps-12 mb-12 axi_ad9361_dac_dma/irq
+
+
diff --git a/projects/antsdre200/system_constr.xdc b/projects/antsdre200/system_constr.xdc
new file mode 100644
index 000000000..72933bc75
--- /dev/null
+++ b/projects/antsdre200/system_constr.xdc
@@ -0,0 +1,121 @@
+set_property -dict {PACKAGE_PIN V6  IOSTANDARD LVCMOS33} [get_ports CLK_40M_DAC_nSYNC]   ;
+set_property -dict {PACKAGE_PIN W6  IOSTANDARD LVCMOS33} [get_ports CLK_40M_DAC_SCLK]    ;
+set_property -dict {PACKAGE_PIN V10 IOSTANDARD LVCMOS33} [get_ports CLK_40M_DAC_DIN]    ;
+set_property -dict {PACKAGE_PIN V11 IOSTANDARD LVCMOS33} [get_ports PPS_IN]             ;
+set_property -dict {PACKAGE_PIN K17 IOSTANDARD LVCMOS18} [get_ports CLK_40MHz_FPGA]     ;
+set_property -dict {PACKAGE_PIN J18 IOSTANDARD LVCMOS18} [get_ports CLKIN_10MHz]        ;
+set_property -dict {PACKAGE_PIN M20 IOSTANDARD LVCMOS18} [get_ports CLKIN_10MHz_REQ]    ;
+
+
+set_property  -dict {PACKAGE_PIN  C20   IOSTANDARD  LVCMOS18} [get_ports  RGMII_td[3]]  ;
+set_property  -dict {PACKAGE_PIN  D19   IOSTANDARD  LVCMOS18} [get_ports  RGMII_td[2]]  ;
+set_property  -dict {PACKAGE_PIN  D20   IOSTANDARD  LVCMOS18} [get_ports  RGMII_td[1]]  ;
+set_property  -dict {PACKAGE_PIN  F19   IOSTANDARD  LVCMOS18} [get_ports  RGMII_td[0]]  ;
+set_property  -dict {PACKAGE_PIN  E18   IOSTANDARD  LVCMOS18} [get_ports  RGMII_rd[3]]  ;
+set_property  -dict {PACKAGE_PIN  E19   IOSTANDARD  LVCMOS18} [get_ports  RGMII_rd[2]]  ;
+set_property  -dict {PACKAGE_PIN  E17   IOSTANDARD  LVCMOS18} [get_ports  RGMII_rd[1]]  ;
+set_property  -dict {PACKAGE_PIN  F16   IOSTANDARD  LVCMOS18} [get_ports  RGMII_rd[0]]  ;
+
+set_property  -dict {PACKAGE_PIN  F20   IOSTANDARD  LVCMOS18} [get_ports  RGMII_tx_ctl] ;
+set_property  -dict {PACKAGE_PIN  D18   IOSTANDARD  LVCMOS18} [get_ports  RGMII_txc]    ;
+set_property  -dict {PACKAGE_PIN  G17   IOSTANDARD  LVCMOS18} [get_ports  RGMII_rx_ctl] ;
+set_property  -dict {PACKAGE_PIN  H16   IOSTANDARD  LVCMOS18} [get_ports  RGMII_rxc]    ;
+set_property  -dict {PACKAGE_PIN  B19   IOSTANDARD  LVCMOS18} [get_ports  eth_rst_n]    ;
+set_property  -dict {PACKAGE_PIN  A20   IOSTANDARD  LVCMOS18} [get_ports  MDIO_PHY_mdio_io]   ;
+set_property  -dict {PACKAGE_PIN  B20   IOSTANDARD  LVCMOS18} [get_ports  MDIO_PHY_mdc]       ;
+
+set_property  -dict {PACKAGE_PIN  G15   IOSTANDARD  LVCMOS18} [get_ports  tx_amp_en]  ;
+
+create_clock -period  8.000          [get_ports RGMII_rxc] 
+
+set_property  -dict {PACKAGE_PIN    T15   IOSTANDARD LVCMOS18} [get_ports gpio_status[7]]                    ; 
+set_property  -dict {PACKAGE_PIN    K16   IOSTANDARD LVCMOS18} [get_ports gpio_status[6]]                    ; 
+set_property  -dict {PACKAGE_PIN    P14   IOSTANDARD LVCMOS18} [get_ports gpio_status[5]]                    ; 
+set_property  -dict {PACKAGE_PIN    P15   IOSTANDARD LVCMOS18} [get_ports gpio_status[4]]                    ; 
+set_property  -dict {PACKAGE_PIN    R14   IOSTANDARD LVCMOS18} [get_ports gpio_status[3]]                    ; 
+set_property  -dict {PACKAGE_PIN    J16   IOSTANDARD LVCMOS18} [get_ports gpio_status[2]]                    ; 
+set_property  -dict {PACKAGE_PIN    J15   IOSTANDARD LVCMOS18} [get_ports gpio_status[1]]                    ; 
+set_property  -dict {PACKAGE_PIN    T10   IOSTANDARD LVCMOS18} [get_ports gpio_status[0]]                    ; 
+set_property  -dict {PACKAGE_PIN    T11   IOSTANDARD LVCMOS18} [get_ports gpio_ctl[3]]                       ; 
+set_property  -dict {PACKAGE_PIN    V13   IOSTANDARD LVCMOS18} [get_ports gpio_ctl[2]]                       ; 
+set_property  -dict {PACKAGE_PIN    T14   IOSTANDARD LVCMOS18} [get_ports gpio_ctl[1]]                       ; 
+set_property  -dict {PACKAGE_PIN    U13   IOSTANDARD LVCMOS18} [get_ports gpio_ctl[0]]                       ; 
+set_property  -dict {PACKAGE_PIN    P16   IOSTANDARD LVCMOS18} [get_ports gpio_en_agc]                       ; 
+set_property  -dict {PACKAGE_PIN    U20   IOSTANDARD LVCMOS18} [get_ports gpio_sync]                         ; 
+set_property  -dict {PACKAGE_PIN    T17   IOSTANDARD LVCMOS18} [get_ports gpio_resetb]                       ; 
+set_property  -dict {PACKAGE_PIN    R18   IOSTANDARD LVCMOS18} [get_ports enable]                            ; 
+set_property  -dict {PACKAGE_PIN    N17   IOSTANDARD LVCMOS18} [get_ports txnrx]                             ; 
+
+set_property  -dict {PACKAGE_PIN    T20   IOSTANDARD LVCMOS18  PULLTYPE PULLUP} [get_ports spi_csn]          ; 
+set_property  -dict {PACKAGE_PIN    R19   IOSTANDARD LVCMOS18} [get_ports spi_clk]                           ; 
+set_property  -dict {PACKAGE_PIN    P18   IOSTANDARD LVCMOS18} [get_ports spi_mosi]                          ; 
+set_property  -dict {PACKAGE_PIN    T19   IOSTANDARD LVCMOS18} [get_ports spi_miso]                          ; 
+
+
+
+
+
+# constraints (pzsdr2.e)
+# ad9361
+
+set_property  -dict {PACKAGE_PIN  N20  IOSTANDARD LVCMOS18 }     [get_ports rx_clk_in]       ; 
+set_property  -dict {PACKAGE_PIN  P20  IOSTANDARD LVCMOS18 }     [get_ports rx_clk_in_n]     ; 
+set_property  -dict {PACKAGE_PIN  Y16  IOSTANDARD LVCMOS18 }     [get_ports rx_frame_in]     ; 
+set_property  -dict {PACKAGE_PIN  W14  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[11]]  ; 
+set_property  -dict {PACKAGE_PIN  Y14  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[10]]  ; 
+set_property  -dict {PACKAGE_PIN  V20  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[9]]   ; 
+set_property  -dict {PACKAGE_PIN  W20  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[8]]   ; 
+set_property  -dict {PACKAGE_PIN  R16  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[7]]   ; 
+set_property  -dict {PACKAGE_PIN  R17  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[6]]   ; 
+set_property  -dict {PACKAGE_PIN  W18  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[5]]   ; 
+set_property  -dict {PACKAGE_PIN  W19  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[4]]   ; 
+set_property  -dict {PACKAGE_PIN  V17  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[3]]   ; 
+set_property  -dict {PACKAGE_PIN  V18  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[2]]   ; 
+set_property  -dict {PACKAGE_PIN  Y18  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[1]]   ; 
+set_property  -dict {PACKAGE_PIN  Y19  IOSTANDARD LVCMOS18 }     [get_ports rx_data_in[0]]   ; 
+set_property  -dict {PACKAGE_PIN  N18  IOSTANDARD LVCMOS18 }     [get_ports tx_clk_out]      ; 
+set_property  -dict {PACKAGE_PIN  V16  IOSTANDARD LVCMOS18 }     [get_ports tx_frame_out]    ; 
+set_property  -dict {PACKAGE_PIN  V15  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[11]] ; 
+set_property  -dict {PACKAGE_PIN  W15  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[10]] ; 
+set_property  -dict {PACKAGE_PIN  T12  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[9]]  ; 
+set_property  -dict {PACKAGE_PIN  U12  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[8]]  ; 
+set_property  -dict {PACKAGE_PIN  V12  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[7]]  ; 
+set_property  -dict {PACKAGE_PIN  W13  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[6]]  ; 
+set_property  -dict {PACKAGE_PIN  U14  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[5]]  ; 
+set_property  -dict {PACKAGE_PIN  U15  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[4]]  ; 
+set_property  -dict {PACKAGE_PIN  U18  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[3]]  ; 
+set_property  -dict {PACKAGE_PIN  U19  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[2]]  ; 
+set_property  -dict {PACKAGE_PIN  T16  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[1]]  ; 
+set_property  -dict {PACKAGE_PIN  U17  IOSTANDARD LVCMOS18 }     [get_ports tx_data_out[0]]  ; 
+
+
+
+# TX_AMP_EN	    G15
+# FPGA_GCLK1	K17
+# EEPROM_I2C_SDA	C6
+# EEPROM_I2C_SCL	E9
+
+
+
+create_clock -name rx_clk -period  16.27 [get_ports rx_clk_in]
+create_clock -name clk_fpga_0 -period 10 [get_pins "i_system_wrapper/system_i/sys_ps7/inst/PS7_i/FCLKCLK[0]"]
+create_clock -name clk_fpga_1 -period  5 [get_pins "i_system_wrapper/system_i/sys_ps7/inst/PS7_i/FCLKCLK[1]"]
+
+create_clock -name spi0_clk      -period 40   [get_pins -hier */EMIOSPI0SCLKO]
+
+set_input_jitter clk_fpga_0 0.3
+set_input_jitter clk_fpga_1 0.15
+
+
+set_property  -dict {PACKAGE_PIN   Y9    IOSTANDARD LVCMOS33} [get_ports GPIOB[7]]                    ; 
+set_property  -dict {PACKAGE_PIN   Y6    IOSTANDARD LVCMOS33} [get_ports GPIOB[6]]                    ; 
+set_property  -dict {PACKAGE_PIN   Y7    IOSTANDARD LVCMOS33} [get_ports GPIOB[5]]                    ; 
+set_property  -dict {PACKAGE_PIN   U10   IOSTANDARD LVCMOS33} [get_ports GPIOB[4]]                    ; 
+set_property  -dict {PACKAGE_PIN   T9    IOSTANDARD LVCMOS33} [get_ports GPIOB[3]]                    ; 
+set_property  -dict {PACKAGE_PIN   V7    IOSTANDARD LVCMOS33} [get_ports GPIOB[2]]                    ; 
+set_property  -dict {PACKAGE_PIN   U7    IOSTANDARD LVCMOS33} [get_ports GPIOB[1]]                    ; 
+set_property  -dict {PACKAGE_PIN   V5    IOSTANDARD LVCMOS33} [get_ports GPIOB[0]]                    ;
+
+
+
+                                        
\ No newline at end of file
diff --git a/projects/antsdre200/system_project.tcl b/projects/antsdre200/system_project.tcl
new file mode 100644
index 000000000..fe077b48d
--- /dev/null
+++ b/projects/antsdre200/system_project.tcl
@@ -0,0 +1,19 @@
+
+source ../scripts/adi_env.tcl
+source $ad_hdl_dir/projects/scripts/adi_project_xilinx.tcl
+source $ad_hdl_dir/projects/scripts/adi_board.tcl
+
+set p_device "xc7z020clg400-2"
+adi_project antsdre200
+
+adi_project_files antsdre200 [list \
+  "system_top.v" \
+  "ppsloop.v" \
+  "ltc2630_spi.v" \
+  "system_constr.xdc" \
+  "$ad_hdl_dir/library/common/ad_iobuf.v"]
+
+set_property is_enabled false [get_files  *system_sys_ps7_0.xdc]
+adi_project_run antsdre200
+source $ad_hdl_dir/library/axi_ad9361/axi_ad9361_delay.tcl
+
diff --git a/projects/antsdre200/system_top.v b/projects/antsdre200/system_top.v
new file mode 100644
index 000000000..5f00556c8
--- /dev/null
+++ b/projects/antsdre200/system_top.v
@@ -0,0 +1,234 @@
+// ***************************************************************************
+// ***************************************************************************
+// Copyright 2014 - 2017 (c) Analog Devices, Inc. All rights reserved.
+//
+// In this HDL repository, there are many different and unique modules, consisting
+// of various HDL (Verilog or VHDL) components. The individual modules are
+// developed independently, and may be accompanied by separate and unique license
+// terms.
+//
+// The user should read each of these license terms, and understand the
+// freedoms and responsibilities that he or she has by using this source/core.
+//
+// This core is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+// A PARTICULAR PURPOSE.
+//
+// Redistribution and use of source or resulting binaries, with or without modification
+// of this file, are permitted under one of the following two license terms:
+//
+//   1. The GNU General Public License version 2 as published by the
+//      Free Software Foundation, which can be found in the top level directory
+//      of this repository (LICENSE_GPL2), and also online at:
+//      <https://www.gnu.org/licenses/old-licenses/gpl-2.0.html>
+//
+// OR
+//
+//   2. An ADI specific BSD license, which can be found in the top level directory
+//      of this repository (LICENSE_ADIBSD), and also on-line at:
+//      https://github.com/analogdevicesinc/hdl/blob/master/LICENSE_ADIBSD
+//      This will allow to generate bit files and not release the source code,
+//      as long as it attaches to an ADI device.
+//
+// ***************************************************************************
+// ***************************************************************************
+
+`timescale 1ns/100ps
+
+module system_top (
+  output          MDIO_PHY_mdc,
+  inout           MDIO_PHY_mdio_io,
+  input [3:0]     RGMII_rd,
+  input           RGMII_rx_ctl,
+  input           RGMII_rxc,
+  output [3:0]    RGMII_td,
+  output          RGMII_tx_ctl,
+  output          RGMII_txc,
+  output          eth_rst_n ,
+
+  inout   [14:0]  ddr_addr,
+  inout   [ 2:0]  ddr_ba,
+  inout           ddr_cas_n,
+  inout           ddr_ck_n,
+  inout           ddr_ck_p,
+  inout           ddr_cke,
+  inout           ddr_cs_n,
+  inout   [ 1:0]  ddr_dm,
+  inout   [31:0]  ddr_dq,
+  inout   [ 1:0]  ddr_dqs_n,
+  inout   [ 1:0]  ddr_dqs_p,
+  inout           ddr_odt,
+  inout           ddr_ras_n,
+  inout           ddr_reset_n,
+  inout           ddr_we_n,
+
+  inout           fixed_io_ddr_vrn,
+  inout           fixed_io_ddr_vrp,
+  inout   [31:0]  fixed_io_mio,
+  inout           fixed_io_ps_clk,
+  inout           fixed_io_ps_porb,
+  inout           fixed_io_ps_srstb,
+
+  inout           iic_scl,
+  inout           iic_sda,
+
+  input           rx_clk_in,
+  input           rx_frame_in,
+  input   [11:0]  rx_data_in,
+  output          tx_clk_out,
+  output          tx_frame_out,
+  output  [11:0]  tx_data_out,
+
+  output          enable,
+  output          txnrx,
+
+  inout           gpio_resetb,
+  inout           gpio_en_agc,
+  inout   [ 3:0]  gpio_ctl,
+  inout   [ 7:0]  gpio_status,
+
+  output          spi_csn,
+  output          spi_clk,
+  output          spi_mosi,
+  input           spi_miso,
+
+
+  // clock form vctcxo
+  input  wire	 			      CLK_40MHz_FPGA  ,
+  // PPS or 10 MHz (need to choose from SW)
+  input  wire             PPS_IN          ,
+  input  wire             CLKIN_10MHz     ,
+  output wire             CLKIN_10MHz_REQ ,
+
+  // Clock disciplining / AD5662 controls
+  output wire             CLK_40M_DAC_nSYNC,
+  output wire             CLK_40M_DAC_SCLK ,
+  output wire             CLK_40M_DAC_DIN ,
+
+  output                  tx_amp_en,
+
+  inout   [7:0]           GPIOB
+  );
+
+  // internal signals
+
+  wire    [63:0]  gpio_i;
+  wire    [63:0]  gpio_o;
+  wire    [63:0]  gpio_t;
+  wire            int_40mhz   ;
+  wire            ref_pll_clk ;
+  wire            locked      ;
+  wire            ref_sel;
+  wire            ext_ref;
+  wire            ext_ref_is_pps;
+  wire            ext_ref_locked;
+
+  // instantiations
+
+  ad_iobuf #(.DATA_WIDTH(14)) i_iobuf (
+    .dio_t (gpio_t[13:0]),
+    .dio_i (gpio_o[13:0]),
+    .dio_o (gpio_i[13:0]),
+    .dio_p ({ gpio_resetb,        // 13:13
+              gpio_en_agc,        // 12:12
+              gpio_ctl,           // 11: 8
+              gpio_status}));     //  7: 0
+
+  ad_iobuf #(.DATA_WIDTH(8)) gpio_io_buf (
+    .dio_t (gpio_t[42:35]),
+    .dio_i (gpio_o[42:35]),
+    .dio_o (gpio_i[42:35]),
+    .dio_p (GPIOB       )
+    );
+
+  assign gpio_i[31:17] = gpio_o[31:17];
+
+  assign gpio_i[32] = ext_ref_locked;
+  assign ext_ref_is_pps = gpio_o[33];
+  assign ref_sel = gpio_o[34];
+
+
+  assign tx_amp_en = 1'b1;
+  assign eth_rst_n = 1'b1;
+
+  assign ext_ref = ext_ref_is_pps ? PPS_IN : ref_sel ? CLKIN_10MHz : 1'b0;
+  assign CLKIN_10MHz_REQ = ref_sel;
+  ppsloop #(.DEVICE("LTC2630")
+  )u_ppsloop(
+      .xoclk   ( CLK_40MHz_FPGA   ),
+      .ppsgps  ( 1'b0  ),
+      .ppsext  ( ext_ref  ),
+      .refsel  ( 2'b11 ),
+      .lpps    (     ),
+      .is10meg (  ),
+      .ispps   (  ),
+      .reflck  ( ext_ref_locked ),
+      .plllck  (  ),
+      .sclk    ( CLK_40M_DAC_SCLK    ),
+      .mosi    ( CLK_40M_DAC_DIN    ),
+      .sync_n  ( CLK_40M_DAC_nSYNC  ),
+      .dac_dflt  ( 16'hBfff )
+  );
+
+  system_wrapper i_system_wrapper (
+    .MDIO_PHY_mdc(MDIO_PHY_mdc),
+    .MDIO_PHY_mdio_io(MDIO_PHY_mdio_io),
+    .RGMII_rd(RGMII_rd),
+    .RGMII_rx_ctl(RGMII_rx_ctl),
+    .RGMII_rxc(RGMII_rxc),
+    .RGMII_td(RGMII_td),
+    .RGMII_tx_ctl(RGMII_tx_ctl),
+    .RGMII_txc(RGMII_txc),
+    .eth_rst_n(),
+    .ddr_addr (ddr_addr),
+    .ddr_ba (ddr_ba),
+    .ddr_cas_n (ddr_cas_n),
+    .ddr_ck_n (ddr_ck_n),
+    .ddr_ck_p (ddr_ck_p),
+    .ddr_cke (ddr_cke),
+    .ddr_cs_n (ddr_cs_n),
+    .ddr_dm (ddr_dm),
+    .ddr_dq (ddr_dq),
+    .ddr_dqs_n (ddr_dqs_n),
+    .ddr_dqs_p (ddr_dqs_p),
+    .ddr_odt (ddr_odt),
+    .ddr_ras_n (ddr_ras_n),
+    .ddr_reset_n (ddr_reset_n),
+    .ddr_we_n (ddr_we_n),
+    .enable (enable),
+    .fixed_io_ddr_vrn (fixed_io_ddr_vrn),
+    .fixed_io_ddr_vrp (fixed_io_ddr_vrp),
+    .fixed_io_mio (fixed_io_mio),
+    .fixed_io_ps_clk (fixed_io_ps_clk),
+    .fixed_io_ps_porb (fixed_io_ps_porb),
+    .fixed_io_ps_srstb (fixed_io_ps_srstb),
+    .gpio_i (gpio_i),
+    .gpio_o (gpio_o),
+    .gpio_t (gpio_t),
+    .rx_clk_in (rx_clk_in),
+    .rx_data_in (rx_data_in),
+    .rx_frame_in (rx_frame_in),
+
+    .spi0_clk_i (1'b0),
+    .spi0_clk_o (spi_clk),
+    .spi0_csn_0_o (spi_csn),
+    .spi0_csn_1_o (),
+    .spi0_csn_2_o (),
+    .spi0_csn_i (1'b1),
+    .spi0_sdi_i (spi_miso),
+    .spi0_sdo_i (1'b0),
+    .spi0_sdo_o (spi_mosi),
+
+
+    .tx_clk_out (tx_clk_out),
+    .tx_data_out (tx_data_out),
+    .tx_frame_out (tx_frame_out),
+    .txnrx (txnrx),
+    .up_enable (gpio_o[15]),
+    .up_txnrx (gpio_o[16]));
+
+endmodule
+
+// ***************************************************************************
+// ***************************************************************************
+
-- 
2.25.1

